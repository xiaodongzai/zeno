{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"helper.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/utils/helper.ts"],"sourcesContent":["import { Primitive } from '../../runtime';\n\nexport function column(value: Primitive[], field?: string) {\n  if (value === null) return undefined;\n  return { type: 'column', value, field };\n}\n\nexport function inferredColumn(value: Primitive[], field?: string) {\n  const c = column(value, field);\n  return { ...c, inferred: true };\n}\n\nexport function visualColumn(value: Primitive[], field?: string) {\n  if (value === null) return undefined;\n  return { type: 'column', value, field, visual: true };\n}\n\nexport function nonConstantColumn(value: Primitive[], field?: string) {\n  const c = column(value, field);\n  return { ...c, constant: false };\n}\n\nexport function constant(I: number[], value: any) {\n  const array = [];\n  for (const i of I) array[i] = value;\n  return array;\n}\n\nexport function columnOf(encode, key: string): [Primitive[], string] {\n  const channel = encode[key];\n  if (!channel) return [null, null];\n  const { value, field = null } = channel;\n  return [value, field];\n}\n\nexport function maybeColumnOf(\n  encode,\n  ...K: (string | Primitive[])[]\n): [Primitive[], string] {\n  for (const key of K) {\n    if (typeof key === 'string') {\n      const [KV, fv] = columnOf(encode, key);\n      if (KV !== null) return [KV, fv];\n    } else {\n      return [key, null];\n    }\n  }\n  return [null, null];\n}\n\nexport function isObject(d) {\n  if (d instanceof Date) return false;\n  return typeof d === 'object';\n}\n"],"names":[],"mappings":";;;;;;;;;;AAEM,SAAU,MAAM,CAAC,KAAkB,EAAE,KAAc;IACvD,IAAI,KAAK,KAAK,IAAI,EAAE,OAAO,SAAS,CAAC;IACrC,OAAO;QAAE,IAAI,EAAE,QAAQ;QAAE,KAAK;QAAE,KAAK;IAAA,CAAE,CAAC;AAC1C,CAAC;AAEK,SAAU,cAAc,CAAC,KAAkB,EAAE,KAAc;IAC/D,MAAM,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC/B,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAY,CAAC,GAAA;QAAE,QAAQ,EAAE,IAAI;IAAA,GAAG;AAClC,CAAC;AAEK,SAAU,YAAY,CAAC,KAAkB,EAAE,KAAc;IAC7D,IAAI,KAAK,KAAK,IAAI,EAAE,OAAO,SAAS,CAAC;IACrC,OAAO;QAAE,IAAI,EAAE,QAAQ;QAAE,KAAK;QAAE,KAAK;QAAE,MAAM,EAAE,IAAI;IAAA,CAAE,CAAC;AACxD,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAkB,EAAE,KAAc;IAClE,MAAM,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC/B,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAY,CAAC,GAAA;QAAE,QAAQ,EAAE,KAAK;IAAA,GAAG;AACnC,CAAC;AAEK,SAAU,QAAQ,CAAC,CAAW,EAAE,KAAU;IAC9C,MAAM,KAAK,GAAG,EAAE,CAAC;IACjB,KAAK,MAAM,CAAC,IAAI,CAAC,CAAE,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;IACpC,OAAO,KAAK,CAAC;AACf,CAAC;AAEK,SAAU,QAAQ,CAAC,MAAM,EAAE,GAAW;IAC1C,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;IAC5B,IAAI,CAAC,OAAO,EAAE,OAAO;QAAC,IAAI;QAAE,IAAI;KAAC,CAAC;IAClC,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;IACxC,OAAO;QAAC,KAAK;QAAE,KAAK;KAAC,CAAC;AACxB,CAAC;AAEK,SAAU,aAAa,CAC3B,MAAM,EACN,GAAG,CAA2B;IAE9B,KAAK,MAAM,GAAG,IAAI,CAAC,CAAE;QACnB,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YAC3B,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;YACvC,IAAI,EAAE,KAAK,IAAI,EAAE,OAAO;gBAAC,EAAE;gBAAE,EAAE;aAAC,CAAC;SAClC,MAAM;YACL,OAAO;gBAAC,GAAG;gBAAE,IAAI;aAAC,CAAC;SACpB;KACF;IACD,OAAO;QAAC,IAAI;QAAE,IAAI;KAAC,CAAC;AACtB,CAAC;AAEK,SAAU,QAAQ,CAAC,CAAC;IACxB,IAAI,CAAC,YAAY,IAAI,EAAE,OAAO,KAAK,CAAC;IACpC,OAAO,OAAO,CAAC,KAAK,QAAQ,CAAC;AAC/B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"file":"maybeTitle.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeTitle.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { isUnset } from '../utils/helper';\nimport { TransformComponent as TC } from '../runtime';\nimport { dynamicFormatDateTime } from '../utils/dateFormat';\nimport { columnOf } from './utils/helper';\n\nexport type MaybeTitleOptions = {\n  channel?: string;\n};\n\n/**\n * Infer title channel from x-position channel.\n */\nexport const MaybeTitle: TC<MaybeTitleOptions> = (options = {}) => {\n  const { channel = 'x' } = options;\n  return (I, mark) => {\n    const { encode } = mark;\n    const { tooltip } = mark;\n    if (isUnset(tooltip)) return [I, mark];\n    const { title } = tooltip;\n    if (title !== undefined) return [I, mark];\n    const titles = Object.keys(encode)\n      .filter((key) => key.startsWith(channel))\n      .filter((key) => !encode[key].inferred)\n      .map((key) => columnOf(encode, key))\n      .filter(([T]) => T)\n      .map((d) => d[0]);\n    if (titles.length === 0) return [I, mark];\n    const T = [];\n    for (const i of I) {\n      T[i] = {\n        value: titles\n          .map((t) =>\n            t[i] instanceof Date ? dynamicFormatDateTime(t[i] as Date) : t[i],\n          )\n          .join(', '),\n      };\n    }\n    return [\n      I,\n      deepMix({}, mark, {\n        tooltip: {\n          title: T,\n        },\n      }),\n    ];\n  };\n};\n\nMaybeTitle.props = {};\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAG1C,OAAO,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAD1C,OAAO,EAAE,qBAAqB,EAAE,MAAM,qBAAqB,CAAC;AAH5D,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;;AAa9B,MAAM,UAAU,GAA0B,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAChE,MAAM,EAAE,OAAO,GAAG,GAAG,EAAE,GAAG,OAAO,CAAC;IAClC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QACzB,+JAAI,UAAA,AAAO,EAAC,OAAO,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACvC,MAAM,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC;QAC1B,IAAI,KAAK,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAC1C,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAC/B,MAAM,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,EAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CACxC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,AAAE,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CACtC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,uKAAC,WAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CACnC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAClB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACpB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAC1C,MAAM,CAAC,GAAG,EAAE,CAAC;QACb,KAAK,MAAM,CAAC,IAAI,CAAC,CAAE;YACjB,CAAC,CAAC,CAAC,CAAC,GAAG;gBACL,KAAK,EAAE,MAAM,CACV,GAAG,CAAC,CAAC,CAAC,EAAE,CACP,CADS,AACR,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC,gKAAC,wBAAqB,AAArB,EAAsB,CAAC,CAAC,CAAC,CAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAClE,CACA,IAAI,CAAC,IAAI,CAAC;aACd,CAAC;SACH;QACD,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,OAAO,EAAE;oBACP,KAAK,EAAE,CAAC;iBACT;aACF,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,UAAU,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"file":"maybeTooltip.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeTooltip.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { isUnset } from '../utils/helper';\nimport { TransformComponent as TC } from '../runtime';\n\nexport type MaybeTooltipOptions = {\n  channel: string | string[];\n};\n\n/**\n * Infer tooltip channel from specified channel.\n */\nexport const MaybeTooltip: TC<MaybeTooltipOptions> = (options) => {\n  const { channel } = options;\n  return (I, mark) => {\n    const { encode, tooltip } = mark;\n    if (isUnset(tooltip)) return [I, mark];\n    const { items = [] } = tooltip;\n    if (!items || items.length > 0) return [I, mark];\n    const channels = Array.isArray(channel) ? channel : [channel];\n    const newItems = channels.flatMap((channel) =>\n      Object.keys(encode)\n        .filter((key) => key.startsWith(channel))\n        .map((key) => {\n          const { field, value, inferred = false, aggregate } = encode[key];\n          if (inferred) return null;\n          // Do not show inferred column.\n          if (aggregate && value) return { channel: key };\n          if (field) return { field };\n          if (value) return { channel: key };\n          return null;\n        })\n        .filter((d) => d !== null),\n    );\n    return [I, deepMix({}, mark, { tooltip: { items: newItems } })];\n  };\n};\n\nMaybeTooltip.props = {};\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAD1C,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAW9B,MAAM,YAAY,GAA4B,CAAC,OAAO,EAAE,EAAE;IAC/D,MAAM,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;IAC5B,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QACjC,QAAI,iKAAA,AAAO,EAAC,OAAO,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACvC,MAAM,EAAE,KAAK,GAAG,EAAE,EAAE,GAAG,OAAO,CAAC;QAC/B,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACjD,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YAAC,OAAO;SAAC,CAAC;QAC9D,MAAM,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAC1C,CAD4C,KACtC,CAAC,IAAI,CAAC,MAAM,CAAC,CAChB,MAAM,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,EAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CACxC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;gBACX,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,GAAG,KAAK,EAAE,SAAS,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;gBAClE,IAAI,QAAQ,EAAE,OAAO,IAAI,CAAC;gBAC1B,+BAA+B;gBAC/B,IAAI,SAAS,IAAI,KAAK,EAAE,OAAO;oBAAE,OAAO,EAAE,GAAG;gBAAA,CAAE,CAAC;gBAChD,IAAI,KAAK,EAAE,OAAO;oBAAE,KAAK;gBAAA,CAAE,CAAC;gBAC5B,IAAI,KAAK,EAAE,OAAO;oBAAE,OAAO,EAAE,GAAG;gBAAA,CAAE,CAAC;gBACnC,OAAO,IAAI,CAAC;YACd,CAAC,CAAC,CACD,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,KAAK,IAAI,CAAC,CAC7B,CAAC;QACF,OAAO;YAAC,CAAC;qNAAE,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,OAAO,EAAE;oBAAE,KAAK,EAAE,QAAQ;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IAClE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,YAAY,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"file":"maybeKey.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeKey.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column } from './utils/helper';\n\nexport type MaybeKeyOptions = Record<string, never>;\n\n/**\n * Infer key for every element.\n */\nexport const MaybeKey: TC<MaybeKeyOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { key, ...rest } = encode;\n    if (key !== undefined) return [I, mark];\n    const values = Object.values(rest).map(({ value }) => value);\n    const K = I.map((i) =>\n      values\n        .filter(Array.isArray)\n        .map((V) => V[i])\n        .join('-'),\n    );\n    return [I, deepMix({}, mark, { encode: { key: column(K) } })];\n  };\n};\n\nMaybeKey.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;;;;;;;;;;;AAOjC,MAAM,QAAQ,GAAwB,GAAG,EAAE;IAChD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,GAAG,EAAA,GAAc,MAAM,EAAf,IAAI,GAAA,OAAK,MAAM,EAAzB;YAAA;SAAgB,CAAS,CAAC;QAChC,IAAI,GAAG,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACxC,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAG,CAAD,IAAM,CAAC,CAAC;QAC7D,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAClB,CADoB,KACd,CACH,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CACrB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAChB,IAAI,CAAC,GAAG,CAAC,CACb,CAAC;QACF,OAAO;YAAC,CAAC;qNAAE,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,GAAG,0KAAE,SAAA,AAAM,EAAC,CAAC,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IAChE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,QAAQ,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"file":"order.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/utils/order.ts"],"sourcesContent":["import { group, ascending, maxIndex, Primitive } from '@antv/vendor/d3-array';\nimport { defined } from '../../utils/helper';\nimport { TabularData, G2Mark } from '../../runtime';\nimport { indexOf } from '../../utils/array';\nimport { columnOf } from './helper';\n\nexport type IndexComparatorFactory = (\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n) => IndexComparator;\n\nexport type IndexComparator = (i: number, j: number) => number;\n\nexport type Order =\n  | 'value'\n  | 'sum'\n  | 'series'\n  | 'maxIndex'\n  | string[]\n  | ((data: Record<string, Primitive>) => Primitive);\n\nexport function createGroups(\n  groupBy: string | string[],\n  I: number[],\n  mark: G2Mark,\n): number[][] {\n  const { encode } = mark;\n  if (groupBy === null) return [I];\n  const G = normalizeGroupBy(groupBy)\n    .map((k) => [k, columnOf(encode, k)?.[0]] as const)\n    .filter(([, column]) => defined(column));\n  const key = (i: number) => G.map(([, V]) => V[i]).join('-');\n  return Array.from(group(I, key).values());\n}\n\nexport function normalizeComparator(\n  order: Order,\n): IndexComparatorFactory | null {\n  if (Array.isArray(order)) return createFieldsOrder(order);\n  if (typeof order === 'function') return createFunctionOrder(order);\n  if (order === 'series') return createSeriesOrder;\n  if (order === 'value') return createValueOrder;\n  if (order === 'sum') return createSumOrder;\n  if (order === 'maxIndex') return createMaxIndexOrder;\n  return null;\n}\n\nexport function applyOrder(groups: number[][], comparator: IndexComparator) {\n  for (const group of groups) {\n    group.sort(comparator);\n  }\n}\n\nexport function domainOf(value: Primitive[], scale: Record<string, any>) {\n  return scale?.domain || Array.from(new Set(value));\n}\n\nfunction normalizeGroupBy(groupBy: string | string[]): string[] {\n  if (Array.isArray(groupBy)) return groupBy;\n  return [groupBy];\n}\n\nfunction createSeriesOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  return ascendingComparator((i: number) => S[i]);\n}\n\nfunction createFunctionOrder(\n  order: (data: Record<string, Primitive>) => Primitive,\n): IndexComparatorFactory {\n  return (data, Y, S) => {\n    return ascendingComparator((i) => order(data[i]));\n  };\n}\n\nfunction createFieldsOrder(order: string[]): IndexComparatorFactory {\n  return (data, Y, S) => {\n    return (i, j) =>\n      order.reduce(\n        (eq, f) => (eq !== 0 ? eq : ascending(data[i][f], data[j][f])),\n        0,\n      );\n  };\n}\n\nfunction createValueOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  return ascendingComparator((i: number) => Y[i]);\n}\n\nfunction createSumOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  const I = indexOf(data);\n  const groups = Array.from(group(I, (i) => S[+i]).entries());\n  const seriesSum = new Map(\n    groups.map(([k, GI]) => [k, GI.reduce((s, i) => s + +Y[i])] as const),\n  );\n  return ascendingComparator((i: number) => seriesSum.get(S[i]));\n}\n\nfunction createMaxIndexOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  const I = indexOf(data);\n  const groups = Array.from(group(I, (i) => S[+i]).entries());\n  const seriesMaxIndex = new Map(\n    groups.map(([k, GI]) => [k, maxIndex(GI, (i) => Y[i])] as const),\n  );\n  return ascendingComparator((i: number) => seriesMaxIndex.get(S[i]));\n}\n\nfunction ascendingComparator(order: (i: number) => any): IndexComparator {\n  return (i, j) => ascending(order(i), order(j));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"file":"stackY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/stackY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { StackYTransform } from '../spec';\nimport {\n  column,\n  columnOf,\n  inferredColumn,\n  maybeColumnOf,\n} from './utils/helper';\nimport { normalizeComparator, createGroups, applyOrder } from './utils/order';\n\nexport type StackYOptions = Omit<StackYTransform, 'type'>;\n\n/**\n * The stack transform group marks into series by color channel,\n * and then produce new y channel for each series by specified order,\n * say to form vertical \"stacks\" by specified channels.\n */\nexport const StackY: TC<StackYOptions> = (options = {}) => {\n  const {\n    groupBy = 'x',\n    orderBy = null,\n    reverse = false,\n    y: fromY = 'y',\n    y1: fromY1 = 'y1',\n    series = true,\n  } = options;\n  return (I, mark) => {\n    const { data, encode, style = {} } = mark;\n    const [Y, fy] = columnOf(encode, 'y');\n    const [Y1, fy1] = columnOf(encode, 'y1');\n    const [S] = series\n      ? maybeColumnOf(encode, 'series', 'color')\n      : columnOf(encode, 'color');\n\n    // Create groups and apply specified order for each group.\n    const groups = createGroups(groupBy, I, mark);\n    const createComparator = normalizeComparator(orderBy) ?? (() => null);\n    const comparator = createComparator(data, Y, S);\n    if (comparator) applyOrder(groups, comparator);\n\n    // Stack y channels to produce new y and y1 channel.\n    const newY = new Array(I.length);\n    const newY1 = new Array(I.length);\n    const TY = new Array(I.length);\n    const F = [];\n    const L = [];\n    for (const G of groups) {\n      if (reverse) G.reverse();\n      // For range interval with specified y and y1.\n      const start = Y1 ? +Y1[G[0]] : 0;\n\n      // Split positive indices of Y and negative Y.\n      const PG = [];\n      const NG = [];\n      for (const i of G) {\n        const y = (TY[i] = +Y[i] - start);\n        if (y < 0) NG.push(i);\n        else if (y >= 0) PG.push(i);\n      }\n\n      // Store the first and last layer.\n      const FG = PG.length > 0 ? PG : NG;\n      const LG = NG.length > 0 ? NG : PG;\n      let i = PG.length - 1;\n      let j = 0;\n      // Find the last non-zero index.\n      while (i > 0 && Y[FG[i]] === 0) i--;\n      // Find the first non-zero index.\n      while (j < LG.length - 1 && Y[LG[j]] === 0) j++;\n      F.push(FG[i]);\n      L.push(LG[j]);\n\n      // Stack negative y in reverse order.\n      let ny = start;\n      for (const i of NG.reverse()) {\n        const y = TY[i];\n        ny = newY[i] = (newY1[i] = ny) + y;\n      }\n\n      // Stack positive y in input order.\n      let py = start;\n      for (const i of PG) {\n        const y = TY[i];\n        if (y > 0) py = newY[i] = (newY1[i] = py) + y;\n        else newY[i] = newY1[i] = py;\n      }\n    }\n\n    // Only set top radius for the first layer,\n    // and set bottom radius for the last layer.\n    const FS = new Set(F);\n    const LS = new Set(L);\n\n    // Choose new y or y1 channel as the new y channel.\n    const V = fromY === 'y' ? newY : newY1;\n    const V1 = fromY1 === 'y' ? newY : newY1;\n    let newEncode: Record<string, any>;\n    // mark point will compute the actural Y = (y + y1) / 2 if y1 exists\n    if (mark.type === 'point') {\n      newEncode = {\n        y0: inferredColumn(Y, fy), // Store original Y.\n        y: column(V, fy),\n      };\n    } else {\n      newEncode = {\n        y0: inferredColumn(Y, fy), // Store original Y.\n        y: column(V, fy),\n        y1: column(V1, fy1),\n      };\n    }\n\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: {\n          ...newEncode,\n        },\n        style: {\n          first: (_, i) => FS.has(i),\n          last: (_, i) => LS.has(i),\n          ...style,\n        },\n      }),\n    ];\n  };\n};\n\nStackY.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 448, "column": 0}, "map": {"version":3,"file":"groupN.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/groupN.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport {\n  max as d3Max,\n  mean as d3Mean,\n  sum as d3Sum,\n  min as d3Min,\n  median as d3Median,\n} from '@antv/vendor/d3-array';\nimport { TransformComponent as TC, Primitive, G2Mark } from '../runtime';\nimport { GroupTransform, Reducer } from '../spec';\nimport { indexOf } from '../utils/array';\nimport { columnOf, column, nonConstantColumn } from './utils/helper';\n\nexport type GroupNOptions = Omit<\n  GroupTransform & {\n    groupBy?: (\n      I: number[],\n      mark: G2Mark,\n      options?: Record<string, any>,\n    ) => number[][];\n  },\n  'type' | 'channels'\n>;\n\ntype ReducerFunction = (I: number[], V: Primitive[]) => Primitive;\n\ntype Formatter = (d: Primitive) => string;\n\nfunction builtinFormatter(summary: string) {\n  return (d: string) => (d === null ? summary : `${summary} of ${d}`);\n}\n\nfunction normalizeReducer(reducer: Reducer): [ReducerFunction, Formatter] {\n  if (typeof reducer === 'function') return [reducer, null];\n  const registry = { mean, max, count, first, last, sum, min, median };\n  const reducerFunction = registry[reducer];\n  if (!reducerFunction) throw new Error(`Unknown reducer: ${reducer}.`);\n  return reducerFunction();\n}\n\nfunction mean(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Mean(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('mean');\n  return [reducer, formatter];\n}\n\nfunction median(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Median(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('median');\n  return [reducer, formatter];\n}\n\nfunction max(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Max(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('max');\n  return [reducer, formatter];\n}\n\nfunction min(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Min(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('min');\n  return [reducer, formatter];\n}\n\nfunction count(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => I.length;\n  const formatter: Formatter = builtinFormatter('count');\n  return [reducer, formatter];\n}\n\nfunction sum(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Sum(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('sum');\n  return [reducer, formatter];\n}\n\nfunction first(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => V[I[0]];\n  const formatter: Formatter = builtinFormatter('first');\n  return [reducer, formatter];\n}\n\nfunction last(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => V[I[I.length - 1]];\n  const formatter: Formatter = builtinFormatter('last');\n  return [reducer, formatter];\n}\n\n/**\n * The Group transform group data by x and y channels, and aggregate.\n */\nexport const GroupN: TC<GroupNOptions> = (options = {}) => {\n  const { groupBy, ...rest } = options;\n  return (I, mark) => {\n    const { data, encode } = mark;\n    const groups = groupBy(I, mark);\n    if (!groups) return [I, mark];\n\n    // Extract field from from channel\n    // x1 from x, y1 from y, etc,.\n    const maybeFrom = (field, reducer) => {\n      if (field) return field;\n      const { from } = reducer;\n      if (!from) return field;\n      const [, field1] = columnOf(encode, from);\n      return field1;\n    };\n    const outputs = Object.entries(rest).map(([channel, reducer]) => {\n      const [reducerFunction, formatter] = normalizeReducer(reducer);\n      const [V, field] = columnOf(encode, channel);\n      const field1 = maybeFrom(field, reducer);\n      const RV = groups.map((I) => reducerFunction(I, V ?? data));\n      return [\n        channel,\n        {\n          ...nonConstantColumn(RV, formatter?.(field1) || field1),\n          aggregate: true,\n        },\n      ];\n    });\n    const reducedColumns = Object.keys(encode).map((key) => {\n      const [V, fv] = columnOf(encode, key);\n      const GV = groups.map((I) => V[I[0]]);\n      return [key, column(GV, fv)];\n    });\n    const GD = groups.map((I) => data[I[0]]);\n    const GI = indexOf(groups);\n    return [\n      GI,\n      deepMix({}, mark, {\n        data: GD,\n        encode: Object.fromEntries([...reducedColumns, ...outputs]),\n      }),\n    ];\n  };\n};\n\nGroupN.props = {};\n"],"names":[],"mappings":";;;AACA,OAAO,EACL,GAAG,IAAI,KAAK,EACZ,IAAI,IAAI,MAAM,EACd,GAAG,IAAI,KAAK,EACZ,GAAG,IAAI,KAAK,EACZ,MAAM,IAAI,QAAQ,GACnB,MAAM,uBAAuB,CAAC;AAI/B,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AADrE,OAAO,EAAE,OAAO,EAAE,MAAM,gBAAgB,CAAC;AAVzC,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;;;;;;;;;;;;;;;AA4BrC,SAAS,gBAAgB,CAAC,OAAe;IACvC,OAAO,CAAC,CAAS,EAAE,CAAI,CAAF,AAAG,CAAF,IAAO,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,IAAA,EAAO,CAAC,EAAE,CAAC,CAAC;AACtE,CAAC;AAED,SAAS,gBAAgB,CAAC,OAAgB;IACxC,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE,OAAO;QAAC,OAAO;QAAE,IAAI;KAAC,CAAC;IAC1D,MAAM,QAAQ,GAAG;QAAE,IAAI;QAAE,GAAG;QAAE,KAAK;QAAE,KAAK;QAAE,IAAI;QAAE,GAAG;QAAE,GAAG;QAAE,MAAM;IAAA,CAAE,CAAC;IACrE,MAAM,eAAe,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC1C,IAAI,CAAC,eAAe,EAAE,MAAM,IAAI,KAAK,CAAC,CAAA,iBAAA,EAAoB,OAAO,CAAA,CAAA,CAAG,CAAC,CAAC;IACtE,OAAO,eAAe,EAAE,CAAC;AAC3B,CAAC;AAED,SAAS,IAAI;IACX,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,iLAAC,OAAA,AAAM,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnE,MAAM,SAAS,GAAc,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACtD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,MAAM;IACb,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,AAAC,8LAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACrE,MAAM,SAAS,GAAc,gBAAgB,CAAC,QAAQ,CAAC,CAAC;IACxD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,GAAG;IACV,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,+KAAC,MAAA,AAAK,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClE,MAAM,SAAS,GAAc,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACrD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,GAAG;IACV,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,+KAAC,MAAA,AAAK,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClE,MAAM,SAAS,GAAc,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACrD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,KAAK;IACZ,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,MAAM,CAAC;IACpD,MAAM,SAAS,GAAc,gBAAgB,CAAC,OAAO,CAAC,CAAC;IACvD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,GAAG;IACV,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,GAAC,kLAAA,AAAK,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClE,MAAM,SAAS,GAAc,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACrD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,KAAK;IACZ,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,MAAM,SAAS,GAAc,gBAAgB,CAAC,OAAO,CAAC,CAAC;IACvD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAED,SAAS,IAAI;IACX,MAAM,OAAO,GAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9D,MAAM,SAAS,GAAc,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACtD,OAAO;QAAC,OAAO;QAAE,SAAS;KAAC,CAAC;AAC9B,CAAC;AAKM,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,MAAM,EAAE,OAAO,EAAA,GAAc,OAAO,EAAhB,IAAI,GAAA,OAAK,OAAO,EAA9B;QAAA;KAAoB,CAAU,CAAC;IACrC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QAC9B,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;QAChC,IAAI,CAAC,MAAM,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAE9B,kCAAkC;QAClC,8BAA8B;QAC9B,MAAM,SAAS,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;YACnC,IAAI,KAAK,EAAE,OAAO,KAAK,CAAC;YACxB,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;YACzB,IAAI,CAAC,IAAI,EAAE,OAAO,KAAK,CAAC;YACxB,MAAM,CAAC,EAAE,MAAM,CAAC,IAAG,kLAAA,AAAQ,EAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAC1C,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC;QACF,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE,EAAE;YAC9D,MAAM,CAAC,eAAe,EAAE,SAAS,CAAC,GAAG,gBAAgB,CAAC,OAAO,CAAC,CAAC;YAC/D,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAC7C,MAAM,MAAM,GAAG,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACzC,MAAM,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,cAAgB,CAAC,CAAC,EAAE,CAAC,KAAA,QAAD,CAAC,KAAA,KAAA,IAAD,CAAC,GAAI,IAAI,CAAC,CAAC,CAAC;YAC5D,OAAO;gBACL,OAAO;iDAEF,2LAAA,AAAiB,EAAC,EAAE,EAAE,CAAA,SAAS,KAAA,QAAT,SAAS,KAAA,KAAA,IAAA,KAAA,IAAT,SAAS,CAAG,MAAM,CAAC,KAAI,MAAM,CAAC,GAAA;oBACvD,SAAS,EAAE,IAAI;gBAAA;aAElB,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;YACrD,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,IAAG,kLAAQ,AAAR,EAAS,MAAM,EAAE,GAAG,CAAC,CAAC;YACtC,MAAM,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,OAAO;gBAAC,GAAG;wLAAE,SAAA,AAAM,EAAC,EAAE,EAAE,EAAE,CAAC;aAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;QACH,MAAM,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,MAAM,EAAE,6JAAG,UAAA,AAAO,EAAC,MAAM,CAAC,CAAC;QAC3B,OAAO;YACL,EAAE;qNACF,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;uBAAG,cAAc,EAAE;uBAAG,OAAO;iBAAC,CAAC;aAC5D,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 619, "column": 0}, "map": {"version":3,"file":"bin.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/bin.ts"],"sourcesContent":["import {\n  bin as d3Bin,\n  group,\n  thresholdScott,\n  extent,\n} from '@antv/vendor/d3-array';\nimport { defined, subObject } from '../utils/helper';\nimport { TransformComponent as TC } from '../runtime';\nimport { BinTransform } from '../spec';\nimport { GroupN } from './groupN';\nimport { columnOf } from './utils/helper';\n\nexport type BinOptions = Omit<BinTransform, 'type'> & {\n  groupChannels?: string[];\n  binChannels?: string[];\n};\n\nconst THRESHOLD = 'thresholds';\n\n/**\n * @see https://github.com/observablehq/plot/blob/main/src/transforms/bin.js\n */\nfunction thresholdAuto(values: number[]) {\n  const [min, max] = extent(values);\n  return Math.min(200, thresholdScott(values, min, max));\n}\n\n/**\n * The Bin aggregate data.\n * @todo More threshold method.\n * @todo Performance.\n */\nexport const Bin: TC<BinOptions> = (options = {}) => {\n  const {\n    groupChannels = ['color'],\n    binChannels = ['x', 'y'],\n    ...rest\n  } = options;\n  const channelIndexKey = {};\n\n  // Group indexes and update channelIndexKey.\n  const groupBy = (I, mark): number[][] => {\n    const { encode } = mark;\n    const binValues = binChannels.map((channel) => {\n      const [V] = columnOf(encode, channel);\n      return V;\n    });\n    const thresholds = subObject(rest, THRESHOLD);\n    const DI = I.filter((i) => binValues.every((V) => defined(V[i])));\n\n    // Group indexes by both discrete and quantitative channels.\n    const groupKeys = [\n      // For discrete channels, use value as group key.\n      ...groupChannels\n        .map((d) => {\n          const [V] = columnOf(encode, d);\n          return V;\n        })\n        .filter(defined)\n        .map((V) => (i) => V[i]),\n\n      // For quantitative channels, use extent of bin as group key.\n      ...binChannels.map((d, i) => {\n        const V = binValues[i];\n        const t = thresholds[d] || thresholdAuto(V as number[]);\n        const bins = d3Bin()\n          .thresholds(t)\n          .value((i) => +V[i])(DI);\n        const indexKey = new Map(\n          bins.flatMap((bin) => {\n            const { x0, x1 } = bin;\n            const key = `${x0},${x1}`;\n            return bin.map((i) => [i, key]);\n          }),\n        );\n        channelIndexKey[d] = indexKey;\n        return (i) => indexKey.get(i);\n      }),\n    ];\n\n    // Group by indexes by channel keys.\n    const key = (i: number) => groupKeys.map((key) => key(i)).join('-');\n    return Array.from(group(DI, key).values()) as number[][];\n  };\n\n  return GroupN({\n    // Non-bin channel and reducer.\n    ...Object.fromEntries(\n      Object.entries(rest).filter(([k]) => !k.startsWith(THRESHOLD)),\n    ),\n    // Bin channel and reducer.\n    ...Object.fromEntries(\n      binChannels.flatMap((channel) => {\n        const start = ([i]) => +channelIndexKey[channel].get(i).split(',')[0];\n        const end = ([i]) => +channelIndexKey[channel].get(i).split(',')[1];\n        end.from = channel;\n        return [\n          [channel, start],\n          [`${channel}1`, end],\n        ];\n      }),\n    ),\n    groupBy,\n  });\n};\n\nBin.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 716, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 722, "column": 0}, "map": {"version":3,"file":"binX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/binX.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { BinXTransform } from '../spec';\nimport { Bin } from './bin';\n\nexport type BinXOptions = Omit<BinXTransform, 'type'>;\n\nexport const BinX: TC<BinXOptions> = (options = {}) => {\n  const { thresholds } = options;\n  return Bin({\n    ...options,\n    thresholdsX: thresholds,\n    groupChannels: ['color'],\n    binChannels: ['x'],\n  });\n};\n\nBinX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;;AAIrB,MAAM,IAAI,GAAoB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACpD,MAAM,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC;IAC/B,mKAAO,MAAA,AAAG,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,OAAO,GAAA;QACV,WAAW,EAAE,UAAU;QACvB,aAAa,EAAE;YAAC,OAAO;SAAC;QACxB,WAAW,EAAE;YAAC,GAAG;SAAC;IAAA,GAClB,CAAC;AACL,CAAC,CAAC;AAEF,IAAI,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 740, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 746, "column": 0}, "map": {"version":3,"file":"dodgeX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/dodgeX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { DodgeXTransform } from '../spec';\nimport { column, columnOf, maybeColumnOf } from './utils/helper';\nimport {\n  createGroups,\n  normalizeComparator,\n  applyOrder,\n  domainOf,\n} from './utils/order';\n\nexport type DodgeXOptions = Omit<DodgeXTransform, 'type'>;\n\n/**\n * The dodge group marks into series by color or series channel,\n * and then produce new series channel for each series by specified order,\n * say to form horizontal \"columns\" by specified channels.\n */\nexport const DodgeX: TC<DodgeXOptions> = (options = {}) => {\n  const { groupBy = 'x', reverse = false, orderBy, padding, ...rest } = options;\n  return (I, mark) => {\n    const { data, encode, scale } = mark;\n    const { series: scaleSeries } = scale;\n    const [Y] = columnOf(encode, 'y');\n    const [S] = maybeColumnOf(encode, 'series', 'color');\n    const domainSeries = domainOf(S, scaleSeries);\n    const newMark = deepMix({}, mark, {\n      scale: {\n        series: {\n          domain: domainSeries,\n          paddingInner: padding,\n        },\n      },\n    });\n\n    // Create groups and apply specified order for each group.\n    const groups = createGroups(groupBy, I, mark);\n    const createComparator = normalizeComparator(orderBy);\n\n    if (!createComparator) {\n      return [I, deepMix(newMark, { encode: { series: column(S) } })];\n    }\n\n    // Sort and Update series for each mark related to series domain.\n    const comparator = createComparator(data, Y, S);\n    if (comparator) applyOrder(groups, comparator);\n    const newS = new Array(I.length);\n    for (const G of groups) {\n      if (reverse) G.reverse();\n      for (let i = 0; i < G.length; i++) {\n        newS[G[i]] = domainSeries[i];\n      }\n    }\n\n    return [\n      I,\n      deepMix(newMark, {\n        encode: {\n          series: column(orderBy ? newS : S),\n        },\n      }),\n    ];\n  };\n};\n\nDodgeX.props = {};\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,aAAa,EAAE,MAAM,gBAAgB,CAAC;AACjE,OAAO,EACL,YAAY,EACZ,mBAAmB,EACnB,UAAU,EACV,QAAQ,GACT,MAAM,eAAe,CAAC;AATvB,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;;;;;;;;;AAkB9B,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,MAAM,EAAE,OAAO,GAAG,GAAG,EAAE,OAAO,GAAG,KAAK,EAAE,OAAO,EAAE,OAAO,EAAA,GAAc,OAAO,EAAhB,IAAI,GAAA,OAAK,OAAO,EAAvE;QAAA;QAAA;QAAA;QAAA;KAA6D,CAAU,CAAC;IAC9E,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QACrC,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,KAAK,CAAC;QACtC,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,CAAC,CAAC,CAAC,IAAG,uLAAA,AAAa,EAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QACrD,MAAM,YAAY,0KAAG,WAAQ,AAAR,EAAS,CAAC,EAAE,WAAW,CAAC,CAAC;QAC9C,MAAM,OAAO,IAAG,kNAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;YAChC,KAAK,EAAE;gBACL,MAAM,EAAE;oBACN,MAAM,EAAE,YAAY;oBACpB,YAAY,EAAE,OAAO;iBACtB;aACF;SACF,CAAC,CAAC;QAEH,0DAA0D;QAC1D,MAAM,MAAM,OAAG,kLAAY,AAAZ,EAAa,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QAC9C,MAAM,gBAAgB,0KAAG,sBAAA,AAAmB,EAAC,OAAO,CAAC,CAAC;QAEtD,IAAI,CAAC,gBAAgB,EAAE;YACrB,OAAO;gBAAC,CAAC;yNAAE,UAAA,AAAO,EAAC,OAAO,EAAE;oBAAE,MAAM,EAAE;wBAAE,MAAM,0KAAE,SAAA,AAAM,EAAC,CAAC,CAAC;oBAAA,CAAE;gBAAA,CAAE,CAAC;aAAC,CAAC;SACjE;QAED,iEAAiE;QACjE,MAAM,UAAU,GAAG,gBAAgB,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChD,IAAI,UAAU,yKAAE,aAAA,AAAU,EAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAC/C,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACjC,KAAK,MAAM,CAAC,IAAI,MAAM,CAAE;YACtB,IAAI,OAAO,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC;YACzB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;gBACjC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;aAC9B;SACF;QAED,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,OAAO,EAAE;gBACf,MAAM,EAAE;oBACN,MAAM,0KAAE,SAAA,AAAM,EAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;iBACnC;aACF,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 818, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"file":"jitter.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/jitter.ts"],"sourcesContent":["import { Band } from '@antv/scale';\nimport { deepMix } from '@antv/util';\nimport { Primitive, TransformComponent as TC } from '../runtime';\nimport { JitterTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { domainOf } from './utils/order';\n\nexport type JitterOptions = Omit<JitterTransform, 'type'>;\n\nexport function rangeOf(\n  value: Primitive[],\n  scaleOptions: Record<string, any>,\n  padding: number,\n): [number, number] {\n  if (value === null) return [-0.5, 0.5];\n  const domain = domainOf(value, scaleOptions);\n  const scale = new Band({ domain, range: [0, 1], padding });\n  const step = scale.getBandWidth();\n  return [-step / 2, step / 2];\n}\n\nexport function interpolate(t: number, a: number, b: number): number {\n  return a * (1 - t) + b * t;\n}\n\n/**\n * The jitter transform produce dx and dy channels for marks (especially for point)\n * with ordinal x and y dimension, say to make them jitter in their own space.\n */\nexport const Jitter: TC<JitterOptions> = (options = {}) => {\n  const {\n    padding = 0,\n    paddingX = padding,\n    paddingY = padding,\n    random = Math.random,\n  } = options;\n  return (I, mark) => {\n    const { encode, scale } = mark;\n    const { x: scaleX, y: scaleY } = scale;\n    const [X] = columnOf(encode, 'x');\n    const [Y] = columnOf(encode, 'y');\n    const rangeX = rangeOf(X, scaleX, paddingX);\n    const rangeY = rangeOf(Y, scaleY, paddingY);\n    const DY = I.map(() => interpolate(random(), ...rangeY));\n    const DX = I.map(() => interpolate(random(), ...rangeX));\n    return [\n      I,\n      deepMix(\n        {\n          scale: {\n            x: { padding: 0.5 },\n            y: { padding: 0.5 },\n          },\n        },\n        mark,\n        {\n          encode: { dy: column(DY), dx: column(DX) },\n        },\n      ),\n    ];\n  };\n};\n\nJitter.props = {};\n"],"names":[],"mappings":";;;;;AAIA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAHlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAIrC,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AALzC,OAAO,EAAE,IAAI,EAAE,MAAM,aAAa,CAAC;;;;;AAS7B,SAAU,OAAO,CACrB,KAAkB,EAClB,YAAiC,EACjC,OAAe;IAEf,IAAI,KAAK,KAAK,IAAI,EAAE,OAAO;QAAC,CAAC,GAAG;QAAE,GAAG;KAAC,CAAC;IACvC,MAAM,MAAM,yKAAG,YAAQ,AAAR,EAAS,KAAK,EAAE,YAAY,CAAC,CAAC;IAC7C,MAAM,KAAK,GAAG,6JAAI,OAAI,CAAC;QAAE,MAAM;QAAE,KAAK,EAAE;YAAC,CAAC;YAAE,CAAC;SAAC;QAAE,OAAO;IAAA,CAAE,CAAC,CAAC;IAC3D,MAAM,IAAI,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;IAClC,OAAO;QAAC,CAAC,IAAI,GAAG,CAAC;QAAE,IAAI,GAAG,CAAC;KAAC,CAAC;AAC/B,CAAC;AAEK,SAAU,WAAW,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS;IACzD,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC7B,CAAC;AAMM,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,MAAM,EACJ,OAAO,GAAG,CAAC,EACX,QAAQ,GAAG,OAAO,EAClB,QAAQ,GAAG,OAAO,EAClB,MAAM,GAAG,IAAI,CAAC,MAAM,EACrB,GAAG,OAAO,CAAC;IACZ,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QAC/B,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;QACvC,MAAM,CAAC,CAAC,CAAC,IAAG,kLAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;QAC5C,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;QAC5C,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAG,CAAD,UAAY,CAAC,MAAM,EAAE,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC;QACzD,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAG,CAAD,UAAY,CAAC,MAAM,EAAE,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC;QACzD,OAAO;YACL,CAAC;aACD,kNAAA,AAAO,EACL;gBACE,KAAK,EAAE;oBACL,CAAC,EAAE;wBAAE,OAAO,EAAE,GAAG;oBAAA,CAAE;oBACnB,CAAC,EAAE;wBAAE,OAAO,EAAE,GAAG;oBAAA,CAAE;iBACpB;aACF,EACD,IAAI,EACJ;gBACE,MAAM,EAAE;oBAAE,EAAE,0KAAE,SAAA,AAAM,EAAC,EAAE,CAAC;oBAAE,EAAE,0KAAE,SAAA,AAAM,EAAC,EAAE,CAAC;gBAAA,CAAE;aAC3C,CACF;SACF,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 892, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"file":"jitterX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/jitterX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { JitterXTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { rangeOf, interpolate } from './jitter';\n\nexport type JitterXOptions = Omit<JitterXTransform, 'type'>;\n\n/**\n * The JitterX transform produce dy channels for marks (especially for point)\n * with ordinal x and y dimension, say to make them jitter in their own space.\n */\nexport const JitterX: TC<JitterXOptions> = (options = {}) => {\n  const { padding = 0, random = Math.random } = options;\n  return (I, mark) => {\n    const { encode, scale } = mark;\n    const { x: scaleX } = scale;\n    const [X] = columnOf(encode, 'x');\n    const rangeX = rangeOf(X, scaleX, padding);\n    const DX = I.map(() => interpolate(random(), ...rangeX));\n    return [\n      I,\n      deepMix({ scale: { x: { padding: 0.5 } } }, mark, {\n        encode: { dx: column(DX) },\n      }),\n    ];\n  };\n};\n\nJitterX.props = {};\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAClD,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,CAAC;AAJhD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;AAY9B,MAAM,OAAO,GAAuB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAC1D,MAAM,EAAE,OAAO,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,OAAO,CAAC;IACtD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QAC/B,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;QAC5B,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,MAAM,kKAAG,UAAO,AAAP,EAAQ,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;QAC3C,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,8JAAC,cAAA,AAAW,EAAC,MAAM,EAAE,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC;QACzD,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC;gBAAE,KAAK,EAAE;oBAAE,CAAC,EAAE;wBAAE,OAAO,EAAE,GAAG;oBAAA,CAAE;gBAAA,CAAE;YAAA,CAAE,EAAE,IAAI,EAAE;gBAChD,MAAM,EAAE;oBAAE,EAAE,0KAAE,SAAA,AAAM,EAAC,EAAE,CAAC;gBAAA,CAAE;aAC3B,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,OAAO,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 938, "column": 0}, "map": {"version":3,"file":"jitterY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/jitterY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { JitterYTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { rangeOf, interpolate } from './jitter';\n\nexport type JitterYOptions = Omit<JitterYTransform, 'type'>;\n\n/**\n * The JitterY transform produce dy channels for marks (especially for point)\n * with ordinal x and y dimension, say to make them jitter in their own space.\n */\nexport const JitterY: TC<JitterYOptions> = (options = {}) => {\n  const { padding = 0, random = Math.random } = options;\n  return (I, mark) => {\n    const { encode, scale } = mark;\n    const { y: scaleY } = scale;\n    const [Y] = columnOf(encode, 'y');\n    const rangeY = rangeOf(Y, scaleY, padding);\n    const DY = I.map(() => interpolate(random(), ...rangeY));\n    return [\n      I,\n      deepMix({ scale: { y: { padding: 0.5 } } }, mark, {\n        encode: { dy: column(DY) },\n      }),\n    ];\n  };\n};\n\nJitterY.props = {};\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAClD,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,CAAC;AAJhD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;AAY9B,MAAM,OAAO,GAAuB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAC1D,MAAM,EAAE,OAAO,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,OAAO,CAAC;IACtD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QAC/B,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;QAC5B,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,MAAM,kKAAG,UAAO,AAAP,EAAQ,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;QAC3C,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,8JAAC,cAAA,AAAW,EAAC,MAAM,EAAE,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC;QACzD,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC;gBAAE,KAAK,EAAE;oBAAE,CAAC,EAAE;wBAAE,OAAO,EAAE,GAAG;oBAAA,CAAE;gBAAA,CAAE;YAAA,CAAE,EAAE,IAAI,EAAE;gBAChD,MAAM,EAAE;oBAAE,EAAE,0KAAE,SAAA,AAAM,EAAC,EAAE,CAAC;gBAAA,CAAE;aAC3B,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,OAAO,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 972, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 978, "column": 0}, "map": {"version":3,"file":"symmetryY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/symmetryY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC } from '../runtime';\nimport { SymmetryYTransform } from '../spec';\nimport { columnOf, column } from './utils/helper';\nimport { createGroups } from './utils/order';\n\nexport type SymmetryYOptions = Omit<SymmetryYTransform, 'type'>;\n\n/**\n * The SymmetryY transform apply offset for y channels, say to transform\n * them to be symmetry.\n */\nexport const SymmetryY: TC<SymmetryYOptions> = (options = {}) => {\n  const { groupBy = 'x' } = options;\n  return (I, mark) => {\n    const { encode } = mark;\n    const { x, ...rest } = encode;\n\n    // Extract and create new channels starts with y, such as y, y1.\n    const Yn = Object.entries(rest)\n      .filter(([k]) => k.startsWith('y'))\n      .map(([k]) => [k, columnOf(encode, k)[0]] as const);\n    const newYn = Yn.map(([k]) => [k, new Array(I.length)] as const);\n\n    // Group marks into series by specified keys.\n    const groups = createGroups(groupBy, I, mark);\n    const MY = new Array(groups.length);\n    for (let i = 0; i < groups.length; i++) {\n      const I = groups[i];\n      const Y = I.flatMap((i) => Yn.map(([, V]) => +V[i]));\n      const [minY, maxY] = extent(Y);\n      MY[i] = (minY + maxY) / 2;\n    }\n\n    const maxMiddleY = Math.max(...MY);\n    for (let m = 0; m < groups.length; m++) {\n      const offset = maxMiddleY - MY[m];\n      const I = groups[m];\n      for (const i of I) {\n        for (let j = 0; j < Yn.length; j++) {\n          const [, V] = Yn[j];\n          const [, newV] = newYn[j];\n          newV[i] = +V[i] + offset;\n        }\n      }\n    }\n\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: Object.fromEntries(\n          newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]),\n        ),\n      }),\n    ];\n  };\n};\n\nSymmetryY.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1047, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1053, "column": 0}, "map": {"version":3,"file":"diffY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/diffY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { DiffYTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { createGroups } from './utils/order';\n\nexport type DiffYOptions = Omit<DiffYTransform, 'type'>;\n\n/**\n * The DiffY transform apply offset for y0 channels.\n * Keep y unchanged, set y1 = max(otherY), if y1 > y, remove the data.\n */\nexport const DiffY: TC<DiffYOptions> = (options = {}) => {\n  const { groupBy = 'x' } = options;\n  return (I, mark) => {\n    const { encode } = mark;\n    const [Y] = columnOf(encode, 'y');\n    const [_, fy1] = columnOf(encode, 'y1');\n\n    // Create groups and apply specified order for each group.\n    const groups = createGroups(groupBy, I, mark);\n\n    // Only adjust Y1 channel.\n    const newY1 = new Array(I.length);\n    for (const G of groups) {\n      const YG = G.map((i) => +Y[i]);\n      // Process each series.\n      for (let idx = 0; idx < G.length; idx++) {\n        const i = G[idx];\n        // Get the max Y of current group with current Y exclude.\n        const max = Math.max(...YG.filter((_, _i) => _i !== idx));\n        // Diff Y value.\n        newY1[i] = +Y[i] > max ? max : Y[i];\n      }\n    }\n\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: {\n          y1: column(newY1, fy1),\n        },\n      }),\n    ];\n  };\n};\n\nDiffY.props = {};\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAClD,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAJ7C,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;AAY9B,MAAM,KAAK,GAAqB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACtD,MAAM,EAAE,OAAO,GAAG,GAAG,EAAE,GAAG,OAAO,CAAC;IAClC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAExC,0DAA0D;QAC1D,MAAM,MAAM,0KAAG,eAAA,AAAY,EAAC,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QAE9C,0BAA0B;QAC1B,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QAClC,KAAK,MAAM,CAAC,IAAI,MAAM,CAAE;YACtB,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/B,uBAAuB;YACvB,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,CAAE;gBACvC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;gBACjB,yDAAyD;gBACzD,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAG,CAAD,CAAG,KAAK,GAAG,CAAC,CAAC,CAAC;gBAC1D,gBAAgB;gBAChB,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACrC;SACF;QAED,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,MAAM,EAAE;oBACN,EAAE,0KAAE,SAAA,AAAM,EAAC,KAAK,EAAE,GAAG,CAAC;iBACvB;aACF,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,KAAK,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1100, "column": 0}, "map": {"version":3,"file":"stackEnter.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/stackEnter.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { group, max } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC } from '../runtime';\nimport { StackEnterTransform } from '../spec';\nimport {\n  columnOf,\n  constant,\n  maybeColumnOf,\n  visualColumn,\n} from './utils/helper';\n\nexport type StackEnterOptions = Omit<StackEnterTransform, 'type'>;\n\n/**\n * Group marks by channels into groups and stacking their enterDelay\n * to make marks show up groups by groups.\n * It will update enterDelay channel for each mark by its enterDuration and group.\n * @todo Support orderBy.\n * @todo Sort among groups(e.g. reverse).\n * @todo Stack enter in groups rather than between groups?\n * @todo Auto inter this statistic for scaleInY animation in stacked interval?\n * @todo All the groups shared the enterDuration?\n */\nexport const StackEnter: TC<StackEnterOptions> = (options) => {\n  const {\n    groupBy = ['x'],\n    reducer = (I, V) => V[I[0]],\n    orderBy = null,\n    reverse = false,\n    duration,\n  } = options;\n  return (I, mark) => {\n    const { encode } = mark;\n\n    // Extract group information by each specified channel,\n    // and skip if all values of channels are empty.\n    const by = Array.isArray(groupBy) ? groupBy : [groupBy];\n    const groupEntries = by.map((k) => [k, columnOf(encode, k)[0]]);\n    if (groupEntries.length === 0) return [I, mark];\n\n    // Nest group index and flatten them in right order among timeline.\n    // [[1, 2, 3, 4, 5, 6]] ->\n    // [[1, 2, 3], [4, 5, 6]] ->\n    // [[1], [2], [3], [4], [5], [6]]\n    let groups = [I];\n    for (const [, V] of groupEntries) {\n      const newGroups = [];\n      for (const I of groups) {\n        const G = Array.from(group(I, (i) => V[i]).values());\n        // @todo sort by x.\n        newGroups.push(...G);\n      }\n      groups = newGroups;\n    }\n\n    // const {color} = encode;\n    if (orderBy) {\n      const [V] = columnOf(encode, orderBy);\n      if (V) groups.sort((I, J) => reducer(I, V) - reducer(J, V));\n      if (reverse) groups.reverse();\n    }\n\n    // Stack delay for each group.\n    const t = (duration || 3000) / groups.length;\n    const [ED] = duration\n      ? [constant(I, t)] // If specified duration, generate enter duration for each.\n      : maybeColumnOf(encode, 'enterDuration', constant(I, t));\n    const [EDL] = maybeColumnOf(encode, 'enterDelay', constant(I, 0));\n    const newEnterDelay = new Array(I.length);\n    for (let i = 0, pd = 0; i < groups.length; i++) {\n      const I = groups[i];\n      const maxDuration = max(I, (i) => +ED[i]);\n      for (const j of I) newEnterDelay[j] = +EDL[j] + pd;\n      pd += maxDuration;\n    }\n\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: {\n          enterDuration: visualColumn(ED),\n          enterDelay: visualColumn(newEnterDelay),\n        },\n      }),\n    ];\n  };\n};\n\nStackEnter.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1178, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"file":"normalizeY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/normalizeY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { mean, deviation, median, sum, max, min } from '@antv/vendor/d3-array';\nimport { isUnset } from '../utils/helper';\nimport { TransformComponent as TC } from '../runtime';\nimport { NormalizeYTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { createGroups } from './utils/order';\n\nexport type NormalizeYOptions = Omit<NormalizeYTransform, 'type'>;\n\nfunction normalizeBasis(basis: NormalizeYOptions['basis']) {\n  if (typeof basis === 'function') return basis;\n  const registry = {\n    min: (I, Y) => min(I, (i) => Y[+i]),\n    max: (I, Y) => max(I, (i) => Y[+i]),\n    first: (I, Y) => Y[I[0]],\n    last: (I, Y) => Y[I[I.length - 1]],\n    mean: (I, Y) => mean(I, (i) => Y[+i]),\n    median: (I, Y) => median(I, (i) => Y[+i]),\n    sum: (I, Y) => sum(I, (i) => Y[+i]),\n    deviation: (I, Y) => deviation(I, (i) => Y[+i]),\n  };\n  return registry[basis] || max;\n}\n\n/**\n * Group marks into series by specified channels, and then transform\n * each series's value, say to transform them relative to some basis\n * to apply a moving average.\n */\nexport const NormalizeY: TC<NormalizeYOptions> = (options = {}) => {\n  const { groupBy = 'x', basis = 'max' } = options;\n  return (I, mark) => {\n    const { encode, tooltip } = mark;\n    const { x, ...rest } = encode;\n\n    // Extract and create new channels starts with y, such as y, y1.\n    const Yn = Object.entries(rest)\n      .filter(([k]) => k.startsWith('y'))\n      .map(([k]) => [k, columnOf(encode, k)[0]] as const);\n    const [, Y] = Yn.find(([k]) => k === 'y');\n    const newYn = Yn.map(([k]) => [k, new Array(I.length)] as const);\n\n    // Group marks into series by specified keys.\n    const groups = createGroups(groupBy, I, mark);\n\n    // Transform y channels for each group based on basis.\n    const basisFunction = normalizeBasis(basis);\n    for (const I of groups) {\n      // Compute basis only base on y.\n      const basisValue = basisFunction(I, Y);\n      for (const i of I) {\n        for (let j = 0; j < Yn.length; j++) {\n          const [, V] = Yn[j];\n          const [, newV] = newYn[j];\n          newV[i] = +V[i] / basisValue;\n        }\n      }\n    }\n\n    const specifiedTooltip =\n      isUnset(tooltip) || (tooltip?.items && tooltip?.items.length !== 0);\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: Object.fromEntries(\n          newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]),\n        ),\n        // Infer tooltip item.\n        ...(!specifiedTooltip &&\n          encode.y0 && {\n            tooltip: { items: [{ channel: 'y0' }] },\n          }),\n      }),\n    ];\n  };\n};\n\nNormalizeY.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1278, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1284, "column": 0}, "map": {"version":3,"file":"select.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/select.ts"],"sourcesContent":["import { maxIndex, minIndex } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC } from '../runtime';\nimport { SelectTransform, Selector } from '../spec';\nimport { columnOf } from './utils/helper';\nimport { createGroups } from './utils/order';\n\nexport type SelectOptions = Omit<SelectTransform, 'type'>;\n\ntype SelectorFunction = (I: number[], V: number[]) => number[];\n\nfunction first(I: number[], V: number[]): number[] {\n  return [I[0]];\n}\n\nfunction last(I: number[], V: number[]): number[] {\n  const i = I.length - 1;\n  return [I[i]];\n}\n\nfunction max(I: number[], V: number[]): number[] {\n  const i = maxIndex(I, (i) => V[i]);\n  return [I[i]];\n}\n\nfunction min(I: number[], V: number[]): number[] {\n  const i = minIndex(I, (i) => V[i]);\n  return [I[i]];\n}\n\nfunction normalizeSelector(selector: Selector): SelectorFunction {\n  if (typeof selector === 'function') return selector;\n  const registry = { first, last, max, min };\n  return registry[selector] || first;\n}\n\n/**\n * The select transform groups marks with specified channels, and\n * filter index by specified selector for each series, say to\n * pull a single or multiple values out of each series.\n */\nexport const Select: TC<SelectOptions> = (options = {}) => {\n  const { groupBy = 'series', channel, selector } = options;\n  return (I, mark) => {\n    const { encode } = mark;\n    const groups = createGroups(groupBy, I, mark);\n    const [V] = columnOf(encode, channel);\n    const selectFunction = normalizeSelector(selector);\n    return [groups.flatMap((GI) => selectFunction(GI, V as number[])), mark];\n  };\n};\n\nSelect.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAI3D,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAD7C,OAAO,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;;;;;;AAO1C,SAAS,KAAK,CAAC,CAAW,EAAE,CAAW;IACrC,OAAO;QAAC,CAAC,CAAC,CAAC,CAAC;KAAC,CAAC;AAChB,CAAC;AAED,SAAS,IAAI,CAAC,CAAW,EAAE,CAAW;IACpC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;IACvB,OAAO;QAAC,CAAC,CAAC,CAAC,CAAC;KAAC,CAAC;AAChB,CAAC;AAED,SAAS,GAAG,CAAC,CAAW,EAAE,CAAW;IACnC,MAAM,CAAC,6LAAG,WAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,CAAC,CAAC,CAAC,CAAC;IACnC,OAAO;QAAC,CAAC,CAAC,CAAC,CAAC;KAAC,CAAC;AAChB,CAAC;AAED,SAAS,GAAG,CAAC,CAAW,EAAE,CAAW;IACnC,MAAM,CAAC,6LAAG,WAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACnC,OAAO;QAAC,CAAC,CAAC,CAAC,CAAC;KAAC,CAAC;AAChB,CAAC;AAED,SAAS,iBAAiB,CAAC,QAAkB;IAC3C,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE,OAAO,QAAQ,CAAC;IACpD,MAAM,QAAQ,GAAG;QAAE,KAAK;QAAE,IAAI;QAAE,GAAG;QAAE,GAAG;IAAA,CAAE,CAAC;IAC3C,OAAO,QAAQ,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC;AACrC,CAAC;AAOM,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,MAAM,EAAE,OAAO,GAAG,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;IAC1D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,MAAM,0KAAG,eAAA,AAAY,EAAC,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QAC9C,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QACtC,MAAM,cAAc,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACnD,OAAO;YAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,aAAe,CAAC,EAAE,EAAE,CAAa,CAAC,CAAC;YAAE,IAAI;SAAC,CAAC;IAC3E,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1342, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1348, "column": 0}, "map": {"version":3,"file":"selectX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/selectX.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { SelectXTransform } from '../spec';\nimport { Select } from './select';\n\nexport type SelectXOptions = Omit<SelectXTransform, 'type'>;\n\n/**\n * The selectX transform filter index by y channel.\n */\nexport const SelectX: TC<SelectXOptions> = (options = {}) => {\n  const { selector, ...rest } = options;\n  return Select({ channel: 'x', selector, ...rest });\n};\n\nSelectX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;;;;;;;;;;AAO3B,MAAM,OAAO,GAAuB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAC1D,MAAM,EAAE,QAAQ,EAAA,GAAc,OAAO,EAAhB,IAAI,GAAA,OAAK,OAAO,EAA/B;QAAA;KAAqB,CAAU,CAAC;IACtC,sKAAO,SAAA,AAAM,EAAA,OAAA,MAAA,CAAA;QAAG,OAAO,EAAE,GAAG;QAAE,QAAQ;IAAA,GAAK,IAAI,EAAG,CAAC;AACrD,CAAC,CAAC;AAEF,OAAO,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1371, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1377, "column": 0}, "map": {"version":3,"file":"selectY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/selectY.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { SelectYTransform } from '../spec';\nimport { Select } from './select';\n\nexport type SelectYOptions = Omit<SelectYTransform, 'type'>;\n\n/**\n * The selectY transform filter index by y channel.\n */\nexport const SelectY: TC<SelectYOptions> = (options = {}) => {\n  const { selector, ...rest } = options;\n  return Select({ channel: 'y', selector, ...rest });\n};\n\nSelectY.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;;;;;;;;;;AAO3B,MAAM,OAAO,GAAuB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAC1D,MAAM,EAAE,QAAQ,EAAA,GAAc,OAAO,EAAhB,IAAI,GAAA,OAAK,OAAO,EAA/B;QAAA;KAAqB,CAAU,CAAC;IACtC,sKAAO,SAAA,AAAM,EAAA,OAAA,MAAA,CAAA;QAAG,OAAO,EAAE,GAAG;QAAE,QAAQ;IAAA,GAAK,IAAI,EAAG,CAAC;AACrD,CAAC,CAAC;AAEF,OAAO,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1400, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1406, "column": 0}, "map": {"version":3,"file":"group.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/group.ts"],"sourcesContent":["import { TransformComponent as TC, G2Mark } from '../runtime';\nimport { GroupTransform } from '../spec';\nimport { createGroups } from './utils/order';\nimport { GroupN } from './groupN';\n\nexport type GroupOptions = Omit<\n  GroupTransform & {\n    groupBy?: (\n      I: number[],\n      mark: G2Mark,\n      options?: Record<string, any>,\n    ) => number[][];\n  },\n  'type'\n>;\n\n/**\n * The Group transform group data by x and y channels, and aggregate.\n */\nexport const Group: TC<GroupOptions> = (options = {}) => {\n  const { channels = ['x', 'y'], ...rest } = options;\n  const groupBy = (I, mark) => createGroups(channels, I, mark);\n  return GroupN({ ...rest, groupBy });\n};\n\nGroup.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;;;;;;;;;;;AAgB3B,MAAM,KAAK,GAAqB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACtD,MAAM,EAAE,QAAQ,GAAG;QAAC,GAAG;QAAE,GAAG;KAAC,EAAA,GAAc,OAAO,EAAhB,IAAI,GAAA,OAAK,OAAO,EAA5C;QAAA;KAAkC,CAAU,CAAC;IACnD,MAAM,OAAO,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAG,CAAD,qLAAC,AAAY,EAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;IAC7D,sKAAO,SAAA,AAAM,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,IAAI,GAAA;QAAE,OAAO;IAAA,GAAG,CAAC;AACtC,CAAC,CAAC;AAEF,KAAK,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1434, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"file":"groupX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/groupX.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { GroupXTransform } from '../spec';\nimport { Group } from './group';\n\nexport type GroupXOptions = Omit<GroupXTransform, 'type'>;\n\n/**\n * The GroupX transform group data by x channel, and aggregate.\n */\nexport const GroupX: TC<GroupXOptions> = (options = {}) => {\n  return Group({ ...options, channels: ['x', 'color', 'series'] });\n};\n\nGroupX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;;AAOzB,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,qKAAO,QAAA,AAAK,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAO,GAAA;QAAE,QAAQ,EAAE;YAAC,GAAG;YAAE,OAAO;YAAE,QAAQ;SAAC;IAAA,GAAG,CAAC;AACnE,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1461, "column": 0}, "map": {"version":3,"file":"groupY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/groupY.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { GroupYTransform } from '../spec';\nimport { Group } from './group';\n\nexport type GroupYOptions = Omit<GroupYTransform, 'type'>;\n\n/**\n * The GroupY transform group data by x channel, and aggregate.\n */\nexport const GroupY: TC<GroupYOptions> = (options = {}) => {\n  return Group({ ...options, channels: ['y', 'color', 'series'] });\n};\n\nGroupY.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;;AAOzB,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,qKAAO,QAAA,AAAK,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAO,GAAA;QAAE,QAAQ,EAAE;YAAC,GAAG;YAAE,OAAO;YAAE,QAAQ;SAAC;IAAA,GAAG,CAAC;AACnE,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1482, "column": 0}, "map": {"version":3,"file":"groupColor.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/groupColor.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { GroupColorTransform } from '../spec';\nimport { Group } from './group';\n\nexport type GroupColorOptions = Omit<GroupColorTransform, 'type'>;\n\n/**\n * The GroupColor transform group data by x channel, and aggregate.\n */\nexport const GroupColor: TC<GroupColorOptions> = (options = {}) => {\n  return Group({ ...options, channels: ['color'] });\n};\n\nGroupColor.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;;AAOzB,MAAM,UAAU,GAA0B,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAChE,qKAAO,QAAA,AAAK,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAO,GAAA;QAAE,QAAQ,EAAE;YAAC,OAAO;SAAC;IAAA,GAAG,CAAC;AACpD,CAAC,CAAC;AAEF,UAAU,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1501, "column": 0}, "map": {"version":3,"file":"sort.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/sort.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport {\n  Primitive,\n  groupSort,\n  max,\n  min,\n  sum,\n  mean,\n  median,\n  sort,\n} from '@antv/vendor/d3-array';\nimport { G2Mark, TransformComponent as TC } from '../runtime';\nimport { columnOf } from './utils/helper';\n\nfunction createReducer(channel, options, encode): (I: number[]) => any {\n  const { by = channel, reducer = 'max' } = options;\n  const [V] = columnOf(encode, by);\n  if (typeof reducer === 'function') return (GI: number[]) => reducer(GI, V);\n  if (reducer === 'max') return (GI: number[]) => max(GI, (i) => +V[i]);\n  if (reducer === 'min') return (GI: number[]) => min(GI, (i) => +V[i]);\n  if (reducer === 'sum') return (GI: number[]) => sum(GI, (i) => +V[i]);\n  if (reducer === 'median') return (GI: number[]) => median(GI, (i) => +V[i]);\n  if (reducer === 'mean') return (GI: number[]) => mean(GI, (i) => +V[i]);\n  if (reducer === 'first') return (GI: number[]) => V[GI[0]];\n  if (reducer === 'last') return (GI: number[]) => V[GI[GI.length - 1]];\n  throw new Error(`Unknown reducer: ${reducer}`);\n}\n\nexport type SortOptions = {\n  by?: string;\n  reverse?: boolean;\n  channel?: string;\n  slice?: number | [number, number];\n  ordinal?: boolean;\n  reducer?:\n    | 'max'\n    | 'min'\n    | 'sum'\n    | 'first'\n    | 'last'\n    | 'mean'\n    | 'median'\n    | ((I: number[], V: Primitive[]) => Primitive);\n};\n\n// If domain is specified, only sort data in the domain.\nfunction filterIndex(I, values, specifiedDomain): number[] {\n  if (!Array.isArray(specifiedDomain)) return I;\n  const domain = new Set(specifiedDomain);\n  return I.filter((i) => domain.has(values[i]));\n}\n\n/**\n * Sort marks groups by groups.\n */\nexport const Sort: TC<SortOptions> = (options = {}) => {\n  return (I, mark) => {\n    const { reverse, slice, channel, by, ordinal = true, reducer } = options;\n    const { encode, scale = {} } = mark;\n    const domain = scale[channel].domain;\n    const [V] = columnOf(encode, by ?? channel);\n    const [T] = columnOf(encode, channel);\n    const normalizeReducer = createReducer(channel, { by, reducer }, encode);\n    const SI = filterIndex(I, T, domain);\n    const sortedDomain = groupSort(SI, normalizeReducer, (i: number) => T[i]);\n\n    // when ordinal is true, do not change the index of the data.\n    const sortedI = !ordinal ? sort(I, (i: number) => V[i]) : I;\n    if (reverse) {\n      !ordinal && sortedI.reverse();\n      sortedDomain.reverse();\n    }\n    const s = typeof slice === 'number' ? [0, slice] : slice;\n    const slicedDomain = slice ? sortedDomain.slice(...s) : sortedDomain;\n    return [\n      sortedI,\n      deepMix(mark, { scale: { [channel]: { domain: slicedDomain } } }),\n    ];\n  };\n};\n\nSort.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1573, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1579, "column": 0}, "map": {"version":3,"file":"sortX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/sortX.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { SortXTransform } from '../spec';\nimport { Sort } from './sort';\n\nexport type SortXOptions = Omit<SortXTransform, 'type'>;\n\n/**\n * Sort domain of x scale of mark groups by groups.\n */\nexport const SortX: TC<SortXOptions> = (options = {}) => {\n  return Sort({ ...options, channel: 'x' });\n};\n\nSortX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;;AAOvB,MAAM,KAAK,GAAqB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACtD,oKAAO,OAAA,AAAI,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAO,GAAA;QAAE,OAAO,EAAE,GAAG;IAAA,GAAG,CAAC;AAC5C,CAAC,CAAC;AAEF,KAAK,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1590, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"file":"sortY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/sortY.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { SortYTransform } from '../spec';\nimport { Sort } from './sort';\n\nexport type SortYOptions = Omit<SortYTransform, 'type'>;\n\n/**\n * Sort domain of x scale of mark groups by groups.\n */\nexport const SortY: TC<SortYOptions> = (options = {}) => {\n  return Sort({ ...options, channel: 'y' });\n};\n\nSortY.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;;AAOvB,MAAM,KAAK,GAAqB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACtD,oKAAO,OAAA,AAAI,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAO,GAAA;QAAE,OAAO,EAAE,GAAG;IAAA,GAAG,CAAC;AAC5C,CAAC,CAAC;AAEF,KAAK,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"file":"sortColor.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/sortColor.ts"],"sourcesContent":["import { TransformComponent as TC } from '../runtime';\nimport { SortColorTransform } from '../spec';\nimport { Sort } from './sort';\n\nexport type SortColorOptions = Omit<SortColorTransform, 'type'>;\n\n/**\n * Sort domain of x scale of mark groups by groups.\n */\nexport const SortColor: TC<SortColorOptions> = (options = {}) => {\n  return Sort({ ...options, channel: 'color' });\n};\n\nSortColor.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;;AAOvB,MAAM,SAAS,GAAyB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IAC9D,oKAAO,OAAA,AAAI,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAO,GAAA;QAAE,OAAO,EAAE,OAAO;IAAA,GAAG,CAAC;AAChD,CAAC,CAAC;AAEF,SAAS,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1624, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1630, "column": 0}, "map": {"version":3,"file":"flexX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/flexX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { rollups, sum, Primitive } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC } from '../runtime';\nimport { FlexXTransform } from '../spec';\nimport { columnOf } from './utils/helper';\n\nexport type FlexXOptions = Omit<FlexXTransform, 'type'>;\n\nfunction valueOf(data: any, field: FlexXOptions['field']) {\n  if (typeof field === 'string') return data.map((d) => d[field]);\n  return data.map(field);\n}\n\nfunction createReducer(\n  reducer: FlexXOptions['reducer'],\n  V: Primitive[],\n): (I: number[]) => any {\n  if (typeof reducer === 'function') return (GI: number[]) => reducer(GI, V);\n  if (reducer === 'sum') return (GI: number[]) => sum(GI, (i) => +V[i]);\n  throw new Error(`Unknown reducer: ${reducer}`);\n}\n\n/**\n * Produce flex options from data for x scale.\n */\nexport const FlexX: TC<FlexXOptions> = (options = {}) => {\n  const { field, channel = 'y', reducer = 'sum' } = options;\n  return (I, mark) => {\n    const { data, encode } = mark;\n    const [x] = columnOf(encode, 'x');\n    const V = field ? valueOf(data, field) : columnOf(encode, channel)[0];\n    const reducerFunction = createReducer(reducer, V);\n    const flex = rollups(I, reducerFunction, (i) => x[i]).map((d) => d[1]);\n    return [I, deepMix({}, mark, { scale: { x: { flex } } })];\n  };\n};\n\nFlexX.props = {};\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,OAAO,EAAE,GAAG,EAAa,MAAM,uBAAuB,CAAC;AAGhE,OAAO,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;;AAJ1C,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;;AAQrC,SAAS,OAAO,CAAC,IAAS,EAAE,KAA4B;IACtD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,KAAK,CAAC,CAAC,CAAC;IAChE,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACzB,CAAC;AAED,SAAS,aAAa,CACpB,OAAgC,EAChC,CAAc;IAEd,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE,OAAO,CAAC,EAAY,EAAE,CAAG,CAAD,MAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAC3E,IAAI,OAAO,KAAK,KAAK,EAAE,OAAO,CAAC,EAAY,EAAE,EAAE,+KAAC,MAAA,AAAG,EAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACtE,MAAM,IAAI,KAAK,CAAC,CAAA,iBAAA,EAAoB,OAAO,EAAE,CAAC,CAAC;AACjD,CAAC;AAKM,MAAM,KAAK,GAAqB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACtD,MAAM,EAAE,KAAK,EAAE,OAAO,GAAG,GAAG,EAAE,OAAO,GAAG,KAAK,EAAE,GAAG,OAAO,CAAC;IAC1D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QAC9B,MAAM,CAAC,CAAC,CAAC,IAAG,kLAAA,AAAQ,EAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,yKAAC,WAAQ,AAAR,EAAS,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QACtE,MAAM,eAAe,GAAG,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAClD,MAAM,IAAI,mJAAG,UAAA,AAAO,EAAC,CAAC,EAAE,eAAe,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACvE,OAAO;YAAC,CAAC;qNAAE,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,KAAK,EAAE;oBAAE,CAAC,EAAE;wBAAE,IAAI;oBAAA,CAAE;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IAC5D,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,KAAK,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1671, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1677, "column": 0}, "map": {"version":3,"file":"pack.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/pack.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { calcBBox } from '../utils/vector';\nimport { PackTransform } from '../spec';\n\nexport type PackOptions = Omit<PackTransform, 'type'>;\n\nfunction pack(options: PackOptions) {\n  const { padding = 0, direction = 'col' } = options;\n  return (P, count, layout) => {\n    const pcount = P.length;\n    if (pcount === 0) return [];\n\n    // col * row >= count\n    // row is close to col * aspect, so\n    // col * (col * aspect) >= count\n    const { innerWidth, innerHeight } = layout;\n    const aspect = innerHeight / innerWidth;\n    let col = Math.ceil(Math.sqrt(count / aspect));\n\n    // Increase col to avoid total height of packed shape\n    // being large than height of bbox.\n    let size = innerWidth / col;\n    let row = Math.ceil(count / col);\n    let h0 = row * size;\n    while (h0 > innerHeight) {\n      col = col + 1;\n      size = innerWidth / col;\n      row = Math.ceil(count / col);\n      h0 = row * size;\n    }\n\n    // Some offset to increase the space usage.\n    const space = innerHeight - row * size;\n    const intervalY = row <= 1 ? 0 : space / (row - 1);\n    const [offsetX, offsetY] =\n      row <= 1\n        ? [\n            (innerWidth - pcount * size) / (pcount - 1),\n            (innerHeight - size) / 2,\n          ]\n        : [0, 0];\n\n    return P.map((points, m) => {\n      const [x, y, width, height] = calcBBox(points);\n      const i = direction === 'col' ? m % col : Math.floor(m / row);\n      const j = direction === 'col' ? Math.floor(m / col) : m % row;\n\n      const newX = i * size;\n      const newY = (row - j - 1) * size + space;\n\n      const sx = (size - padding) / width;\n      const sy = (size - padding) / height;\n\n      // Translate the shape and mark to make sure the center of\n      // shape is overlap before and after scale transformation.\n      const tx = newX - x + offsetX * i + (1 / 2) * padding;\n      const ty = newY - y - intervalY * j - offsetY + (1 / 2) * padding;\n      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;\n    });\n  };\n}\n\n/**\n * Uniform pack to avid overlap.\n * @todo Improve or change algorithm to increase space usage.\n * @todo Take some special case into account.\n */\nexport const Pack: TC<PackOptions> = (options) => {\n  return (I, mark) => {\n    return [I, deepMix({}, mark, { modifier: pack(options), axis: false })];\n  };\n};\n\nPack.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1750, "column": 0}, "map": {"version":3,"file":"lttb.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/utils/lttb.ts"],"sourcesContent":["/**\n * Sample data with lttb(Largest-Triangle-Three-Buckets) algo (https://github.com/pingec/downsample-lttb).\n * Return the sampled index array.\n */\nexport function lttb(\n  I: number[],\n  X: number[],\n  Y: number[],\n  thresholds: number,\n): number[] {\n  const length = I.length;\n  if (thresholds >= length || thresholds === 0) {\n    return I;\n  }\n\n  const x = (i: number) => X[I[i]] * 1;\n  const y = (i: number) => Y[I[i]] * 1;\n  const sampled = [];\n\n  // Bucket size. Leave room for start and end data points.\n  const every = (length - 2) / (thresholds - 2);\n\n  let a = 0; // Initially a is the first point in the triangle.\n  let maxArea;\n  let area;\n  let nextA;\n\n  sampled.push(a); // Always add the first point.\n\n  for (let i = 0; i < thresholds - 2; i++) {\n    // Calculate point average for next bucket (containing c).\n    let avgX = 0;\n    let avgY = 0;\n    let start = Math.floor((i + 1) * every) + 1;\n    let end = Math.floor((i + 2) * every) + 1;\n    end = Math.min(end, length);\n    const size = end - start;\n\n    for (; start < end; start++) {\n      avgX += x(start);\n      avgY += y(start);\n    }\n    avgX /= size;\n    avgY /= size;\n\n    // Get the range for this bucket.\n    let frameStart = Math.floor((i + 0) * every) + 1;\n    const frameEnd = Math.floor((i + 1) * every) + 1;\n\n    // Point a.\n    const pointA = [x(a), y(a)];\n    maxArea = area = -1;\n    for (; frameStart < frameEnd; frameStart++) {\n      // Calculate triangle area over three buckets.\n      area =\n        Math.abs(\n          (pointA[0] - avgX) * (x(frameStart) - pointA[1]) -\n            (pointA[0] - y(frameStart)) * (avgY - pointA[0]),\n        ) * 0.5;\n      if (area > maxArea) {\n        maxArea = area;\n        nextA = frameStart; // Next a is this b.\n      }\n    }\n\n    sampled.push(nextA); // Pick this point from the bucket.\n    a = nextA; // This a is the next a (chosen b).\n  }\n\n  sampled.push(length - 1); // Always add last.\n\n  return sampled.map((a) => I[a]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1808, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1814, "column": 0}, "map": {"version":3,"file":"sample.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/sample.ts"],"sourcesContent":["// @ts-ignore medianIndex exist in d3-array@3.2.0, but @types/d3-array Expired.\nimport { maxIndex, minIndex, medianIndex } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC, Primitive } from '../runtime';\nimport { SampleTransform, SampleFunction } from '../spec';\nimport { createGroups } from './utils/order';\nimport { columnOf } from './utils/helper';\nimport { lttb } from './utils/lttb';\n\nexport type SampleOptions = Omit<SampleTransform, 'type'>;\n\nfunction normalizeSample(\n  strategy: SampleTransform['strategy'],\n): SampleFunction {\n  if (typeof strategy === 'function') return strategy;\n  if (strategy === 'lttb') return lttb;\n\n  const strategies = {\n    first: (f: number[]) => [f[0]],\n    last: (f: number[]) => [f[f.length - 1]],\n    min: (f: number[], X: number[], Y: number[]) => [\n      f[minIndex(f, (i) => Y[i])],\n    ],\n    max: (f: number[], X: number[], Y: number[]) => [\n      f[maxIndex(f, (i) => Y[i])],\n    ],\n    median: (f: number[], X: number[], Y: number[]) => [\n      f[medianIndex(f, (i) => Y[i])],\n    ],\n  };\n  const sampleFunction = strategies[strategy] || strategies.median;\n  return (I: number[], X: number[], Y: number[], thresholds: number) => {\n    // Sepreate group to frames, then sample each frame.\n    // Keep more data as possible.\n    const frameSize = Math.max(1, Math.floor(I.length / thresholds));\n    const frames = getFrames(I, frameSize);\n    return frames.flatMap((frame) => sampleFunction(frame, X, Y));\n  };\n}\n\n/**\n * Split the array into frame with each frameSize.\n */\nfunction getFrames(I: Primitive[], frameSize: number): number[][] {\n  const size = I.length;\n  const frames = [];\n  let i = 0;\n  while (i < size) {\n    frames.push(I.slice(i, (i += frameSize)));\n  }\n  return frames;\n}\n\n/**\n * The sample transform groups marks with specified groupBy fields, and\n * sample data for each group when data.length >= threshold(default = 2000).\n */\nexport const Sample: TC<SampleOptions> = (options = {}) => {\n  const {\n    strategy = 'median',\n    thresholds = 2000,\n    groupBy = ['series', 'color'],\n  } = options;\n  const sampleFunction = normalizeSample(strategy);\n\n  return (I, mark) => {\n    const { encode } = mark;\n    const groups = createGroups(groupBy, I, mark);\n    const [X] = columnOf(encode, 'x');\n    const [Y] = columnOf(encode, 'y');\n\n    return [\n      groups.flatMap((g) =>\n        sampleFunction(g, X as number[], Y as number[], thresholds),\n      ),\n      mark,\n    ];\n  };\n};\n\nSample.props = {};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1887, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1893, "column": 0}, "map": {"version":3,"file":"filter.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/filter.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { G2Mark, TransformComponent as TC } from '../runtime';\nimport { FilterTransform } from '../spec';\nimport { defined } from '../utils/helper';\nimport { columnOf } from './utils/helper';\n\nexport type FilterOptions = Omit<FilterTransform, 'type'>;\n\nfunction normalizeValue(value) {\n  if (typeof value === 'object') return [value.value, value.ordinal];\n  else return [value, true];\n}\n\nfunction filterWhenNoElements(mark: G2Mark) {\n  const { encode } = mark;\n\n  // keep y-axis\n  const noElementMark = {\n    ...mark,\n    encode: {\n      ...mark.encode,\n      y: {\n        ...mark.encode.y,\n        value: [],\n      },\n    },\n  };\n\n  const targetField = encode?.color?.field;\n  if (!encode || !targetField) {\n    return noElementMark;\n  }\n\n  // color\n  let filterObject;\n\n  for (const [key, v] of Object.entries(encode)) {\n    if ((key === 'x' || key === 'y') && v.field === targetField) {\n      filterObject = {\n        ...filterObject,\n        [key]: {\n          ...v,\n          value: [],\n        },\n      };\n    }\n  }\n\n  if (!filterObject) {\n    return noElementMark;\n  }\n\n  return {\n    ...mark,\n    encode: {\n      ...mark.encode,\n      ...filterObject,\n    },\n  };\n}\n\n/**\n * The Filter transform filter channels.\n */\nexport const Filter: TC<FilterOptions> = (options = {}) => {\n  return (I, mark) => {\n    const { encode, data } = mark;\n    const filters = Object.entries(options)\n      .map(([key, v]) => {\n        const [V] = columnOf(encode, key);\n        // Skip empty channel.\n        if (!V) return null;\n        const [value, ordinal = true] = normalizeValue(v);\n        if (typeof value === 'function') return (i) => value(V[i]);\n        if (ordinal) {\n          const expectedValues = Array.isArray(value) ? value : [value];\n          // Skip empty expected values.\n          if (expectedValues.length === 0) return null;\n          return (i) => expectedValues.includes(V[i]);\n        } else {\n          const [start, end] = value;\n          return (i) => V[i] >= start && V[i] <= end;\n        }\n      })\n      .filter(defined);\n    // Filter index and channels.\n    const totalFilter = (i) => filters.every((f) => f(i));\n    const FI = I.filter(totalFilter);\n    const newIndex = FI.map((_, i) => i);\n\n    if (filters.length === 0) {\n      const targetMark = filterWhenNoElements(mark);\n      return [I, targetMark];\n    }\n\n    const newEncodes = Object.entries(encode).map(([key, encode]) => {\n      return [\n        key,\n        {\n          ...encode,\n          value: newIndex\n            .map((i) => encode.value[FI[i]])\n            .filter((v) => v !== undefined),\n        },\n      ];\n    });\n    return [\n      newIndex,\n      deepMix({}, mark, {\n        encode: Object.fromEntries(newEncodes),\n        // Filter data for tooltip item.\n        data: FI.map((i) => data[i]),\n      }),\n    ];\n  };\n};\n\nFilter.props = {};\n"],"names":[],"mappings":";;;AAIA,OAAO,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAD1C,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAH1C,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;AAQrC,SAAS,cAAc,CAAC,KAAK;IAC3B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,OAAO;QAAC,KAAK,CAAC,KAAK;QAAE,KAAK,CAAC,OAAO;KAAC,CAAC;SAC9D,OAAO;QAAC,KAAK;QAAE,IAAI;KAAC,CAAC;AAC5B,CAAC;AAED,SAAS,oBAAoB,CAAC,IAAY;;IACxC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;IAExB,cAAc;IACd,MAAM,aAAa,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACd,IAAI,GAAA;QACP,MAAM,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACD,IAAI,CAAC,MAAM,GAAA;YACd,CAAC,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACI,IAAI,CAAC,MAAM,CAAC,CAAC,GAAA;gBAChB,KAAK,EAAE,EAAE;YAAA;QAAA;IAAA,EAGd,CAAC;IAEF,MAAM,WAAW,GAAG,CAAA,KAAA,MAAM,KAAA,QAAN,MAAM,KAAA,KAAA,IAAA,KAAA,IAAN,MAAM,CAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,CAAC;IACzC,IAAI,CAAC,MAAM,IAAI,CAAC,WAAW,EAAE;QAC3B,OAAO,aAAa,CAAC;KACtB;IAED,cAAc;IACd,IAAI,YAAY,CAAC;IAEjB,KAAK,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAE;QAC7C,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,WAAW,EAAE;YAC3D,YAAY,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACP,YAAY,GAAA;gBACf,CAAC,GAAG,CAAC,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACA,CAAC,GAAA;oBACJ,KAAK,EAAE,EAAE;gBAAA;YAAA,EAEZ,CAAC;SACH;KACF;IAED,IAAI,CAAC,YAAY,EAAE;QACjB,OAAO,aAAa,CAAC;KACtB;IAED,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACK,IAAI,GAAA;QACP,MAAM,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACD,IAAI,CAAC,MAAM,GACX,YAAY;IAAA,GAEjB;AACJ,CAAC;AAKM,MAAM,MAAM,GAAsB,CAAC,OAAO,GAAG,CAAA,CAAE,EAAE,EAAE;IACxD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QAC9B,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CACpC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,EAAE;YAChB,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAQ,AAAR,EAAS,MAAM,EAAE,GAAG,CAAC,CAAC;YAClC,sBAAsB;YACtB,IAAI,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC;YACpB,MAAM,CAAC,KAAK,EAAE,OAAO,GAAG,IAAI,CAAC,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YAClD,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE,OAAO,CAAC,CAAC,EAAE,CAAG,CAAD,IAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3D,IAAI,OAAO,EAAE;gBACX,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBAAC,KAAK;iBAAC,CAAC;gBAC9D,8BAA8B;gBAC9B,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC;gBAC7C,OAAO,CAAC,CAAC,EAAE,CAAG,CAAD,aAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aAC7C,MAAM;gBACL,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC;gBAC3B,OAAO,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC;aAC5C;QACH,CAAC,CAAC,CACD,MAAM,wJAAC,UAAO,CAAC,CAAC;QACnB,6BAA6B;QAC7B,MAAM,WAAW,GAAG,CAAC,CAAC,EAAE,CAAG,CAAD,MAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACtD,MAAM,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QACjC,MAAM,QAAQ,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC;QAErC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,MAAM,UAAU,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC;YAC9C,OAAO;gBAAC,CAAC;gBAAE,UAAU;aAAC,CAAC;SACxB;QAED,MAAM,UAAU,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,MAAM,CAAC,EAAE,EAAE;YAC9D,OAAO;gBACL,GAAG;gDAEE,MAAM,GAAA;oBACT,KAAK,EAAE,QAAQ,CACZ,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,KAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAC/B,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,KAAK,SAAS,CAAC;gBAAA;aAEpC,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,OAAO;YACL,QAAQ;qNACR,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,MAAM,EAAE,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC;gBACtC,gCAAgC;gBAChC,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,CAAC,CAAC,CAAC;aAC7B,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2002, "column": 0}, "map": {"version":3,"file":"maybeZeroY1.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeZeroY1.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { inferredColumn, constant } from './utils/helper';\n\nexport type MaybeZeroY1Options = Record<string, never>;\n\n/**\n * Add zero constant encode for y1 channel.\n */\nexport const MaybeZeroY1: TC<MaybeZeroY1Options> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { y1 } = encode;\n    if (y1 !== undefined) return [I, mark];\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: { y1: inferredColumn(constant(I, 0)) },\n      }),\n    ];\n  };\n};\n\nMaybeZeroY1.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;;;AAOnD,MAAM,WAAW,GAA2B,GAAG,EAAE;IACtD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,CAAC;QACtB,IAAI,EAAE,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACvC,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,MAAM,EAAE;oBAAE,EAAE,0KAAE,iBAAA,AAAc,EAAC,mLAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAAA,CAAE;aAC/C,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,WAAW,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2028, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2034, "column": 0}, "map": {"version":3,"file":"maybeZeroX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeZeroX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { inferredColumn, constant } from './utils/helper';\n\nexport type MaybeZeroXOptions = Record<string, never>;\n\n/**\n * Add zero constant encode for x channel.\n * This is useful for interval geometry.\n */\nexport const MaybeZeroX: TC<MaybeZeroXOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { x } = encode;\n    if (x !== undefined) return [I, mark];\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: { x: inferredColumn(constant(I, 0)) },\n        scale: { x: { guide: null } },\n      }),\n    ];\n  };\n};\n\nMaybeZeroX.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;;;AAQnD,MAAM,UAAU,GAA0B,GAAG,EAAE;IACpD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,CAAC,EAAE,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACtC,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,MAAM,EAAE;oBAAE,CAAC,0KAAE,iBAAA,AAAc,0KAAC,WAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAAA,CAAE;gBAC7C,KAAK,EAAE;oBAAE,CAAC,EAAE;wBAAE,KAAK,EAAE,IAAI;oBAAA,CAAE;gBAAA,CAAE;aAC9B,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,UAAU,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2065, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2071, "column": 0}, "map": {"version":3,"file":"maybeGradient.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeGradient.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { constant, visualColumn } from './utils/helper';\n\nexport type MaybeGradientOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeGradient: TC<MaybeGradientOptions> = () => {\n  return (I, mark) => {\n    const { style = {}, encode } = mark;\n    const { series } = encode;\n    const { gradient } = style;\n    if (!gradient || series) return [I, mark];\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: {\n          series: visualColumn(constant(I, undefined)),\n        },\n      }),\n    ];\n  };\n};\n\nMaybeGradient.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;;;AAQjD,MAAM,aAAa,GAA6B,GAAG,EAAE;IAC1D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,KAAK,GAAG,CAAA,CAAE,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACpC,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;QAC1B,MAAM,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC;QAC3B,IAAI,CAAC,QAAQ,IAAI,MAAM,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAC1C,OAAO;YACL,CAAC;aACD,kNAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,MAAM,EAAE;oBACN,MAAM,0KAAE,eAAA,AAAY,0KAAC,WAAA,AAAQ,EAAC,CAAC,EAAE,SAAS,CAAC,CAAC;iBAC7C;aACF,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,aAAa,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2104, "column": 0}, "map": {"version":3,"file":"maybeSeries.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeSeries.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, columnOf } from './utils/helper';\n\nexport type MaybeSeriesOptions = Record<string, never>;\n\n/**\n * Assume color channel is series channel.\n */\nexport const MaybeSeries: TC<MaybeSeriesOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { series, color } = encode;\n    if (series !== undefined || color === undefined) return [I, mark];\n    const [C, fc] = columnOf(encode, 'color');\n    return [I, deepMix({}, mark, { encode: { series: column(C, fc) } })];\n  };\n};\n\nMaybeSeries.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAS9B,MAAM,WAAW,GAA2B,GAAG,EAAE;IACtD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,CAAC;QACjC,IAAI,MAAM,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAClE,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,2KAAG,WAAA,AAAQ,EAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAC1C,OAAO;YAAC,CAAC;qNAAE,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,MAAM,0KAAE,SAAA,AAAM,EAAC,CAAC,EAAE,EAAE,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IACvE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,WAAW,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2131, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"file":"maybeZeroY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeZeroY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { inferredColumn, constant } from './utils/helper';\n\nexport type MaybeZeroYOptions = Record<string, never>;\n\n/**\n * Add zero constant encode for y channel.\n */\nexport const MaybeZeroY: TC<MaybeZeroYOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { y } = encode;\n    if (y !== undefined) return [I, mark];\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: { y: inferredColumn(constant(I, 0)) },\n        scale: { y: { guide: null } },\n      }),\n    ];\n  };\n};\n\nMaybeZeroY.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;;;AAOnD,MAAM,UAAU,GAA0B,GAAG,EAAE;IACpD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,CAAC,EAAE,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACtC,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,MAAM,EAAE;oBAAE,CAAC,0KAAE,iBAAA,AAAc,0KAAC,WAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAAA,CAAE;gBAC7C,KAAK,EAAE;oBAAE,CAAC,EAAE;wBAAE,KAAK,EAAE,IAAI;oBAAA,CAAE;gBAAA,CAAE;aAC9B,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,UAAU,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2168, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2174, "column": 0}, "map": {"version":3,"file":"maybeSize.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeSize.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { constant, visualColumn } from './utils/helper';\n\nexport type MaybeSizeOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeSize: TC<MaybeSizeOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { size } = encode;\n    if (size !== undefined) return [I, mark];\n    return [\n      I,\n      deepMix({}, mark, { encode: { size: visualColumn(constant(I, 3)) } }),\n    ];\n  };\n};\n\nMaybeSize.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;;;AAQjD,MAAM,SAAS,GAAyB,GAAG,EAAE;IAClD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;QACxB,IAAI,IAAI,KAAK,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACzC,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,IAAI,0KAAE,eAAA,AAAY,EAAC,mLAAA,AAAQ,EAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SACtE,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,SAAS,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2200, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2206, "column": 0}, "map": {"version":3,"file":"maybeTuple.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeTuple.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, isObject } from './utils/helper';\n\nexport type MaybeTupleOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeTuple: TC<MaybeTupleOptions> = () => {\n  return (I, mark) => {\n    const { data } = mark;\n    if (!Array.isArray(data) || data.some(isObject)) return [I, mark];\n    const position = Array.isArray(data[0]) ? data : [data];\n    const X = position.map((d) => d[0]);\n    const Y = position.map((d) => d[1]);\n    return [I, deepMix({}, mark, { encode: { x: column(X), y: column(Y) } })];\n  };\n};\n\nMaybeTuple.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,UAAU,GAA0B,GAAG,EAAE;IACpD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,qKAAC,WAAQ,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAClE,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YAAC,IAAI;SAAC,CAAC;QACxD,MAAM,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACpC,OAAO;YAAC,CAAC;qNAAE,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,CAAC,0KAAE,SAAA,AAAM,EAAC,CAAC,CAAC;oBAAE,CAAC,0KAAE,SAAA,AAAM,EAAC,CAAC,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IAC5E,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,UAAU,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2237, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2243, "column": 0}, "map": {"version":3,"file":"maybeVisualPosition.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeVisualPosition.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column } from './utils/helper';\n\nexport type MaybeVisualPositionOptions = Record<string, never>;\n\n/**\n * Set visual position with style.x and style.y.\n * The priority of style.x, style.y is higher than data.\n */\nexport const MaybeVisualPosition: TC<MaybeVisualPositionOptions> = () => {\n  return (I, mark) => {\n    const { data, style = {}, ...restMark } = mark;\n    const { x: x0, y: y0, ...rest } = style;\n    if (x0 == undefined || y0 == undefined) return [I, mark];\n    const x = x0 || 0;\n    const y = y0 || 0;\n    return [\n      [0],\n      deepMix({}, restMark, {\n        data: [0],\n        cartesian: true,\n        encode: {\n          x: column([x]),\n          y: column([y]),\n        },\n        scale: {\n          x: { type: 'identity', independent: true, guide: null }, // hide axis\n          y: { type: 'identity', independent: true, guide: null }, // hide axis\n        },\n        style: rest,\n      }),\n    ];\n  };\n};\n\nMaybeVisualPosition.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;;;;;;;;;;;AAQjC,MAAM,mBAAmB,GAAmC,GAAG,EAAE;IACtE,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,KAAK,GAAG,CAAA,CAAE,EAAA,GAAkB,IAAI,EAAjB,QAAQ,GAAA,OAAK,IAAI,EAAxC;YAAA;YAAA;SAAiC,CAAO,CAAC;QAC/C,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAA,GAAc,KAAK,EAAd,IAAI,GAAA,OAAK,KAAK,EAAjC;YAAA;YAAA;SAAyB,CAAQ,CAAC;QACxC,IAAI,EAAE,IAAI,SAAS,IAAI,EAAE,IAAI,SAAS,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACzD,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAClB,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAClB,OAAO;YACL;gBAAC,CAAC;aAAC;qNACH,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,QAAQ,EAAE;gBACpB,IAAI,EAAE;oBAAC,CAAC;iBAAC;gBACT,SAAS,EAAE,IAAI;gBACf,MAAM,EAAE;oBACN,CAAC,GAAE,gLAAA,AAAM,EAAC;wBAAC,CAAC;qBAAC,CAAC;oBACd,CAAC,0KAAE,SAAA,AAAM,EAAC;wBAAC,CAAC;qBAAC,CAAC;iBACf;gBACD,KAAK,EAAE;oBACL,CAAC,EAAE;wBAAE,IAAI,EAAE,UAAU;wBAAE,WAAW,EAAE,IAAI;wBAAE,KAAK,EAAE,IAAI;oBAAA,CAAE;oBACvD,CAAC,EAAE;wBAAE,IAAI,EAAE,UAAU;wBAAE,WAAW,EAAE,IAAI;wBAAE,KAAK,EAAE,IAAI;oBAAA,CAAE,EAAE,YAAY;iBACtE;gBACD,KAAK,EAAE,IAAI;aACZ,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,mBAAmB,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2309, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2315, "column": 0}, "map": {"version":3,"file":"maybeZeroPadding.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeZeroPadding.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\n\nexport type MaybeZeroPaddingOptions = Record<string, never>;\n\n/**\n * Set padding of x and y scale to zero.\n */\nexport const MaybeZeroPadding: TC<MaybeZeroPaddingOptions> = () => {\n  return (I, mark) => {\n    return [\n      I,\n      deepMix({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark),\n    ];\n  };\n};\n\nMaybeZeroPadding.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;AAQ9B,MAAM,gBAAgB,GAAgC,GAAG,EAAE;IAChE,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,OAAO;YACL,CAAC;qNACD,UAAA,AAAO,EAAC;gBAAE,KAAK,EAAE;oBAAE,CAAC,EAAE;wBAAE,OAAO,EAAE,CAAC;oBAAA,CAAE;oBAAE,CAAC,EAAE;wBAAE,OAAO,EAAE,CAAC;oBAAA,CAAE;gBAAA,CAAE;YAAA,CAAE,EAAE,IAAI,CAAC;SACnE,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,gBAAgB,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2344, "column": 0}, "map": {"version":3,"file":"maybeIdentityY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeIdentityY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, columnOf } from './utils/helper';\n\nexport type MaybeIdentityYOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeIdentityY: TC<MaybeIdentityYOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { y1 } = encode;\n    if (y1) return [I, mark];\n    const [Y] = columnOf(encode, 'y');\n    return [I, deepMix({}, mark, { encode: { y1: column([...Y]) } })];\n  };\n};\n\nMaybeIdentityY.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,cAAc,GAA8B,GAAG,EAAE;IAC5D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,CAAC;QACtB,IAAI,EAAE,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACzB,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAQ,AAAR,EAAS,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,OAAO;YAAC,CAAC;aAAE,kNAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,EAAE,0KAAE,SAAM,AAAN,EAAO,CAAC;2BAAG,CAAC;qBAAC,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IACpE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,cAAc,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2373, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2379, "column": 0}, "map": {"version":3,"file":"maybeIdentityX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeIdentityX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, columnOf } from './utils/helper';\n\nexport type MaybeIdentityXOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeIdentityX: TC<MaybeIdentityXOptions> = () => {\n  return (I, mark) => {\n    const { encode } = mark;\n    const { x1 } = encode;\n    if (x1) return [I, mark];\n    const [X] = columnOf(encode, 'x');\n    return [I, deepMix({}, mark, { encode: { x1: column([...X]) } })];\n  };\n};\n\nMaybeIdentityX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,cAAc,GAA8B,GAAG,EAAE;IAC5D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACxB,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,CAAC;QACtB,IAAI,EAAE,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QACzB,MAAM,CAAC,CAAC,CAAC,2KAAG,WAAQ,AAAR,EAAS,MAAM,EAAE,GAAG,CAAC,CAAC;QAClC,OAAO;YAAC,CAAC;aAAE,kNAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,EAAE,0KAAE,SAAM,AAAN,EAAO,CAAC;2BAAG,CAAC;qBAAC,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IACpE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,cAAc,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2408, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2414, "column": 0}, "map": {"version":3,"file":"maybeTupleX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeTupleX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, isObject } from './utils/helper';\n\nexport type MaybeTupleXOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeTupleX: TC<MaybeTupleXOptions> = () => {\n  return (I, mark) => {\n    const { data } = mark;\n    if (!Array.isArray(data) || data.some(isObject)) return [I, mark];\n    return [I, deepMix({}, mark, { encode: { x: column(data) } })];\n  };\n};\n\nMaybeTupleX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,WAAW,GAA2B,GAAG,EAAE;IACtD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,qKAAC,WAAQ,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAClE,OAAO;YAAC,CAAC;aAAE,kNAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,CAAC,0KAAE,SAAA,AAAM,EAAC,IAAI,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IACjE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,WAAW,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2439, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2445, "column": 0}, "map": {"version":3,"file":"maybeTupleY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeTupleY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, isObject } from './utils/helper';\n\nexport type MaybeTupleYOptions = Record<string, never>;\n\n/**\n * Add 3 constant encode for size channel.\n * This is useful for point geometry.\n */\nexport const MaybeTupleY: TC<MaybeTupleYOptions> = () => {\n  return (I, mark) => {\n    const { data } = mark;\n    if (!Array.isArray(data) || data.some(isObject)) return [I, mark];\n    return [I, deepMix({}, mark, { encode: { y: column(data) } })];\n  };\n};\n\nMaybeTupleY.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,WAAW,GAA2B,GAAG,EAAE;IACtD,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,qKAAC,WAAQ,CAAC,EAAE,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;QAClE,OAAO;YAAC,CAAC;aAAE,kNAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;gBAAE,MAAM,EAAE;oBAAE,CAAC,0KAAE,SAAA,AAAM,EAAC,IAAI,CAAC;gBAAA,CAAE;YAAA,CAAE,CAAC;SAAC,CAAC;IACjE,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,WAAW,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2470, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"file":"maybeDefaultX.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeDefaultX.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { column, isObject } from './utils/helper';\n\nexport type MaybeDefaultXOptions = Record<string, never>;\n\n/**\n * Add a default encode for rangeX\n * when data is just an array\n */\nexport const MaybeDefaultX: TC<MaybeDefaultXOptions> = () => {\n  return (I, mark) => {\n    const { data } = mark;\n    if (\n      Array.isArray(data) &&\n      (data.every(Array.isArray) || !data.some(isObject))\n    ) {\n      const extractX = (data, index: number) =>\n        Array.isArray(data[0])\n          ? data.map((item) => item[index])\n          : [data[index]];\n      return [\n        I,\n        deepMix({}, mark, {\n          encode: {\n            x: column(extractX(data, 0)),\n            x1: column(extractX(data, 1)),\n          },\n        }),\n      ];\n    }\n    return [I, mark];\n  };\n};\n\nMaybeDefaultX.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,aAAa,GAA6B,GAAG,EAAE;IAC1D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QACtB,IACE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IACnB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,qKAAC,WAAQ,CAAC,CAAC,EACnD;YACA,MAAM,QAAQ,GAAG,CAAC,IAAI,EAAE,KAAa,EAAE,CACrC,CADuC,IAClC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAClB,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAG,CAAD,GAAK,CAAC,KAAK,CAAC,CAAC,GAC/B;oBAAC,IAAI,CAAC,KAAK,CAAC;iBAAC,CAAC;YACpB,OAAO;gBACL,CAAC;yNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;oBAChB,MAAM,EAAE;wBACN,CAAC,0KAAE,SAAA,AAAM,EAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;wBAC5B,EAAE,0KAAE,SAAM,AAAN,EAAO,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;qBAC9B;iBACF,CAAC;aACH,CAAC;SACH;QACD,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;IACnB,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,aAAa,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2513, "column": 0}, "map": {"version":3,"file":"maybeDefaultY.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeDefaultY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { Primitive, TransformComponent as TC } from '../runtime';\nimport { column, isObject } from './utils/helper';\n\nexport type MaybeDefaultYOptions = Record<string, never>;\n\n/**\n * Add a default encode for rangeY\n * when data is just an array\n */\nexport const MaybeDefaultY: TC<MaybeDefaultYOptions> = () => {\n  return (I, mark) => {\n    const { data } = mark;\n    if (\n      Array.isArray(data) &&\n      (data.every(Array.isArray) || !data.some(isObject))\n    ) {\n      const extractY = (data, index: number) =>\n        Array.isArray(data[0])\n          ? data.map((item) => item[index])\n          : [data[index]];\n      return [\n        I,\n        deepMix({}, mark, {\n          encode: {\n            y: column(extractY(data, 0)),\n            y1: column(extractY(data, 1)),\n          },\n        }),\n      ];\n    }\n    return [I, mark];\n  };\n};\n\nMaybeDefaultY.props = {};\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAFlD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;AAU9B,MAAM,aAAa,GAA6B,GAAG,EAAE;IAC1D,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QACtB,IACE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IACnB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,qKAAC,WAAQ,CAAC,CAAC,EACnD;YACA,MAAM,QAAQ,GAAG,CAAC,IAAI,EAAE,KAAa,EAAE,CACrC,CADuC,IAClC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAClB,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAG,CAAD,GAAK,CAAC,KAAK,CAAC,CAAC,GAC/B;oBAAC,IAAI,CAAC,KAAK,CAAC;iBAAC,CAAC;YACpB,OAAO;gBACL,CAAC;yNACD,UAAA,AAAO,EAAC,CAAA,CAAE,EAAE,IAAI,EAAE;oBAChB,MAAM,EAAE;wBACN,CAAC,0KAAE,SAAA,AAAM,EAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;wBAC5B,EAAE,0KAAE,SAAM,AAAN,EAAO,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;qBAC9B;iBACF,CAAC;aACH,CAAC;SACH;QACD,OAAO;YAAC,CAAC;YAAE,IAAI;SAAC,CAAC;IACnB,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,aAAa,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2544, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2550, "column": 0}, "map": {"version":3,"file":"maybeFunctionAttribute.js","sources":["file:///Users/xiezhendong1/Documents/code/github/zeno/node_modules/%40antv/g2/src/transform/maybeFunctionAttribute.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\n\nexport type MaybeFunctionAttributeOptions = Record<string, never>;\n\n/**\n * Mark functional attribute constant.\n */\nexport const MaybeFunctionAttribute: TC<MaybeFunctionAttributeOptions> = () => {\n  return (I, mark) => {\n    const { style = {} } = mark;\n    return [\n      I,\n      deepMix({}, mark, {\n        style: {\n          ...style,\n          ...Object.fromEntries(\n            Object.entries(style)\n              .filter(([, v]) => typeof v === 'function')\n              .map(([k, v]) => [k, () => v]),\n          ),\n        },\n      }),\n    ];\n  };\n};\n\nMaybeFunctionAttribute.props = {};\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;AAQ9B,MAAM,sBAAsB,GAAsC,GAAG,EAAE;IAC5E,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACjB,MAAM,EAAE,KAAK,GAAG,CAAA,CAAE,EAAE,GAAG,IAAI,CAAC;QAC5B,OAAO;YACL,CAAC;aACD,kNAAO,AAAP,EAAQ,CAAA,CAAE,EAAE,IAAI,EAAE;gBAChB,KAAK,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACA,KAAK,GACL,MAAM,CAAC,WAAW,CACnB,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAClB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,MAAQ,CAAC,KAAK,UAAU,CAAC,CAC1C,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD;wBAAE,CAAC;wBAAE,GAAG,CAAG,CAAD,AAAE;qBAAC,CAAC,CACjC,CACF;aACF,CAAC;SACH,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF,sBAAsB,CAAC,KAAK,GAAG,CAAA,CAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2570, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}