(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@antv_g2_esm_runtime_1cffd5._.js", {

"[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AREA_CLASS_NAME": (()=>AREA_CLASS_NAME),
    "BREAK_CLASS_NAME": (()=>BREAK_CLASS_NAME),
    "BREAK_GROUP_CLASS_NAME": (()=>BREAK_GROUP_CLASS_NAME),
    "COMPONENT_CLASS_NAME": (()=>COMPONENT_CLASS_NAME),
    "ELEMENT_CLASS_NAME": (()=>ELEMENT_CLASS_NAME),
    "LABEL_CLASS_NAME": (()=>LABEL_CLASS_NAME),
    "LABEL_LAYER_CLASS_NAME": (()=>LABEL_LAYER_CLASS_NAME),
    "MAIN_LAYER_CLASS_NAME": (()=>MAIN_LAYER_CLASS_NAME),
    "MASK_CLASS_NAME": (()=>MASK_CLASS_NAME),
    "PLOT_CLASS_NAME": (()=>PLOT_CLASS_NAME),
    "VIEW_CLASS_NAME": (()=>VIEW_CLASS_NAME)
});
const MAIN_LAYER_CLASS_NAME = 'main-layer';
const LABEL_LAYER_CLASS_NAME = 'label-layer';
const ELEMENT_CLASS_NAME = 'element';
const VIEW_CLASS_NAME = 'view';
const PLOT_CLASS_NAME = 'plot';
const COMPONENT_CLASS_NAME = 'component';
const LABEL_CLASS_NAME = 'label';
const AREA_CLASS_NAME = 'area';
const MASK_CLASS_NAME = 'mask';
const BREAK_CLASS_NAME = 'axis-breaks';
const BREAK_GROUP_CLASS_NAME = 'axis-breaks-group'; //# sourceMappingURL=constant.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/option-preprocess/style.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "columnWidthRatio": (()=>columnWidthRatio)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
;
function columnWidthRatio(options) {
    const { style, scale, type } = options;
    const scaleOption = {};
    const columnWidthRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(style, 'columnWidthRatio');
    if (columnWidthRatio && type === 'interval') {
        scaleOption.x = Object.assign(Object.assign({}, scale === null || scale === void 0 ? void 0 : scale.x), {
            padding: 1 - columnWidthRatio
        });
    }
    return Object.assign(Object.assign({}, options), {
        scale: Object.assign(Object.assign({}, scale), scaleOption)
    });
} //# sourceMappingURL=style.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/option-preprocess/axis-breaks.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "axisBreaks": (()=>axisBreaks),
    "percentToRatio": (()=>percentToRatio)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__set$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/set.js [app-client] (ecmascript) <export default as set>");
;
const percentToRatio = (gap)=>{
    if (!gap || typeof gap !== 'string') {
        return gap;
    }
    const value = gap.endsWith('%') ? parseFloat(gap.slice(0, -1)) / 100 : parseFloat(gap);
    if (isNaN(value) || value < 0 || value > 1) {
        throw new Error(`Invalid gap value: ${gap}. It should be between 0 and 1.`);
    }
    return value;
};
function axisBreaks(options) {
    const { axis } = options;
    const breaks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(axis, 'y.breaks');
    if (breaks) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__set$3e$__["set"])(options, 'scale.y.breaks', breaks.map((item)=>Object.assign(Object.assign({
                key: `break-${item.start}-${item.end}`
            }, item), {
                gap: percentToRatio(item.gap)
            })));
    }
    return options;
} //# sourceMappingURL=axis-breaks.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/option-preprocess/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "preprocessOption": (()=>preprocessOption)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$flow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/flow.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$option$2d$preprocess$2f$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/option-preprocess/style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$option$2d$preprocess$2f$axis$2d$breaks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/option-preprocess/axis-breaks.js [app-client] (ecmascript)");
;
;
;
function preprocessOption(options) {
    const convertedOptions = adapter(options);
    // If there are children, recursively convert each child node.
    if (convertedOptions.children && Array.isArray(convertedOptions.children)) {
        convertedOptions.children = convertedOptions.children.map((child)=>preprocessOption(child));
    }
    return convertedOptions;
}
// Entry point for all syntactic sugar functions.
function adapter(options) {
    //@todo define a type for params of flow
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$flow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flow"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$option$2d$preprocess$2f$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["columnWidthRatio"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$option$2d$preprocess$2f$axis$2d$breaks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["axisBreaks"])(options);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "documentOf": (()=>documentOf),
    "useLibrary": (()=>useLibrary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$lib$2f$builtinlib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/lib/builtinlib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
function useLibrary(namespace, publicLibrary) {
    const library = Object.assign(Object.assign({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$lib$2f$builtinlib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["builtinlib"])()), publicLibrary);
    const create = (type)=>{
        if (typeof type !== 'string') return type;
        const key = `${namespace}.${type}`;
        return library[key] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(`Unknown Component: ${key}`);
    };
    const use = (options, context)=>{
        const { type } = options, rest = __rest(options, [
            "type"
        ]);
        if (!type) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(`Plot type is required!`);
        const currentLibrary = create(type);
        return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
    };
    return [
        use,
        create
    ];
}
function documentOf(library) {
    const { canvas, group } = library;
    return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group === null || group === void 0 ? void 0 : group.ownerDocument) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(`Cannot find library document`);
} //# sourceMappingURL=library.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/coordinate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "coordOf": (()=>coordOf),
    "coordinate2Transform": (()=>coordinate2Transform),
    "createCoordinate": (()=>createCoordinate),
    "isHelix": (()=>isHelix),
    "isParallel": (()=>isParallel),
    "isPolar": (()=>isPolar),
    "isRadar": (()=>isRadar),
    "isRadial": (()=>isRadial),
    "isReflect": (()=>isReflect),
    "isReflectY": (()=>isReflectY),
    "isTheta": (()=>isTheta),
    "isTranspose": (()=>isTranspose)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$coord$2f$dist$2f$coordinate$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/coord/dist/coordinate.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
function createCoordinate(layout, partialOptions, library) {
    const [useCoordinate] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('coordinate', library);
    const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
    const { coordinates: partialTransform = [] } = partialOptions;
    const transform = inferCoordinate(partialTransform);
    const isCartesian3D = transform[0].type === 'cartesian3D';
    const options = Object.assign(Object.assign({}, layout), {
        x: insetLeft,
        y: insetTop,
        width: innerWidth - insetLeft - insetRight,
        height: innerHeight - insetBottom - insetTop,
        transformations: transform.flatMap(useCoordinate)
    });
    const coordinate = isCartesian3D ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$coord$2f$dist$2f$coordinate$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Coordinate3D"](options) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$coord$2f$dist$2f$coordinate$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Coordinate"](options);
    return coordinate;
}
function coordinate2Transform(node, library) {
    // @ts-ignore
    const { coordinate = {}, coordinates } = node, rest = __rest(node, [
        "coordinate",
        "coordinates"
    ]);
    // If coordinates are already set, it means that the coordinate has been processed
    // during the initialization. There is not need to process it during update.
    if (coordinates) return node;
    const { type, transform = [] } = coordinate, options = __rest(coordinate, [
        "type",
        "transform"
    ]);
    if (!type) return Object.assign(Object.assign({}, rest), {
        coordinates: transform
    });
    const [, createCoordinate] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('coordinate', library);
    const { transform: isTransform = false } = createCoordinate(type).props || {};
    if (isTransform) {
        throw new Error(`Unknown coordinate: ${type}.`);
    }
    return Object.assign(Object.assign({}, rest), {
        coordinates: [
            Object.assign({
                type
            }, options),
            ...transform
        ]
    });
}
function coordOf(coordinates, type) {
    return coordinates.filter((d)=>d.type === type);
}
function isPolar(coordinates) {
    return coordOf(coordinates, 'polar').length > 0;
}
function isHelix(coordinates) {
    return coordOf(coordinates, 'helix').length > 0;
}
function isTranspose(coordinates) {
    return coordOf(coordinates, 'transpose').length % 2 === 1;
}
function isParallel(coordinates) {
    return coordOf(coordinates, 'parallel').length > 0;
}
function isTheta(coordinates) {
    return coordOf(coordinates, 'theta').length > 0;
}
function isReflect(coordinates) {
    return coordOf(coordinates, 'reflect').length > 0;
}
function isRadial(coordinates) {
    return coordOf(coordinates, 'radial').length > 0;
}
function isRadar(coordinates) {
    return coordOf(coordinates, 'radar').length > 0;
}
function isReflectY(coordinates) {
    return coordOf(coordinates, 'reflectY').length > 0;
}
function inferCoordinate(coordinates) {
    if (coordinates.find((d)=>d.type === 'cartesian' || d.type === 'cartesian3D')) return coordinates;
    return [
        ...coordinates,
        {
            type: 'cartesian'
        }
    ];
} //# sourceMappingURL=coordinate.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/scale.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applyScale": (()=>applyScale),
    "assignScale": (()=>assignScale),
    "collectScales": (()=>collectScales),
    "groupTransform": (()=>groupTransform),
    "inferScale": (()=>inferScale),
    "isPosition": (()=>isPosition),
    "isValidScale": (()=>isValidScale),
    "syncFacetsScales": (()=>syncFacetsScales),
    "useRelation": (()=>useRelation),
    "useRelationScale": (()=>useRelationScale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$scale$2d$chromatic$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-scale-chromatic.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__omit$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/omit.js [app-client] (ecmascript) <export default as omit>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__extent$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/extent.js [app-client] (ecmascript) <export default as extent>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$linear$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/scale/esm/scales/linear.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/upper-first.js [app-client] (ecmascript) <export default as upperFirst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$scale$2d$chromatic$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-scale-chromatic.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$utils$2f$interpolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/scale/esm/utils/interpolate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/coordinate.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function inferScale(name, values, options, coordinates, theme, library) {
    const { guide = {} } = options;
    const type = inferScaleType(name, values, options);
    if (typeof type !== 'string') return options;
    const expectedDomain = inferScaleDomain(type, name, values, options);
    const actualDomain = maybeRatio(type, expectedDomain, options);
    return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name, values, options, coordinates)), {
        domain: actualDomain,
        range: inferScaleRange(type, name, values, options, actualDomain, theme, library),
        expectedDomain,
        guide,
        name,
        type
    });
}
function applyScale(channels, scale) {
    const scaledValue = {};
    for (const channel of channels){
        const { values, name: scaleName } = channel;
        const scaleInstance = scale[scaleName];
        for (const value of values){
            const { name, value: V } = value;
            scaledValue[name] = V.map((d)=>scaleInstance.map(d));
        }
    }
    return scaledValue;
}
function groupTransform(markState, uidScale) {
    const channels = Array.from(markState.values()).flatMap((d)=>d.channels);
    const scaleGroups = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rollups"])(channels, (channels)=>channels.map((d)=>uidScale.get(d.scale.uid)), (d)=>d.name).filter(([, scales])=>scales.some((d)=>typeof d.getOptions().groupTransform === 'function') && // only sync scales with groupTransform options
        scales.every((d)=>d.getTicks)).map((d)=>d[1]);
    scaleGroups.forEach((group)=>{
        const groupTransform = group.map((d)=>d.getOptions().groupTransform)[0];
        groupTransform(group);
    });
}
function collectScales(states, options) {
    var _a;
    const { components = [] } = options;
    const NONE_STATIC_KEYS = [
        'scale',
        'encode',
        'axis',
        'legend',
        'data',
        'transform'
    ];
    // From normal marks.
    const scales = Array.from(new Set(states.flatMap((d)=>d.channels.map((d)=>d.scale))));
    // From static marks.
    const nameScale = new Map(scales.map((scale)=>[
            scale.name,
            scale
        ]));
    for (const component of components){
        const channels = inferChannelsForComponent(component);
        for (const channel of channels){
            const scale = nameScale.get(channel);
            const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};
            const { independent = false } = staticScale;
            if (scale && !independent) {
                // Merged with exist scales if is not independent.
                const { guide } = scale;
                const guide1 = typeof guide === 'boolean' ? {} : guide;
                scale.guide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, guide1, component);
                Object.assign(scale, staticScale);
            } else {
                // Append new scales without exit scales or independent.
                const options1 = Object.assign(Object.assign({}, staticScale), {
                    expectedDomain: staticScale.domain,
                    name: channel,
                    guide: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__omit$3e$__["omit"])(component, NONE_STATIC_KEYS)
                });
                scales.push(options1);
            }
        }
    }
    return scales;
}
function useRelation(relations) {
    if (!relations || !Array.isArray(relations)) return [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"]
    ];
    // Store original map and invert.
    let map;
    let invert;
    const conditionalize = (scale)=>{
        var _a;
        map = scale.map.bind(scale);
        invert = (_a = scale.invert) === null || _a === void 0 ? void 0 : _a.bind(scale);
        // Distinguish functions[function, output] and value[vale, output] relations.
        const funcRelations = relations.filter(([v])=>typeof v === 'function');
        const valueRelations = relations.filter(([v])=>typeof v !== 'function');
        // Update scale.map
        const valueOutput = new Map(valueRelations);
        scale.map = (x)=>{
            for (const [verify, value] of funcRelations){
                if (verify(x)) return value;
            }
            if (valueOutput.has(x)) return valueOutput.get(x);
            return map(x);
        };
        if (!invert) return scale;
        // Update scale.invert
        const outputValue = new Map(valueRelations.map(([a, b])=>[
                b,
                a
            ]));
        const outputFunc = new Map(funcRelations.map(([a, b])=>[
                b,
                a
            ]));
        scale.invert = (x)=>{
            if (outputFunc.has(x)) return x;
            if (outputValue.has(x)) return outputValue.get(x);
            return invert(x);
        };
        return scale;
    };
    const deconditionalize = (scale)=>{
        if (map !== null) scale.map = map;
        if (invert !== null) scale.invert = invert;
        return scale;
    };
    return [
        conditionalize,
        deconditionalize
    ];
}
function assignScale(target, source) {
    const keys = Object.keys(target);
    for (const scale of Object.values(source)){
        const { name } = scale.getOptions();
        if (!(name in target)) target[name] = scale;
        else {
            const I = keys.filter((d)=>d.startsWith(name))// Reg is for extract `1` from `x1`;
            .map((d)=>+(d.replace(name, '') || 0));
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(I) + 1;
            const newKey = `${name}${index}`;
            target[newKey] = scale;
            scale.getOptions().key = newKey;
        }
    }
    return target;
}
function useRelationScale(options, library) {
    const [useScale] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('scale', library);
    const { relations } = options;
    const [conditionalize] = useRelation(relations);
    const scale = useScale(options);
    return conditionalize(scale);
}
function syncFacetsScales(states) {
    const scales = states.flatMap((d)=>Array.from(d.values())).flatMap((d)=>d.channels.map((d)=>d.scale));
    syncFacetsScaleByChannel(scales, 'x');
    syncFacetsScaleByChannel(scales, 'y');
}
function inferChannelsForComponent(component) {
    const { channels = [], type, scale = {} } = component;
    const L = [
        'shape',
        'color',
        'opacity',
        'size'
    ];
    if (channels.length !== 0) return channels;
    if (type === 'axisX') return [
        'x'
    ];
    if (type === 'axisY') return [
        'y'
    ];
    if (type === 'legends') return Object.keys(scale).filter((d)=>L.includes(d));
    return [];
}
function syncFacetsScaleByChannel(scales, channel) {
    const S = scales.filter(({ name, facet = true })=>facet && name === channel);
    const D = S.flatMap((d)=>d.domain);
    const syncedD = S.every(isQuantitativeScale) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__extent$3e$__["extent"])(D) : S.every(isDiscreteScale) ? Array.from(new Set(D)) : null;
    if (syncedD === null) return;
    for (const scale of S){
        scale.domain = syncedD;
    }
}
function maybeRatio(type, domain, options) {
    const { ratio } = options;
    if (ratio === undefined || ratio === null) return domain;
    if (isQuantitativeScale({
        type
    })) {
        return clampQuantitativeScale(domain, ratio, type);
    }
    if (isDiscreteScale({
        type
    })) return clampDiscreteScale(domain, ratio);
    return domain;
}
function clampQuantitativeScale(domain, ratio, type) {
    const D = domain.map(Number);
    const scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$linear$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Linear"]({
        domain: D,
        range: [
            D[0],
            D[0] + (D[D.length - 1] - D[0]) * ratio
        ]
    });
    if (type === 'time') return domain.map((d)=>new Date(scale.map(d)));
    return domain.map((d)=>scale.map(d));
}
function clampDiscreteScale(domain, ratio) {
    const index = Math.round(domain.length * ratio);
    return domain.slice(0, index);
}
function isQuantitativeScale(scale) {
    const { type } = scale;
    if (typeof type !== 'string') return false;
    // Do not take quantize, quantile or threshold scale into account,
    // because they are not for position scales. If they are, there is
    // no need to sync them.
    const names = [
        'linear',
        'log',
        'pow',
        'time'
    ];
    return names.includes(type);
}
function isDiscreteScale(scale) {
    const { type } = scale;
    if (typeof type !== 'string') return false;
    const names = [
        'band',
        'point',
        'ordinal'
    ];
    return names.includes(type);
}
// @todo More accurate inference for different cases.
function inferScaleType(name, values, options) {
    const { type, domain, range, quantitative, ordinal } = options;
    if (type !== undefined) return type;
    if (isObject(values)) return 'identity';
    if (typeof range === 'string') return 'linear';
    if ((domain || range || []).length > 2) return asOrdinalType(name, ordinal);
    if (domain !== undefined) {
        if (isOrdinal([
            domain
        ])) return asOrdinalType(name, ordinal);
        if (isTemporal(values)) return 'time';
        return asQuantitativeType(name, range, quantitative);
    }
    if (isOrdinal(values)) return asOrdinalType(name, ordinal);
    if (isTemporal(values)) return 'time';
    return asQuantitativeType(name, range, quantitative);
}
function inferScaleDomain(type, name, values, options) {
    const { domain } = options;
    if (domain !== undefined) return domain;
    switch(type){
        case 'linear':
        case 'time':
        case 'log':
        case 'pow':
        case 'sqrt':
        case 'quantize':
        case 'threshold':
            return maybeMinMax(inferDomainQ(values, options), options);
        case 'band':
        case 'ordinal':
        case 'point':
            return inferDomainC(values);
        case 'quantile':
            return inferDomainO(values);
        case 'sequential':
            return maybeMinMax(inferDomainS(values), options);
        default:
            return [];
    }
}
function inferScaleRange(type, name, values, options, domain, theme, library) {
    const { range } = options;
    if (typeof range === 'string') return gradientColors(range);
    if (range !== undefined) return range;
    const { rangeMin, rangeMax } = options;
    switch(type){
        case 'linear':
        case 'time':
        case 'log':
        case 'pow':
        case 'sqrt':
            {
                const colors = categoricalColors(values, options, domain, theme, library);
                const [r0, r1] = inferRangeQ(name, colors);
                return [
                    rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0,
                    rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1
                ];
            }
        case 'band':
        case 'point':
            {
                const min = name === 'size' ? 5 : 0;
                const max = name === 'size' ? 10 : 1;
                return [
                    rangeMin !== null && rangeMin !== void 0 ? rangeMin : min,
                    rangeMax !== null && rangeMax !== void 0 ? rangeMax : max
                ];
            }
        case 'ordinal':
            {
                return categoricalColors(values, options, domain, theme, library);
            }
        case 'sequential':
            return undefined;
        case 'constant':
            return [
                values[0][0]
            ];
        default:
            return [];
    }
}
function inferScaleOptions(type, name, values, options, coordinates) {
    switch(type){
        case 'linear':
        case 'time':
        case 'log':
        case 'pow':
        case 'sqrt':
            return inferOptionsQ(coordinates, options);
        case 'band':
        case 'point':
            return inferOptionsC(type, name, coordinates, options);
        case 'sequential':
            return inferOptionsS(options);
        default:
            return options;
    }
}
function categoricalColors(values, options, domain, theme, library) {
    const [usePalette] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('palette', library);
    const { category10: c10, category20: c20 } = theme;
    const defaultPalette = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unique"])(domain).length <= c10.length ? c10 : c20;
    const { palette = defaultPalette, offset } = options;
    if (Array.isArray(palette)) return palette;
    // Built-in palettes have higher priority.
    try {
        return usePalette({
            type: palette
        });
    } catch (e) {
        const colors = interpolatedColors(palette, domain, offset);
        if (colors) return colors;
        throw new Error(`Unknown Component: ${palette} `);
    }
}
function gradientColors(range) {
    return range.split('-');
}
function interpolatedColors(palette, domain, offset = (d)=>d) {
    if (!palette) return null;
    const fullName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(palette);
    // If scheme have enough colors, then return pre-defined colors.
    const scheme = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$scale$2d$chromatic$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[`scheme${fullName}`];
    const interpolator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$scale$2d$chromatic$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[`interpolate${fullName}`];
    if (!scheme && !interpolator) return null;
    if (scheme) {
        // If is a one dimension array, return it.
        if (!scheme.some(Array.isArray)) return scheme;
        const schemeColors = scheme[domain.length];
        if (schemeColors) return schemeColors;
    }
    // Otherwise interpolate to get full colors.
    return domain.map((_, i)=>interpolator(offset(i / domain.length)));
}
function inferOptionsS(options) {
    const { palette = 'ylGnBu', offset } = options;
    const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(palette);
    const interpolator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$scale$2d$chromatic$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[`interpolate${name}`];
    if (!interpolator) throw new Error(`Unknown palette: ${name}`);
    return {
        interpolator: offset ? (x)=>interpolator(offset(x)) : interpolator
    };
}
function inferOptionsQ(coordinates, options) {
    const { interpolate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$utils$2f$interpolate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createInterpolateValue"], nice = false, tickCount = 5 } = options;
    return Object.assign(Object.assign({}, options), {
        interpolate,
        nice,
        tickCount
    });
}
function inferOptionsC(type, name, coordinates, options) {
    if (options.padding !== undefined || options.paddingInner !== undefined || options.paddingOuter !== undefined) {
        return Object.assign(Object.assign({}, options), {
            unknown: NaN
        });
    }
    const padding = inferPadding(type, name, coordinates);
    const { paddingInner = padding, paddingOuter = padding } = options;
    return Object.assign(Object.assign({}, options), {
        paddingInner,
        paddingOuter,
        padding,
        unknown: NaN
    });
}
function inferPadding(type, name, coordinates) {
    // The scale for enterDelay and enterDuration should has zero padding by default.
    // Because there is no need to add extra delay for the start and the end.
    if (name === 'enterDelay' || name === 'enterDuration') return 0;
    if (name === 'size') return 0;
    if (type === 'band') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTheta"])(coordinates) ? 0 : 0.1;
    // Point scale need 0.5 padding to make interval between first and last point
    // equal to other intervals in polar coordinate.
    if (type === 'point') return 0.5;
    return 0;
}
function asOrdinalType(name, defaults) {
    if (defaults) return defaults;
    return isQuantitative(name) ? 'point' : 'ordinal';
}
function asQuantitativeType(name, range, defaults) {
    if (defaults) return defaults;
    if (name !== 'color') return 'linear';
    return range ? 'linear' : 'sequential';
}
function maybeMinMax(domain, options) {
    if (domain.length === 0) return domain;
    const { domainMin, domainMax } = options;
    const [d0, d1] = domain;
    return [
        domainMin !== null && domainMin !== void 0 ? domainMin : d0,
        domainMax !== null && domainMax !== void 0 ? domainMax : d1
    ];
}
function inferDomainQ(values, options) {
    const { zero = false } = options;
    let min = Infinity;
    let max = -Infinity;
    for (const value of values){
        for (const d of value){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(d)) {
                min = Math.min(min, +d);
                max = Math.max(max, +d);
            }
        }
    }
    if (min === Infinity) return [];
    return zero ? [
        Math.min(0, min),
        max
    ] : [
        min,
        max
    ];
}
function inferDomainC(values) {
    return Array.from(new Set(values.flat()));
}
function inferDomainO(values) {
    return values.flat().sort();
}
function inferDomainS(values) {
    let min = Infinity;
    let max = -Infinity;
    for (const value of values){
        for (const d of value){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(d)) {
                min = Math.min(min, +d);
                max = Math.max(max, +d);
            }
        }
    }
    if (min === Infinity) return [];
    return [
        min < 0 ? -max : min,
        max
    ];
}
/**
 * @todo More nice default range for enterDelay and enterDuration.
 * @todo Move these to channel definition.
 */ function inferRangeQ(name, palette) {
    if (name === 'enterDelay') return [
        0,
        1000
    ];
    if (name == 'enterDuration') return [
        300,
        1000
    ];
    if (name.startsWith('y') || name.startsWith('position')) return [
        1,
        0
    ];
    if (name === 'color') return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["firstOf"])(palette),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastOf"])(palette)
    ];
    if (name === 'opacity') return [
        0,
        1
    ];
    if (name === 'size') return [
        1,
        10
    ];
    return [
        0,
        1
    ];
}
function isOrdinal(values) {
    return some(values, (d)=>{
        const type = typeof d;
        return type === 'string' || type === 'boolean';
    });
}
function isTemporal(values) {
    return some(values, (d)=>d instanceof Date);
}
function isObject(values) {
    return some(values, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStrictObject"]);
}
function some(values, callback) {
    for (const V of values){
        if (V.some(callback)) return true;
    }
    return false;
}
function isQuantitative(name) {
    return name.startsWith('x') || name.startsWith('y') || name.startsWith('position') || name.startsWith('size');
}
function isPosition(name) {
    return name.startsWith('x') || name.startsWith('y') || name.startsWith('position') || name === 'enterDelay' || name === 'enterDuration' || name === 'updateDelay' || name === 'updateDuration' || name === 'exitDelay' || name === 'exitDuration';
}
function isValidScale(scale) {
    if (!scale || !scale.type) return false;
    if (typeof scale.type === 'function') return true;
    const { type, domain, range, interpolator } = scale;
    const isValidDomain = domain && domain.length > 0;
    const isValidRange = range && range.length > 0;
    if ([
        'linear',
        'sqrt',
        'log',
        'time',
        'pow',
        'threshold',
        'quantize',
        'quantile',
        'ordinal',
        'band',
        'point'
    ].includes(type) && isValidDomain && isValidRange) {
        return true;
    }
    if ([
        'sequential'
    ].includes(type) && isValidDomain && (isValidRange || interpolator)) {
        return true;
    }
    if ([
        'constant',
        'identity'
    ].includes(type) && isValidRange) return true;
    return false;
} //# sourceMappingURL=scale.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/types/scale.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ConstantScale": (()=>ConstantScale),
    "ContinuousScale": (()=>ContinuousScale),
    "DiscreteScale": (()=>DiscreteScale),
    "DistributionScale": (()=>DistributionScale)
});
const ContinuousScale = {
    linear: 'linear',
    identity: 'identity',
    log: 'log',
    pow: 'pow',
    sqrt: 'sqrt',
    sequential: 'sequential'
};
const DistributionScale = {
    threshold: 'threshold',
    quantize: 'quantize',
    quantile: 'quantile'
};
const DiscreteScale = {
    ordinal: 'ordinal',
    band: 'band',
    point: 'point'
};
const ConstantScale = {
    constant: 'constant'
}; //# sourceMappingURL=scale.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/component.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "computeComponentSize": (()=>computeComponentSize),
    "computeLabelsBBox": (()=>computeLabelsBBox),
    "computeTitleBBox": (()=>computeTitleBBox),
    "createScale": (()=>createScale),
    "flatComponents": (()=>flatComponents),
    "groupComponents": (()=>groupComponents),
    "inferComponent": (()=>inferComponent),
    "normalizeComponents": (()=>normalizeComponents),
    "renderComponent": (()=>renderComponent),
    "styleOf": (()=>styleOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$format$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-format.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sum.js [app-client] (ecmascript) <export default as sum>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$component$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/component/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/is-equal.js [app-client] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$types$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/types/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$coordinate$2f$radial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/coordinate/radial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$coordinate$2f$polar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/coordinate/polar.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-format/src/defaultLocale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
function inferComponent(scales, partialOptions, library) {
    const { coordinates = [], title } = partialOptions;
    const [, createGuideComponent] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('component', library);
    const displayedScales = scales.filter(({ guide })=>{
        if (guide === null) return false;
        return true;
    });
    const components = [];
    // Sliders and scrollbar component.
    const sliders = inferScrollableComponents(partialOptions, scales, library);
    components.push(...sliders);
    // Title components.
    if (title) {
        const { props } = createGuideComponent('title');
        const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
        const titleOptions = typeof title === 'string' ? {
            title
        } : title;
        components.push(Object.assign({
            type: 'title',
            position: defaultPosition,
            orientation: defaultOrientation,
            order: defaultOrder,
            crossPadding: defaultCrossPadding[0],
            defaultSize
        }, titleOptions));
    }
    // Axis and legends.
    const inferredComponents = inferComponentsType(displayedScales, coordinates);
    inferredComponents.forEach(([type, relativeScales])=>{
        const { props } = createGuideComponent(type);
        const { defaultPosition, defaultPlane = 'xy', defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [
            0,
            0
        ], defaultCrossPadding: DCP = [
            0,
            0
        ] } = props;
        // @todo to be confirm if the scale can be merged.
        // const scale: G2ScaleOptions = Object.assign({}, ...relativeScales);
        const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, ...relativeScales);
        const { guide: guideOptions, field } = scale;
        // A scale may have multiple guides.
        const guides = Array.isArray(guideOptions) ? guideOptions : [
            guideOptions
        ];
        for (const partialGuide of guides){
            const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
            // Skip if position and orientation are not specified.
            // @example the last axis of radar chart
            if (!position && !orientation) continue;
            const isVertical = position === 'left' || position === 'right';
            const defaultPadding = isVertical ? DP[1] : DP[0];
            const defaultCrossPadding = isVertical ? DCP[1] : DCP[0];
            const { size, order = defaultOrder, length = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
            components.push(Object.assign(Object.assign({
                title: field
            }, partialGuide), {
                defaultSize,
                length,
                position,
                plane: defaultPlane,
                orientation,
                padding,
                order,
                crossPadding,
                size,
                type,
                scales: relativeScales
            }));
        }
    });
    return components;
}
function renderComponent(component, coordinate, theme, library, markState) {
    const [useGuideComponent] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('component', library);
    const { scaleInstances: scales, scale, bbox } = component, options = __rest(component, [
        "scaleInstances",
        "scale",
        "bbox"
    ]);
    const value = {
        bbox,
        library
    };
    const render = useGuideComponent(options);
    return render({
        coordinate,
        library,
        markState,
        scales,
        theme,
        value,
        scale
    });
}
function normalizeComponents(components) {
    return components.map((d)=>{
        const component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(d, d.style);
        delete component.style;
        return component;
    });
}
function flatComponents(components) {
    return components.flatMap((d)=>d.type == 'group' ? d.children : d);
}
function groupComponents(components, crossSize) {
    // Group components by key.
    const P = [
        'left',
        'right',
        'bottom',
        'top'
    ];
    const key = ({ type, position, group })=>{
        if (!P.includes(position)) return Symbol('independent');
        if (group === undefined) {
            if (type.startsWith('legend')) return `legend-${position}`;
            return Symbol('independent');
        }
        if (group === 'independent') return Symbol('independent');
        return group;
    };
    const grouped = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groups"])(components, key);
    // Update attributes of group components,
    // and maybe flatten group components without enough room.
    return grouped.flatMap(([, components])=>{
        if (components.length === 1) return components[0];
        // If crossSize defined, group components only when has
        // enough room.
        if (crossSize !== undefined) {
            // Compute total length.
            const DL = components.filter((d)=>d.length !== undefined).map((d)=>d.length);
            const totalLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(DL);
            // If there is no enough room for components,
            // do not group.
            if (totalLength > crossSize) {
                components.forEach((d)=>d.group = Symbol('independent'));
                return components;
            }
            // Group legends and update legend length.
            const emptyLength = crossSize - totalLength;
            const emptyCount = components.length - DL.length;
            const length = emptyLength / emptyCount;
            components.forEach((d)=>{
                if (d.length !== undefined) return;
                d.length = length;
            });
        }
        // Create a group component.
        const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(components, (d)=>d.size);
        const order = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(components, (d)=>d.order);
        const crossPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(components, (d)=>d.crossPadding);
        const position = components[0].position;
        return {
            type: 'group',
            size,
            order,
            position,
            children: components,
            crossPadding
        };
    });
}
function inferLegendComponentType(scales, coordinates) {
    // Filter accepts scales.
    const channels = [
        'shape',
        'size',
        'color',
        'opacity'
    ];
    const isConstantSize = (type, name)=>type === 'constant' && name === 'size';
    const accepts = scales.filter(({ type, name })=>typeof type === 'string' && channels.includes(name) && !isConstantSize(type, name));
    // Group scales by fields.
    const constants = accepts.filter(({ type })=>type === 'constant');
    const nonConstants = accepts.filter(({ type })=>type !== 'constant');
    const groupKey = (d)=>d.field ? d.field : Symbol('independent');
    const fieldScales = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groups"])(nonConstants, groupKey).map(([key, scales])=>[
            key,
            [
                ...scales,
                ...constants
            ]
        ]).filter(([, scales])=>scales.some((scale)=>scale.type !== 'constant'));
    const scalesByField = new Map(fieldScales);
    // Skip empty scales.
    if (scalesByField.size === 0) return [];
    // Infer components.
    const sort = (arr)=>arr.sort(([a], [b])=>a.localeCompare(b));
    const components = Array.from(scalesByField).map(([, scs])=>{
        const combinations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combine"])(scs).sort((a, b)=>b.length - a.length);
        const options = combinations.map((combination)=>({
                combination,
                option: combination.map((scale)=>[
                        scale.name,
                        getScaleType(scale)
                    ])
            }));
        // For category legend.
        for (const { option, combination } of options){
            // If every scale is constant, do not display legend.
            if (option.every((d)=>d[1] === 'constant')) continue;
            if (option.every((d)=>d[1] === 'discrete' || d[1] === 'constant')) {
                return [
                    'legendCategory',
                    combination
                ];
            }
        }
        // For reset legend.
        // @todo Remove this.
        for (const [componentType, accords] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$component$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LEGEND_INFER_STRATEGIES"]){
            for (const { option, combination } of options){
                if (accords.some((accord)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(sort(accord), sort(option)))) {
                    return [
                        componentType,
                        combination
                    ];
                }
            }
        }
        return null;
    }).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
    return components;
}
function getScaleType(scale) {
    const { type } = scale;
    if (typeof type !== 'string') return null;
    if (type in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$types$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContinuousScale"]) return 'continuous';
    if (type in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$types$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DiscreteScale"]) return 'discrete';
    if (type in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$types$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DistributionScale"]) return 'distribution';
    if (type in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$types$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConstantScale"]) return 'constant';
    return null;
}
function inferAxisComponentType(scales, coordinates) {
    return scales.map((scale)=>{
        const { name } = scale;
        // todo wait for gui provide helix axis
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHelix"])(coordinates) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTheta"])(coordinates)) return null;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinates) && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadial"])(coordinates))) return null;
        // infer axis
        if (name.startsWith('x')) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates)) return [
                'axisArc',
                [
                    scale
                ]
            ];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadial"])(coordinates)) return [
                'axisLinear',
                [
                    scale
                ]
            ];
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinates) ? 'axisY' : 'axisX',
                [
                    scale
                ]
            ];
        }
        if (name.startsWith('y')) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates)) return [
                'axisLinear',
                [
                    scale
                ]
            ];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadial"])(coordinates)) return [
                'axisArc',
                [
                    scale
                ]
            ];
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinates) ? 'axisX' : 'axisY',
                [
                    scale
                ]
            ];
        }
        // Only support linear axis for z.
        if (name.startsWith('z')) {
            return [
                'axisZ',
                [
                    scale
                ]
            ];
        }
        if (name.startsWith('position')) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadar"])(coordinates)) return [
                'axisRadar',
                [
                    scale
                ]
            ];
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates)) return [
                'axisY',
                [
                    scale
                ]
            ];
        }
        return null;
    }).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
}
function inferComponentsType(scales, coordinates) {
    const availableScales = scales.filter((scale)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidScale"])(scale));
    return [
        ...inferLegendComponentType(availableScales, coordinates),
        ...inferAxisComponentType(availableScales, coordinates)
    ];
}
function angleOf(coordinates) {
    const polar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordOf"])(coordinates, 'polar');
    if (polar.length) {
        const lastPolar = polar[polar.length - 1];
        const { startAngle, endAngle } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$coordinate$2f$polar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPolarOptions"])(lastPolar);
        return [
            startAngle,
            endAngle
        ];
    }
    const radial = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordOf"])(coordinates, 'radial');
    if (radial.length) {
        const lastRadial = radial[radial.length - 1];
        const { startAngle, endAngle } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$coordinate$2f$radial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRadialOptions"])(lastRadial);
        return [
            startAngle,
            endAngle
        ];
    }
    return [
        -Math.PI / 2,
        Math.PI / 2 * 3
    ];
}
/**
 * match index of position
 */ function matchPosition(name) {
    const match = /position(\d*)/g.exec(name);
    if (!match) return null;
    return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
    // a axis only has one scale
    const { name } = relativeScales[0];
    // todo, in current resolution, the radar chart is implement by parallel + polar coordinate.
    // implementation plan to be confirmed.
    // in current implementation, it must to add the first position encode to it's last.
    // so we won't render the last axis repeatably.
    if (type === 'axisRadar') {
        const positions = scales.filter((scale)=>scale.name.startsWith('position'));
        const index = matchPosition(name);
        if (index === null) return [
            null,
            null
        ];
        // infer radar axis orientation
        const [startAngle, endAngle] = angleOf(coordinates);
        const positionLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadar"])(coordinates) ? positions.length : positions.length - 1;
        const angle = (endAngle - startAngle) / positionLength * index + startAngle;
        return [
            'center',
            angle
        ];
    }
    if (type === 'axisY' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isParallel"])(coordinates)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinates) ? [
            'center',
            'horizontal'
        ] : [
            'center',
            'vertical'
        ];
    }
    // in non-cartesian coordinate systems, infer the arc axis angle
    if (type === 'axisLinear') {
        const [startAngle] = angleOf(coordinates);
        return [
            'center',
            startAngle
        ];
    }
    if (type === 'axisArc') {
        if (ordinalPosition[0] === 'inner') return [
            'inner',
            null
        ];
        return [
            'outer',
            null
        ];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates)) return [
        'center',
        null
    ];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadial"])(coordinates)) return [
        'center',
        null
    ];
    if (type === 'axisX' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReflect"])(coordinates) || type === 'axisX' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReflectY"])(coordinates)) {
        return [
            'top',
            null
        ];
    }
    // if (type === 'axisX') return ['bottom', null];
    return ordinalPosition;
}
// @todo Infer position by coordinates.
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
    const [startAngle] = angleOf(coordinates);
    const ordinalPositionAndOrientation = [
        guide.position || defaultPosition,
        startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
    ];
    if (typeof type === 'string' && type.startsWith('axis')) {
        return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
    }
    if (typeof type === 'string' && type.startsWith('legend') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates)) {
        if (guide.position === 'center') return [
            'center',
            'vertical'
        ];
    }
    // for general component, use default position
    return ordinalPositionAndOrientation;
}
function inferScrollableType(name, type, coordinates = []) {
    if (name === 'x') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinates) ? `${type}Y` : `${type}X`;
    if (name === 'y') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinates) ? `${type}X` : `${type}Y`;
    return null;
}
/**
 * Infer scrollable components, such as slider and scrollbar.
 */ function inferScrollableComponents(partialOptions, scales, library) {
    const [, createGuideComponent] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('component', library);
    const { coordinates } = partialOptions;
    function normalized(type, channelName, scale, options) {
        const componentType = inferScrollableType(channelName, type, coordinates);
        if (!options || !componentType) return;
        const { props } = createGuideComponent(componentType);
        const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
        return Object.assign(Object.assign({
            position: defaultPosition,
            defaultSize,
            order: defaultOrder,
            type: componentType,
            crossPadding
        }, options), {
            scales: [
                scale
            ]
        });
    }
    return scales.filter((d)=>d.slider || d.scrollbar).flatMap((scale)=>{
        const { slider, scrollbar, name: channelName } = scale;
        return [
            normalized('slider', channelName, scale, slider),
            normalized('scrollbar', channelName, scale, scrollbar)
        ];
    }).filter((d)=>!!d);
}
function computeComponentSize(component, crossSize, crossPadding, position, theme, library) {
    // Only compute and update size of components in padding area.
    const { type } = component;
    const paddingAreas = [
        'left',
        'right',
        'bottom',
        'top'
    ];
    if (!paddingAreas.includes(position)) return;
    if (typeof type !== 'string') return;
    const t = type;
    const createCompute = ()=>{
        if (t.startsWith('axis')) return computeAxisSize;
        if (t.startsWith('group')) return computeGroupSize;
        if (t.startsWith('legendContinuous')) return computeContinuousLegendSize;
        if (t === 'legendCategory') return computeCategoryLegendSize;
        if (t.startsWith('slider')) return computeSliderSize;
        if (t === 'title') return computeTitleSize;
        if (t.startsWith('scrollbar')) return computeScrollbarSize;
        return ()=>{};
    };
    return createCompute()(component, crossSize, crossPadding, position, theme, library);
}
function computeGroupSize(component, crossSize, crossPadding, position, theme, library) {
    const { children } = component;
    const maxCrossPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(children, (d)=>d.crossPadding);
    children.forEach((d)=>d.crossPadding = maxCrossPadding);
    children.forEach((child)=>computeComponentSize(child, crossSize, crossPadding, position, theme, library));
    const maxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(children, (d)=>d.size);
    component.size = maxSize;
    children.forEach((d)=>d.size = maxSize);
}
function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library) {
    const { trackSize = 6 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, theme.scrollbar, component);
    component.size = trackSize;
}
function computeTitleSize(component, crossSize, crossPadding, position, theme, library) {
    const _a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, theme.title, component), { title, subtitle, spacing = 0 } = _a, style = __rest(_a, [
        "title",
        "subtitle",
        "spacing"
    ]);
    if (title) {
        const titleStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'title');
        const titleBBox = computeLabelSize(title, titleStyle);
        component.size = titleBBox.height;
    }
    if (subtitle) {
        const subtitleStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'subtitle');
        const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
        component.size += spacing + subtitleBBox.height;
    }
}
function computeSliderSize(component, crossSize, crossPadding, position, theme, library) {
    const styleOf = ()=>{
        const { slider } = theme;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, slider, component);
    };
    const { trackSize, handleIconSize } = styleOf();
    const size = Math.max(trackSize, handleIconSize * 2.4);
    component.size = size;
}
function computeAxisSize(component, crossSize, crossPadding, position, theme, library) {
    var _a, _b;
    // If padding is auto, use hide as the labelTransform by default
    // to avoid overlap between labels.
    component.transform = component.transform || [
        {
            type: 'hide'
        }
    ];
    // Vertical or horizontal.
    const isVertical = position === 'left' || position === 'right';
    // Get styles to be applied.
    const style = styleOf(component, position, theme);
    const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest(style, [
        "tickLength",
        "labelSpacing",
        "titleSpacing",
        "labelAutoRotate"
    ]);
    // Compute Labels.
    const scale = createScale(component, library);
    const labelBBoxes = computeLabelsBBox(rest, scale);
    // Compute dynamic tickLength if it's a function
    let maxTickLength = tickLength;
    if (typeof component.tickLength === 'function') {
        const ticks = ((_a = scale.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale)) || scale.getOptions().domain;
        const tickLengths = ticks.map((d, i, array)=>component.tickLength(d, i, array));
        maxTickLength = Math.max(...tickLengths, 0);
    }
    const paddingTick = maxTickLength + labelSpacing;
    if (labelBBoxes && labelBBoxes.length) {
        const maxLabelWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(labelBBoxes, (d)=>d.width);
        const maxLabelHeight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(labelBBoxes, (d)=>d.height);
        if (isVertical) {
            component.size = maxLabelWidth + paddingTick;
        } else {
            const { tickFilter, labelTransform } = component;
            // If the labels can't be placed horizontally, and labelTransform is unset,
            // rotate 90 deg to display them.
            if (overflowX(scale, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
                component.labelTransform = 'rotate(90)';
                component.size = maxLabelWidth + paddingTick;
            } else {
                component.labelTransform = (_b = component.labelTransform) !== null && _b !== void 0 ? _b : 'rotate(0)';
                component.size = maxLabelHeight + paddingTick;
            }
        }
    } else {
        component.size = maxTickLength;
    }
    // Compute title.
    const titleBBox = computeTitleBBox(rest);
    if (titleBBox) {
        if (isVertical) {
            component.size += titleSpacing + titleBBox.width;
        } else {
            component.size += titleSpacing + titleBBox.height;
        }
    }
}
function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library) {
    // Get styles.
    const styleOf = ()=>{
        const { legendContinuous } = theme;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, legendContinuous, component);
    };
    const _a = styleOf(), { labelSpacing = 0, titleSpacing = 0 } = _a, rest = __rest(_a, [
        "labelSpacing",
        "titleSpacing"
    ]);
    // Vertical or horizontal.
    const isVertical = position === 'left' || position === 'right';
    // Ribbon styles.
    const ribbonStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'ribbon');
    const { size: ribbonSize } = ribbonStyles;
    const handleIconStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'handleIcon');
    const { size: handleIconSize } = handleIconStyles;
    const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
    component.size = mainSize;
    // Compute labels.
    const scale = createScale(component, library);
    const labelBBoxes = computeLabelsBBox(rest, scale);
    if (labelBBoxes) {
        const key = isVertical ? 'width' : 'height';
        const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(labelBBoxes, (d)=>d[key]);
        component.size += size + labelSpacing;
    }
    // Compute title.
    const titleBBox = computeTitleBBox(rest);
    if (titleBBox) {
        if (isVertical) {
            component.size = Math.max(component.size, titleBBox.width);
        } else {
            component.size += titleSpacing + titleBBox.height;
        }
    }
}
function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library) {
    const styleOf = ()=>{
        const { legendCategory } = theme;
        const { title } = component;
        const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [
            title,
            undefined
        ] : [
            undefined,
            title
        ];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
            title: defaultTitle
        }, legendCategory, Object.assign(Object.assign({}, component), {
            title: specifiedTitle
        }));
    };
    const _a = styleOf(), { focus, itemSpacing, focusMarkerSize, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a, rest = __rest(_a, [
        "focus",
        "itemSpacing",
        "focusMarkerSize",
        "itemMarkerSize",
        "titleSpacing",
        "rowPadding",
        "colPadding",
        "maxCols",
        "maxRows"
    ]);
    const { cols, length } = component;
    const getRows = (rows)=>Math.min(rows, maxRows);
    const getCols = (cols)=>Math.min(cols, maxCols);
    // Vertical or horizontal.
    const isVertical = position === 'left' || position === 'right';
    const crossSize = length === undefined ? crossSize0 + (isVertical ? 0 : crossPadding[0] + crossPadding[1]) : length;
    // Compute title.
    const titleBBox = computeTitleBBox(rest);
    const scale = createScale(component, library);
    const labelBBoxes = computeLabelsBBox(rest, scale, 'itemLabel');
    const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
    const widthOf = (w, padding = 0)=>itemMarkerSize + w + itemSpacing[0] + padding + (focus ? focusMarkerSize + itemSpacing[2] : 0);
    // Only support grid layout for vertical area.
    const computeVerticalSize = ()=>{
        let maxSize = -Infinity;
        let pos = 0;
        let cols = 1;
        let rows = 0;
        let maxRows = -Infinity;
        let maxPos = -Infinity;
        const titleHeight = titleBBox ? titleBBox.height : 0;
        const maxHeight = crossSize - titleHeight;
        for (const { width } of labelBBoxes){
            const w = widthOf(width, colPadding);
            maxSize = Math.max(maxSize, w);
            if (pos + height > maxHeight) {
                cols++;
                maxRows = Math.max(maxRows, rows);
                maxPos = Math.max(maxPos, pos);
                rows = 1;
                pos = height;
            } else {
                pos += height;
                rows++;
            }
        }
        if (cols <= 1) {
            maxRows = rows;
            maxPos = pos;
        }
        component.size = maxSize * getCols(cols);
        component.length = maxPos + titleHeight;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(component, {
            cols: getCols(cols),
            gridRow: maxRows
        });
    };
    // Horizontal grid layout.
    const computeHorizontalGrid = ()=>{
        const rows = Math.ceil(labelBBoxes.length / cols);
        const maxWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(labelBBoxes, (d)=>widthOf(d.width)) * cols;
        component.size = height * getRows(rows) - rowPadding;
        component.length = Math.min(maxWidth, crossSize);
    };
    // Horizontal flex layout.
    const computeHorizontalFlex = ()=>{
        let rows = 1;
        let pos = 0;
        let maxPos = -Infinity;
        for (const { width } of labelBBoxes){
            const w = widthOf(width, colPadding);
            if (pos + w > crossSize) {
                maxPos = Math.max(maxPos, pos);
                pos = w;
                rows++;
            } else {
                pos += w;
            }
        }
        if (rows === 1) maxPos = pos;
        component.size = height * getRows(rows) - rowPadding;
        component.length = maxPos;
    };
    if (isVertical) computeVerticalSize();
    else if (typeof cols === 'number') computeHorizontalGrid();
    else computeHorizontalFlex();
    // Compute titles.
    if (titleBBox) {
        if (isVertical) {
            component.size = Math.max(component.size, titleBBox.width);
        } else {
            component.size += titleSpacing + titleBBox.height;
        }
    }
}
function createScale(component, library) {
    const [useScale] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('scale', library);
    // Init scale, the tickCount of axis has higher priority than scale.
    const { scales, tickCount, tickMethod } = component;
    const scaleOptions = scales.find((d)=>d.type !== 'constant' && d.type !== 'identity');
    if (tickCount !== undefined) scaleOptions.tickCount = tickCount;
    if (tickMethod !== undefined) scaleOptions.tickMethod = tickMethod;
    return useScale(scaleOptions);
}
function computeLabelsBBox(component, scale, key = 'label') {
    const { labelFormatter, tickFilter, label = true } = component, style = __rest(component, [
        "labelFormatter",
        "tickFilter",
        "label"
    ]);
    if (!label) return null;
    // Get labels to be rendered.
    const labels = labelsOf(scale, labelFormatter, tickFilter);
    const labelStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, key);
    const labelStyles = labels.map((d, i)=>Object.fromEntries(Object.entries(labelStyle).map(([key, value])=>[
                key,
                typeof value === 'function' ? value(d, i) : value
            ])));
    const labelBBoxes = labels.map((d, i)=>{
        const normalizeStyle = labelStyles[i];
        return computeLabelSize(d, normalizeStyle);
    });
    // Cache boxes to avoid computed twice.
    // @todo GUI use untransformed bbox, so it can't cache if
    // label.style has transform attributes.
    const hasTransform = labelStyles.some((d)=>d.transform);
    if (!hasTransform) {
        const I = labels.map((_, i)=>i);
        component.indexBBox = new Map(I.map((i)=>[
                i,
                [
                    labels[i],
                    labelBBoxes[i]
                ]
            ]));
    }
    return labelBBoxes;
}
function computeTitleBBox(component) {
    const isFalsy = (x)=>x === false || x === null;
    const { title } = component, style = __rest(component, [
        "title"
    ]);
    if (isFalsy(title) || title === undefined) return null;
    const titleStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'title');
    const { direction, transform } = titleStyle;
    const titleText = Array.isArray(title) ? title.join(',') : title;
    if (typeof titleText !== 'string') return null;
    const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), {
        transform: transform || (direction === 'vertical' ? 'rotate(-90)' : '')
    }));
    return titleBBox;
}
function styleOf(axis, position, theme) {
    const { title } = axis;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [
        title,
        undefined
    ] : [
        undefined,
        title
    ];
    const { axis: baseStyle, // @ts-ignore
    [`axis${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["capitalizeFirst"])(position)}`]: positionStyle } = theme;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
        title: defaultTitle
    }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), {
        title: specifiedTitle
    }));
}
function ticksOf(scale, tickFilter) {
    const ticks = scale.getTicks ? scale.getTicks() : scale.getOptions().domain;
    if (!tickFilter) return ticks;
    return ticks.filter(tickFilter);
}
function labelsOf(scale, labelFormatter, tickFilter) {
    const T = ticksOf(scale, tickFilter);
    const ticks = T.map((d)=>typeof d === 'number' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prettyNumber"])(d) : d);
    const formatter = labelFormatter ? typeof labelFormatter === 'string' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(labelFormatter) : labelFormatter : scale.getFormatter ? scale.getFormatter() : (d)=>`${d}`;
    return ticks.map(formatter);
}
function offsetOf(scale, d) {
    if (!scale.getBandWidth) return 0;
    const offset = scale.getBandWidth(d) / 2;
    return offset;
}
function overflowX(scale, labelBBoxes, crossSize, crossPadding, tickFilter) {
    // If actual size bigger than container size, overflow.
    const totalSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(labelBBoxes, (d)=>d.width);
    if (totalSize > crossSize) return true;
    // Clone scale to get visual position for labels.
    const scaleX = scale.clone();
    scaleX.update({
        range: [
            0,
            crossSize
        ]
    });
    const ticks = ticksOf(scale, tickFilter);
    const X = ticks.map((d)=>scaleX.map(d) + offsetOf(scaleX, d));
    const I = ticks.map((_, i)=>i);
    const startX = -crossPadding[0];
    const endX = crossSize + crossPadding[1];
    const extent = (x, bbox)=>{
        const { width } = bbox;
        return [
            x - width / 2,
            x + width / 2
        ];
    };
    // Collision detection.
    for(let i = 0; i < I.length; i++){
        const x = X[i];
        const [x0, x1] = extent(x, labelBBoxes[i]);
        // If a label is out of plot area, overflow.
        if (x0 < startX || x1 > endX) return true;
        const y = X[i + 1];
        if (y) {
            // If two labels intersect, overflow.
            const [y0] = extent(y, labelBBoxes[i + 1]);
            if (x1 > y0) return true;
        }
    }
    return false;
}
function computeLabelSize(d, style) {
    const shape = normalizeLabel(d);
    const { filter } = style, rest = __rest(style, [
        "filter"
    ]);
    shape.attr(Object.assign(Object.assign({}, rest), {
        visibility: 'none'
    }));
    const bbox = shape.getBBox();
    return bbox;
}
function normalizeLabel(d) {
    if (d instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DisplayObject"]) return d;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
        style: {
            text: `${d}`
        }
    });
} //# sourceMappingURL=component.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/layout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "computeLayout": (()=>computeLayout),
    "computeRoughPlotSize": (()=>computeRoughPlotSize),
    "placeComponents": (()=>placeComponents),
    "processAxisZ": (()=>processAxisZ)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$component$2f$esm$2f$util$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/component/esm/util/text.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$head$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__head$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/head.js [app-client] (ecmascript) <export default as head>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/last.js [app-client] (ecmascript) <export default as last>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript) <export default as min>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript) <export default as ascending>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sum.js [app-client] (ecmascript) <export default as sum>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
;
;
;
;
;
;
;
;
;
const DEFAULT_MARGIN = 16;
function processAxisZ(components) {
    const axisX = components.find(({ type })=>type === 'axisX');
    const axisY = components.find(({ type })=>type === 'axisY');
    const axisZ = components.find(({ type })=>type === 'axisZ');
    if (axisX && axisY && axisZ) {
        axisX.plane = 'xy';
        axisY.plane = 'xy';
        axisZ.plane = 'yz';
        axisZ.origin = [
            axisX.bbox.x,
            axisX.bbox.y,
            0
        ];
        axisZ.eulerAngles = [
            0,
            -90,
            0
        ];
        axisZ.bbox.x = axisX.bbox.x;
        axisZ.bbox.y = axisX.bbox.y;
        components.push(Object.assign(Object.assign({}, axisX), {
            plane: 'xz',
            showLabel: false,
            showTitle: false,
            origin: [
                axisX.bbox.x,
                axisX.bbox.y,
                0
            ],
            eulerAngles: [
                -90,
                0,
                0
            ]
        }));
        components.push(Object.assign(Object.assign({}, axisY), {
            plane: 'yz',
            showLabel: false,
            showTitle: false,
            origin: [
                axisY.bbox.x + axisY.bbox.width,
                axisY.bbox.y,
                0
            ],
            eulerAngles: [
                0,
                -90,
                0
            ]
        }));
        components.push(Object.assign(Object.assign({}, axisZ), {
            plane: 'xz',
            actualPosition: 'left',
            showLabel: false,
            showTitle: false,
            eulerAngles: [
                90,
                -90,
                0
            ]
        }));
    }
}
function computeLayout(components, options, theme, library) {
    var _a, _b, _c, _d;
    const { width, height, depth, x = 0, y = 0, z = 0, inset = (_a = theme.inset) !== null && _a !== void 0 ? _a : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library);
    const isDefaultLayoutLeft = marginLeft === DEFAULT_MARGIN && paddingLeft === 'auto';
    const isDefaultLayoutRight = marginRight === DEFAULT_MARGIN && paddingRight === 'auto';
    const isTranspose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(options, 'coordinates', []).some((t)=>t.type === 'transpose');
    const axisX = components.find(({ type })=>type === 'axisX');
    const { size, labelTransform } = axisX || {};
    const MIN_CONTENT_RATIO = 1 / 4;
    const maybeClamp = (viewWidth, paddingLeft, paddingRight, pl0, pr0)=>{
        // Only clamp when has marks.
        const { marks } = options;
        if (marks.length === 0) return [
            pl0,
            pr0
        ];
        // If size of content is enough, skip.
        const contentSize = viewWidth - pl0 - pr0;
        const diff = contentSize - viewWidth * MIN_CONTENT_RATIO;
        if (diff > 0) return [
            pl0,
            pr0
        ];
        // Shrink start and end size equally.
        const shrinkSize = viewWidth * (1 - MIN_CONTENT_RATIO);
        return [
            paddingLeft === 'auto' ? shrinkSize * pl0 / (pl0 + pr0) : pl0,
            paddingRight === 'auto' ? shrinkSize * pr0 / (pl0 + pr0) : pr0
        ];
    };
    const roughPadding = (padding)=>padding === 'auto' ? 20 : padding !== null && padding !== void 0 ? padding : 20;
    const rpt = roughPadding(paddingTop);
    const rpb = roughPadding(paddingBottom);
    // Compute paddingLeft and paddingRight first to get innerWidth.
    const horizontalPadding = computePadding(components, height - rpt - rpb, [
        rpt + marginTop,
        rpb + marginBottom
    ], [
        'left',
        'right'
    ], options, theme, library);
    const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
    const viewWidth = width - marginLeft - marginRight;
    let [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
    let iw = viewWidth - pl - pr;
    // Compute paddingBottom and paddingTop based on innerWidth.
    const verticalPadding = computePadding(components, iw, [
        pl + marginLeft,
        pr + marginRight
    ], [
        'bottom',
        'top'
    ], options, theme, library);
    const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
    const viewHeight = height - marginBottom - marginTop;
    const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
    const ih = viewHeight - pb - pt;
    // Adjust paddingLeft and paddingRight for axisX when they are 'auto' and not specified by user.
    if (size && !isTranspose && !labelTransform) {
        const { fontSize = 12, fontFamily = 'sans-serif', scales = [] } = axisX;
        const domain = (_d = (_c = scales === null || scales === void 0 ? void 0 : scales[0]) === null || _c === void 0 ? void 0 : _c.domain) !== null && _d !== void 0 ? _d : [];
        if (!domain.length) return;
        const adjustSide = (side, labelText, margin, padding)=>{
            const labelWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$component$2f$esm$2f$util$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["measureTextWidth"])(labelText, {
                fontSize,
                fontFamily
            });
            const diff = labelWidth / 2 - margin - padding;
            if (diff > 0) {
                iw -= diff;
                if (side === 'left') pl += labelWidth / 2 - margin;
                else pr += labelWidth / 2 - margin;
            }
        };
        if (isDefaultLayoutLeft) {
            adjustSide('left', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$head$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__head$3e$__["head"])(domain), marginLeft, pl);
        }
        if (isDefaultLayoutRight) {
            adjustSide('right', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__["last"])(domain), marginRight, pr);
        }
    }
    return {
        width,
        height,
        depth,
        insetLeft,
        insetTop,
        insetBottom,
        insetRight,
        innerWidth: iw,
        innerHeight: ih,
        paddingLeft: pl,
        paddingRight: pr,
        paddingTop: pt,
        paddingBottom: pb,
        marginLeft,
        marginBottom,
        marginTop,
        marginRight,
        x,
        y,
        z
    };
}
function computeRoughPlotSize(options) {
    const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
    // @todo Add this padding to theme.
    // 30 is default size for padding, which defined in runtime.
    const maybeAuto = (padding)=>padding === 'auto' ? 20 : padding;
    const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
    const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
    return {
        width: finalWidth,
        height: finalHeight
    };
}
function computeInset(components, options, theme, library) {
    const { coordinates } = options;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinates) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadial"])(coordinates)) {
        return options;
    }
    // Filter axis.
    const axes = components.filter((d)=>typeof d.type === 'string' && d.type.startsWith('axis'));
    if (axes.length === 0) return options;
    const styles = axes.map((component)=>{
        const key = component.type === 'axisArc' ? 'arc' : 'linear';
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["styleOf"])(component, key, theme);
    });
    // Compute max labelSpacing.
    const maxLabelSpacing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(styles, (d)=>{
        var _a;
        return (_a = d.labelSpacing) !== null && _a !== void 0 ? _a : 0;
    });
    // Compute labelBBoxes.
    const labelBBoxes = axes.flatMap((component, i)=>{
        const style = styles[i];
        const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createScale"])(component, library);
        const labels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeLabelsBBox"])(style, scale);
        return labels;
    }).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
    const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(labelBBoxes, (d)=>d.height) + maxLabelSpacing;
    // Compute titles.
    const titleBBoxes = axes.flatMap((_, i)=>{
        const style = styles[i];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeTitleBBox"])(style);
    }).filter((d)=>d !== null);
    const titleSize = titleBBoxes.length === 0 ? 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(titleBBoxes, (d)=>d.height);
    // Update inset.
    const { inset = size, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
    return Object.assign(Object.assign({}, options), {
        insetLeft,
        insetBottom,
        insetTop,
        insetRight
    });
}
/**
 * @todo Support percentage size(e.g. 50%)
 */ function computePadding(components, crossSize, crossPadding, positions, options, theme, library) {
    const positionComponents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(components, (d)=>d.position);
    const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
    const layout = {
        paddingBottom,
        paddingLeft,
        paddingTop,
        paddingRight
    };
    for (const position of positions){
        const key = `padding${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["capitalizeFirst"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["camelCase"])(position))}`;
        const components = positionComponents.get(position) || [];
        const value = layout[key];
        const defaultSizeOf = (d)=>{
            if (d.size === undefined) d.size = d.defaultSize;
        };
        const sizeOf = (d)=>{
            if (d.type === 'group') {
                d.children.forEach(defaultSizeOf);
                d.size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(d.children, (d)=>d.size);
            } else {
                d.size = d.defaultSize;
            }
        };
        const autoSizeOf = (d)=>{
            if (d.size) return;
            if (value !== 'auto') sizeOf(d);
            else {
                // Compute component size dynamically.
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeComponentSize"])(d, crossSize, crossPadding, position, theme, library);
                defaultSizeOf(d);
            }
        };
        const maybeHide = (d)=>{
            if (!d.type.startsWith('axis')) return;
            if (d.labelAutoHide === undefined) d.labelAutoHide = true;
        };
        const isHorizontal = position === 'bottom' || position === 'top';
        // !!!Note
        // Mute axis component padding.
        // The first axis do not has padding.
        const minOrder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__["min"])(components, (d)=>d.order);
        const axes = components.filter((d)=>d.type.startsWith('axis') && d.order == minOrder);
        if (axes.length) axes[0].crossPadding = 0;
        // Specified padding.
        if (typeof value === 'number') {
            components.forEach(defaultSizeOf);
            components.forEach(maybeHide);
        } else {
            // Compute padding dynamically.
            if (components.length === 0) {
                layout[key] = 0;
            } else {
                const size = isHorizontal ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
                const grouped = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupComponents"])(components, size);
                grouped.forEach(autoSizeOf);
                const totalSize = grouped.reduce((sum, { size, crossPadding = 12 })=>sum + size + crossPadding, 0);
                layout[key] = totalSize;
            }
        }
    }
    return layout;
}
function placeComponents(components, coordinate, layout) {
    // Group components by plane & position.
    const positionComponents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(components, (d)=>`${d.plane || 'xy'}-${d.position}`);
    const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
    const planes = {
        xy: createSection({
            width,
            height,
            paddingLeft,
            paddingRight,
            paddingTop,
            paddingBottom,
            marginLeft,
            marginTop,
            marginBottom,
            marginRight,
            innerHeight,
            innerWidth,
            insetBottom,
            insetLeft,
            insetRight,
            insetTop
        }),
        yz: createSection({
            width: depth,
            height: height,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            marginLeft: 0,
            marginTop: 0,
            marginBottom: 0,
            marginRight: 0,
            innerWidth: depth,
            innerHeight: height,
            insetBottom: 0,
            insetLeft: 0,
            insetRight: 0,
            insetTop: 0
        }),
        xz: createSection({
            width,
            height: depth,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            marginLeft: 0,
            marginTop: 0,
            marginBottom: 0,
            marginRight: 0,
            innerWidth: width,
            innerHeight: depth,
            insetBottom: 0,
            insetLeft: 0,
            insetRight: 0,
            insetTop: 0
        })
    };
    for (const [key, components] of positionComponents.entries()){
        const [plane, position] = key.split('-');
        const area = planes[plane][position];
        /**
         * @description non-entity components: axis in the center, inner, outer, component in the center
         * @description entity components: other components
         * @description no volume components take up no extra space
         */ const [nonEntityComponents, entityComponents] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["divide"])(components, (component)=>{
            if (typeof component.type !== 'string') return false;
            if (position === 'center') return true;
            if (component.type.startsWith('axis') && [
                'inner',
                'outer'
            ].includes(position)) {
                return true;
            }
            return false;
        });
        if (nonEntityComponents.length) {
            placeNonEntityComponents(nonEntityComponents, coordinate, area, position);
        }
        if (entityComponents.length) {
            placePaddingArea(components, coordinate, area);
        }
    }
}
function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
    const pl = paddingLeft + marginLeft;
    const pt = paddingTop + marginTop;
    const pr = paddingRight + marginRight;
    const pb = paddingBottom + marginBottom;
    const plotWidth = width - marginLeft - marginRight;
    const centerSection = [
        pl + insetLeft,
        pt + insetTop,
        innerWidth - insetLeft - insetRight,
        innerHeight - insetTop - insetBottom,
        'center',
        null,
        null
    ];
    const xySection = {
        top: [
            pl,
            0,
            innerWidth,
            pt,
            'vertical',
            true,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"],
            marginLeft,
            plotWidth
        ],
        right: [
            width - pr,
            pt,
            pr,
            innerHeight,
            'horizontal',
            false,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]
        ],
        bottom: [
            pl,
            height - pb,
            innerWidth,
            pb,
            'vertical',
            false,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"],
            marginLeft,
            plotWidth
        ],
        left: [
            0,
            pt,
            pl,
            innerHeight,
            'horizontal',
            true,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]
        ],
        'top-left': [
            pl,
            0,
            innerWidth,
            pt,
            'vertical',
            true,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]
        ],
        'top-right': [
            pl,
            0,
            innerWidth,
            pt,
            'vertical',
            true,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]
        ],
        'bottom-left': [
            pl,
            height - pb,
            innerWidth,
            pb,
            'vertical',
            false,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]
        ],
        'bottom-right': [
            pl,
            height - pb,
            innerWidth,
            pb,
            'vertical',
            false,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ascending$3e$__["ascending"]
        ],
        center: centerSection,
        inner: centerSection,
        outer: centerSection
    };
    return xySection;
}
function placeNonEntityComponents(components, coordinate, area, position) {
    const [axisComponents, nonAxisComponents] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["divide"])(components, (component)=>{
        if (typeof component.type === 'string' && component.type.startsWith('axis')) {
            return true;
        }
        return false;
    });
    placeNonEntityAxis(axisComponents, coordinate, area, position);
    // in current stage, only legend component which located in the center can be placed
    placeCenter(nonAxisComponents, coordinate, area);
}
function placeNonEntityAxis(components, coordinate, area, position) {
    if (position === 'center') {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRadar"])(coordinate)) {
            placeAxisRadar(components, coordinate, area, position);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate)) {
            placeArcLinear(components, coordinate, area);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isParallel"])(coordinate)) {
            placeAxisParallel(components, coordinate, area, components[0].orientation);
        }
    } else if (position === 'inner') {
        placeAxisArcInner(components, coordinate, area);
    } else if (position === 'outer') {
        placeAxisArcOuter(components, coordinate, area);
    }
}
function placeAxisArcInner(components, coordinate, area) {
    const [x, y, , height] = area;
    const [cx, cy] = coordinate.getCenter();
    const [innerRadius] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiusOf"])(coordinate);
    const r = height / 2;
    const size = innerRadius * r;
    const x0 = cx - size;
    const y0 = cy - size;
    for(let i = 0; i < components.length; i++){
        const component = components[i];
        component.bbox = {
            x: x + x0,
            y: y + y0,
            width: size * 2,
            height: size * 2
        };
    }
}
function placeAxisArcOuter(components, coordinate, area) {
    const [x, y, width, height] = area;
    for (const component of components){
        component.bbox = {
            x,
            y,
            width,
            height
        };
    }
}
/**
 * @example arcX, arcY, axisLinear with angle
 */ function placeArcLinear(components, coordinate, area) {
    const [x, y, width, height] = area;
    for (const component of components){
        component.bbox = {
            x: x,
            y,
            width,
            height
        };
    }
}
function placeAxisParallel(components, coordinate, area, orientation) {
    if (orientation === 'horizontal') {
        placeAxisParallelHorizontal(components, coordinate, area);
    } else if (orientation === 'vertical') {
        placeAxisParallelVertical(components, coordinate, area);
    }
}
function placeAxisParallelVertical(components, coordinate, area) {
    const [x, y, , height] = area;
    // Create a high dimension vector and map to a list of two-dimension points.
    // [0, 0, 0] -> [x0, 0, x1, 0, x2, 0]
    const vector = new Array(components.length).fill(0);
    const points = coordinate.map(vector);
    // Extract x of each points.
    // [x0, 0, x1, 0, x2, 0] -> [x0, x1, x2]
    const X = points.filter((_, i)=>i % 2 === 0).map((d)=>d + x);
    // Place each axis by coordinate in parallel coordinate.
    for(let i = 0; i < components.length; i++){
        const component = components[i];
        const x = X[i];
        const width = X[i + 1] - x;
        component.bbox = {
            x,
            y,
            width,
            height
        };
    }
}
function placeAxisParallelHorizontal(components, coordinate, area) {
    const [x, y, width] = area;
    // Create a high dimension vector and map to a list of two-dimension points.
    // [0, 0, 0] -> [height, y0, height, y1, height, y2]
    const vector = new Array(components.length).fill(0);
    const points = coordinate.map(vector);
    // Extract y of each points.
    // [x0, 0, x1, 0, x2, 0] -> [x0, x1, x2]
    const Y = points.filter((_, i)=>i % 2 === 1).map((d)=>d + y);
    // Place each axis by coordinate in parallel coordinate.
    for(let i = 0; i < components.length; i++){
        const component = components[i];
        const y = Y[i];
        const height = Y[i + 1] - y;
        component.bbox = {
            x,
            y,
            width,
            height
        };
    }
}
function placeAxisRadar(components, coordinate, area, position) {
    const [x, y, width, height] = area;
    for (const component of components){
        component.bbox = {
            x,
            y,
            width,
            height
        };
        component.radar = {
            index: components.indexOf(component),
            count: components.length
        };
    }
}
function placePaddingArea(components, coordinate, area) {
    const [x, y, width, height, direction, reverse, comparator, minX, totalSize] = area;
    const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction === 'vertical' ? [
        'y',
        y,
        'x',
        x,
        'height',
        height,
        'width',
        width
    ] : [
        'x',
        x,
        'y',
        y,
        'width',
        width,
        'height',
        height
    ];
    // Sort components by order.
    // The smaller the order, the closer to center.
    components.sort((a, b)=>comparator === null || comparator === void 0 ? void 0 : comparator(a.order, b.order));
    const isLarge = (type)=>type === 'title' || type === 'group' || type.startsWith('legend');
    const crossSizeOf = (type, small, bigger)=>{
        if (bigger === undefined) return small;
        if (isLarge(type)) return bigger;
        return small;
    };
    const crossStartOf = (type, x, minX)=>{
        if (minX === undefined) return x;
        if (isLarge(type)) return minX;
        return x;
    };
    const startValue = reverse ? mainStartValue + mainSizeValue : mainStartValue;
    for(let i = 0, start = startValue; i < components.length; i++){
        const component = components[i];
        const { crossPadding = 0, type } = component;
        const { size } = component;
        component.bbox = {
            [mainStartKey]: reverse ? start - size - crossPadding : start + crossPadding,
            [crossStartKey]: crossStartOf(type, crossStartValue, minX),
            [mainSizeKey]: size,
            [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
        };
        start += (size + crossPadding) * (reverse ? -1 : 1);
    }
    // Place group components.
    const groupComponents = components.filter((d)=>d.type === 'group');
    for (const group of groupComponents){
        const { bbox, children } = group;
        const size = bbox[crossSizeKey];
        const step = size / children.length;
        const justifyContent = children.reduce((j, child)=>{
            var _a;
            const j0 = (_a = child.layout) === null || _a === void 0 ? void 0 : _a.justifyContent;
            return j0 ? j0 : j;
        }, 'flex-start');
        const L = children.map((d, i)=>{
            const { length = step, padding = 0 } = d;
            return length + (i === children.length - 1 ? 0 : padding);
        });
        const totalLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(L);
        const diff = size - totalLength;
        const offset = justifyContent === 'flex-start' ? 0 : justifyContent === 'center' ? diff / 2 : diff;
        for(let i = 0, start = bbox[crossStartKey] + offset; i < children.length; i++){
            const component = children[i];
            const { padding = 0 } = component;
            const interval = i === children.length - 1 ? 0 : padding;
            component.bbox = {
                [mainSizeKey]: bbox[mainSizeKey],
                [mainStartKey]: bbox[mainStartKey],
                [crossStartKey]: start,
                [crossSizeKey]: L[i] - interval
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(component, {
                layout: {
                    justifyContent
                }
            });
            start += L[i];
        }
    }
}
/**
 * @example legend in the center of radial or polar system
 */ function placeCenter(components, coordinate, area) {
    if (components.length === 0) return;
    const [x, y, width, height] = area;
    const [innerRadius] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiusOf"])(coordinate);
    const r = height / 2 * innerRadius / Math.sqrt(2);
    const cx = x + width / 2;
    const cy = y + height / 2;
    for(let i = 0; i < components.length; i++){
        const component = components[i];
        component.bbox = {
            x: cx - r,
            y: cy - r,
            width: r * 2,
            height: r * 2
        };
    }
} //# sourceMappingURL=layout.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/transform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CALLBACK_ITEM_SYMBOL": (()=>CALLBACK_ITEM_SYMBOL),
    "addGuideToScale": (()=>addGuideToScale),
    "appendMarkScaleKey": (()=>appendMarkScaleKey),
    "applyDataTransform": (()=>applyDataTransform),
    "applyDefaults": (()=>applyDefaults),
    "extractColumns": (()=>extractColumns),
    "extractTooltip": (()=>extractTooltip),
    "flatEncode": (()=>flatEncode),
    "inferChannelsType": (()=>inferChannelsType),
    "maybeArrayField": (()=>maybeArrayField),
    "maybeNonAnimate": (()=>maybeNonAnimate),
    "maybeVisualChannel": (()=>maybeVisualChannel),
    "normalizeTooltip": (()=>normalizeTooltip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$format$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-format.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$mark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/mark.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$mark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/mark.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-format/src/defaultLocale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isNumber$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/is-number.js [app-client] (ecmascript) <export default as isNumber>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
const CALLBACK_ITEM_SYMBOL = Symbol('CALLBACK_ITEM');
function applyDefaults(I, mark, context) {
    const { encode = {}, scale = {}, transform = [] } = mark, rest = __rest(mark, [
        "encode",
        "scale",
        "transform"
    ]);
    return [
        I,
        Object.assign(Object.assign({}, rest), {
            encode,
            scale,
            transform
        })
    ];
}
function applyDataTransform(I, mark, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const { data } = mark;
        const [useData] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('data', library);
        const descriptor = normalizedDataSource(data);
        const { transform: T = [] } = descriptor, connector = __rest(descriptor, [
            "transform"
        ]);
        const transform = [
            connector,
            ...T
        ];
        const transformFunctions = transform.map((t)=>useData(t, context));
        const transformedData = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeAsync"])(transformFunctions)(data);
        // Maintain the consistency of shape between input and output data.
        // If the shape of raw data is like { value: any }
        // and the returned transformedData is Object,
        // returns the wrapped data: { value: transformedData },
        // otherwise returns the processed tabular data.
        const newData = data && !Array.isArray(data) && !Array.isArray(transformedData) ? {
            value: transformedData
        } : transformedData;
        return [
            Array.isArray(transformedData) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["indexOf"])(transformedData) : [],
            Object.assign(Object.assign({}, mark), {
                data: newData
            })
        ];
    });
}
function flatEncode(I, mark, context) {
    const { encode } = mark;
    if (!encode) return [
        I,
        mark
    ];
    const flattenEncode = {};
    for (const [key, value] of Object.entries(encode)){
        if (Array.isArray(value)) {
            for(let i = 0; i < value.length; i++){
                const name = `${key}${i === 0 ? '' : i}`;
                flattenEncode[name] = value[i];
            }
        } else {
            flattenEncode[key] = value;
        }
    }
    return [
        I,
        Object.assign(Object.assign({}, mark), {
            encode: flattenEncode
        })
    ];
}
function inferChannelsType(I, mark, context) {
    const { encode, data } = mark;
    if (!encode) return [
        I,
        mark
    ];
    const typedEncode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(encode, (channel)=>{
        if (isTypedChannel(channel)) return channel;
        const type = inferChannelType(data, channel);
        return {
            type,
            value: channel
        };
    });
    return [
        I,
        Object.assign(Object.assign({}, mark), {
            encode: typedEncode
        })
    ];
}
function maybeVisualChannel(I, mark, context) {
    const { encode } = mark;
    if (!encode) return [
        I,
        mark
    ];
    const newEncode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(encode, (channel, name)=>{
        const { type } = channel;
        if (type !== 'constant' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPosition"])(name)) return channel;
        return Object.assign(Object.assign({}, channel), {
            constant: true
        });
    });
    return [
        I,
        Object.assign(Object.assign({}, mark), {
            encode: newEncode
        })
    ];
}
function extractColumns(I, mark, context) {
    const { encode, data } = mark;
    if (!encode) return [
        I,
        mark
    ];
    const { library } = context;
    const columnOf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$mark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColumnOf"])(library);
    const valuedEncode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(encode, (channel)=>columnOf(data, channel));
    return [
        I,
        Object.assign(Object.assign({}, mark), {
            encode: valuedEncode
        })
    ];
}
function normalizeTooltip(I, mark, context) {
    const { tooltip = {} } = mark;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnset"])(tooltip)) return [
        I,
        mark
    ];
    if (Array.isArray(tooltip)) {
        return [
            I,
            Object.assign(Object.assign({}, mark), {
                tooltip: {
                    items: tooltip
                }
            })
        ];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStrictObject"])(tooltip) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$mark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFullTooltip"])(tooltip)) {
        return [
            I,
            Object.assign(Object.assign({}, mark), {
                tooltip
            })
        ];
    }
    return [
        I,
        Object.assign(Object.assign({}, mark), {
            tooltip: {
                items: [
                    tooltip
                ]
            }
        })
    ];
}
function extractTooltip(I, mark, context) {
    const { data, encode, tooltip = {} } = mark;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnset"])(tooltip)) return [
        I,
        mark
    ];
    const valueOf = (item)=>{
        if (!item) return item;
        if (typeof item === 'string') {
            return I.map((i)=>({
                    name: item,
                    value: data[i][item]
                }));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStrictObject"])(item)) {
            const { field, channel, color, name = field, valueFormatter = (d)=>d } = item;
            // Support d3-format.
            const normalizedValueFormatter = typeof valueFormatter === 'string' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(valueFormatter) : valueFormatter;
            // Field name.
            const definedChannel = channel && encode[channel];
            const channelField = definedChannel && encode[channel].field;
            const name1 = name || channelField || channel;
            const values = [];
            for (const i of I){
                const value1 = field ? data[i][field] : definedChannel ? encode[channel].value[i] : null;
                values[i] = {
                    name: name1,
                    color,
                    value: normalizedValueFormatter(value1)
                };
            }
            return values;
        }
        if (typeof item === 'function') {
            const values = [];
            for (const i of I){
                const v = item(data[i], i, data, encode);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStrictObject"])(v)) values[i] = Object.assign(Object.assign({}, v), {
                    [CALLBACK_ITEM_SYMBOL]: true
                });
                else values[i] = {
                    value: v
                };
            }
            return values;
        }
        return item;
    };
    const { title, items = [] } = tooltip, rest = __rest(tooltip, [
        "title",
        "items"
    ]);
    const newTooltip = Object.assign({
        title: valueOf(title),
        items: Array.isArray(items) ? items.map(valueOf) : []
    }, rest);
    return [
        I,
        Object.assign(Object.assign({}, mark), {
            tooltip: newTooltip
        })
    ];
}
function maybeArrayField(I, mark, context) {
    const { encode } = mark, rest = __rest(mark, [
        "encode"
    ]);
    if (!encode) return [
        I,
        mark
    ];
    const columns = Object.entries(encode);
    const arrayColumns = columns.filter(([, channel])=>{
        const { value: V } = channel;
        return Array.isArray(V[0]);
    }).flatMap(([key, V])=>{
        const columns = [
            [
                key,
                new Array(I.length).fill(undefined)
            ]
        ];
        const { value: rows } = V, rest = __rest(V, [
            "value"
        ]);
        for(let i = 0; i < rows.length; i++){
            const row = rows[i];
            if (Array.isArray(row)) {
                for(let j = 0; j < row.length; j++){
                    const column = columns[j] || [
                        `${key}${j}`,
                        new Array(I).fill(undefined)
                    ];
                    column[1][i] = row[j];
                    columns[j] = column;
                }
            }
        }
        return columns.map(([key, value])=>[
                key,
                Object.assign({
                    type: 'column',
                    value
                }, rest)
            ]);
    });
    const newEncode = Object.fromEntries([
        ...columns,
        ...arrayColumns
    ]);
    return [
        I,
        Object.assign(Object.assign({}, rest), {
            encode: newEncode
        })
    ];
}
function addGuideToScale(I, mark, context) {
    const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark;
    const normalize = (guide, channel)=>{
        if (typeof guide === 'boolean') return guide ? {} : null;
        const eachGuide = guide[channel];
        return eachGuide === undefined || eachGuide ? eachGuide : null;
    };
    const axisChannels = typeof axis === 'object' ? Array.from(new Set([
        'x',
        'y',
        'z',
        ...Object.keys(axis)
    ])) : [
        'x',
        'y',
        'z'
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(mark, {
        scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel)=>{
            const scrollbarOptions = normalize(scrollbar, channel);
            return [
                channel,
                Object.assign({
                    guide: normalize(axis, channel),
                    slider: normalize(slider, channel),
                    scrollbar: scrollbarOptions
                }, scrollbarOptions && {
                    ratio: scrollbarOptions.ratio === undefined ? 0.5 : scrollbarOptions.ratio
                })
            ];
        }))), {
            color: {
                guide: normalize(legend, 'color')
            },
            size: {
                guide: normalize(legend, 'size')
            },
            shape: {
                guide: normalize(legend, 'shape')
            },
            // fixme: opacity is conflict with DisplayObject.opacity
            // to be confirm.
            opacity: {
                guide: normalize(legend, 'opacity')
            }
        })
    });
    return [
        I,
        mark
    ];
}
function maybeNonAnimate(I, mark, context) {
    const { animate } = mark;
    if (animate || animate === undefined) return [
        I,
        mark
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(mark, {
        animate: {
            enter: {
                type: null
            },
            exit: {
                type: null
            },
            update: {
                type: null
            }
        }
    });
    return [
        I,
        mark
    ];
}
function appendMarkScaleKey(I, mark, context) {
    var _a, _b;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(mark, {
        scale: {
            series: Object.assign({
                key: `DEFAULT_${mark.type}_SERIES_KEY`
            }, (_b = (_a = mark === null || mark === void 0 ? void 0 : mark.scale) === null || _a === void 0 ? void 0 : _a.series) !== null && _b !== void 0 ? _b : {})
        }
    });
    return [
        I,
        mark
    ];
}
function isTypedChannel(channel) {
    if (typeof channel !== 'object' || channel instanceof Date || channel === null) {
        return false;
    }
    const { type } = channel;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(type);
}
function inferChannelType(data, channel) {
    if (typeof channel === 'function') return 'transform';
    if (typeof channel === 'string' && isField(data, channel)) return 'field';
    return 'constant';
}
function isField(data, value) {
    if (!Array.isArray(data)) return false;
    return data.some((d)=>d[value] !== undefined);
}
function normalizedDataSource(data) {
    // LiquidGauge need number data.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isNumber$3e$__["isNumber"])(data)) return {
        type: 'inline',
        value: data
    };
    // Return null as a placeholder.
    if (!data) return {
        type: 'inline',
        value: null
    };
    if (Array.isArray(data)) return {
        type: 'inline',
        value: data
    };
    const { type = 'inline' } = data, rest = __rest(data, [
        "type"
    ]);
    return Object.assign(Object.assign({}, rest), {
        type
    });
} //# sourceMappingURL=transform.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/mark.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createColumnOf": (()=>createColumnOf),
    "initializeMark": (()=>initializeMark)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/transform.js [app-client] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
function initializeMark(partialMark, partialProps, context) {
    return __awaiter(this, void 0, void 0, function*() {
        // Apply transform to mark to derive indices, data, encode, etc,.
        const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
        const { encode, scale, data, tooltip, key: markerKey } = transformedMark;
        // Skip mark with non-tabular data. Do not skip empty
        // data, they are useful for facet to display axes.
        if (Array.isArray(data) === false) {
            return null;
        }
        // Group non-independent channels with same prefix, such as x1, x2 => x.
        // For independent channels, dot not group them, such as position1, position2.
        const { channels: channelDescriptors } = partialProps;
        const nameChannels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rollups"])(Object.entries(encode).filter(([, value])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(value)), (values)=>values.map(([key, options])=>Object.assign({
                    name: key
                }, options)), ([key])=>{
            var _a;
            const prefix = (_a = /([^\d]+)\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
            const descriptor = channelDescriptors.find((d)=>d.name === prefix);
            if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent) return key;
            return prefix;
        });
        // Check required channels and initialize scale options for each channel.
        const channels = channelDescriptors.filter((descriptor)=>{
            const { name, required } = descriptor;
            if (nameChannels.find(([d])=>d === name)) return true;
            if (required) throw new Error(`Missing encoding for channel: ${name}.`);
            return false;
        }).flatMap((descriptor)=>{
            const { name, scale: scaleType, scaleKey, range, quantitative, ordinal } = descriptor;
            const valuesArray = nameChannels.filter(([channel])=>channel.startsWith(name));
            return valuesArray.map(([channel, values], i)=>{
                const visual = values.some((d)=>d.visual);
                const constant = values.some((d)=>d.constant);
                const _a = scale[channel] || {}, { independent = false, // Use channel name as default scale key.
                key = scaleKey || channel, // Visual channel use identity scale.
                type = constant ? 'constant' : visual ? 'identity' : scaleType } = _a, scaleOptions = __rest(_a, [
                    "independent",
                    "key",
                    "type"
                ]);
                // For constant scale, infer range from data.
                const isConstant = type === 'constant';
                const finalRange = isConstant ? undefined : range;
                return {
                    name: channel,
                    values,
                    // Generate a unique key for independent channel,
                    // which will not group with any other channels.
                    scaleKey: independent || isConstant ? Symbol('independent') : key,
                    scale: Object.assign(Object.assign({
                        type,
                        markerKey,
                        range: finalRange
                    }, scaleOptions), {
                        quantitative,
                        ordinal
                    })
                };
            });
        });
        return [
            transformedMark,
            Object.assign(Object.assign({}, partialProps), {
                index: I,
                channels,
                tooltip
            })
        ];
    });
}
function createColumnOf(library) {
    const [useEncode] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('encode', library);
    return (data, encode)=>{
        if (encode === undefined) return null;
        if (data === undefined) return null;
        return Object.assign(Object.assign({}, encode), {
            type: 'column',
            value: useEncode(encode)(data),
            field: fieldOf(encode)
        });
    };
}
function applyMarkTransform(mark, props, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const [useTransform] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('transform', library);
        const { preInference = [], postInference = [] } = props;
        const { transform = [] } = mark;
        const transforms = [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyDefaults"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyDataTransform"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flatEncode"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inferChannelsType"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeVisualChannel"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractColumns"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeArrayField"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeNonAnimate"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addGuideToScale"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeTooltip"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["appendMarkScaleKey"],
            ...preInference.map(useTransform),
            ...transform.map(useTransform),
            ...postInference.map(useTransform),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractTooltip"]
        ];
        let index = [];
        let transformedMark = mark;
        for (const t of transforms){
            [index, transformedMark] = yield t(index, transformedMark, context);
        }
        return [
            index,
            transformedMark
        ];
    });
}
function fieldOf(encode) {
    const { type, value } = encode;
    if (type === 'field' && typeof value === 'string') return value;
    return null;
} //# sourceMappingURL=mark.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/plot.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applyStyle": (()=>applyStyle),
    "plot": (()=>plot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$format$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-format.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/library.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isArray$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/is-array.js [app-client] (ecmascript) <export default as isArray>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$mark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/mark.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/upper-first.js [app-client] (ecmascript) <export default as upperFirst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-format/src/defaultLocale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function plot(options, selection, context) {
    var _a;
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const [useComposition] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('composition', library);
        const [useInteraction] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('interaction', library);
        // Some helper functions.
        const marks = new Set(Object.keys(library).map((d)=>{
            var _a;
            return (_a = /mark\.(.*)/.exec(d)) === null || _a === void 0 ? void 0 : _a[1];
        }).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]));
        const staticMarks = new Set(Object.keys(library).map((d)=>{
            var _a;
            return (_a = /component\.(.*)/.exec(d)) === null || _a === void 0 ? void 0 : _a[1];
        }).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]));
        const typeOf = (node)=>{
            const { type } = node;
            if (typeof type === 'function') {
                // @ts-ignore
                const { props = {} } = type;
                const { composite = true } = props;
                if (composite) return 'mark';
            }
            if (typeof type !== 'string') return type;
            if (marks.has(type) || staticMarks.has(type)) return 'mark';
            return type;
        };
        const isMark = (node)=>typeOf(node) === 'mark';
        const isStandardView = (node)=>typeOf(node) === 'standardView';
        const isStaticMark = (node)=>{
            const { type } = node;
            if (typeof type !== 'string') return false;
            if (staticMarks.has(type)) return true;
            return false;
        };
        const transform = (node)=>{
            if (isStandardView(node)) return [
                node
            ];
            const type = typeOf(node);
            const composition = useComposition({
                type,
                static: isStaticMark(node)
            });
            return composition(node);
        };
        // Some temporary variables help parse the view tree.
        const views = [];
        const viewNode = new Map();
        const nodeState = new Map();
        const discovered = [
            options
        ];
        const nodeGenerators = [];
        while(discovered.length){
            const node = discovered.shift();
            if (isStandardView(node)) {
                // Initialize view to get data to be visualized. If the marks
                // of the view have already been initialized (facet view),
                // initialize the view based on the initialized mark states,
                // otherwise initialize it from beginning.
                const state = nodeState.get(node);
                const [view, children] = state ? initializeState(state, node, library) : yield initializeView(node, context);
                viewNode.set(view, node);
                views.push(view);
                // Transform children, they will be transformed into
                // standardView if they are mark or view node.
                const transformedNodes = children.flatMap(transform).map((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordinate2Transform"])(d, library));
                discovered.push(...transformedNodes);
                // Only StandardView can be treated as facet and it
                // should sync position scales among facets normally.
                if (transformedNodes.every(isStandardView)) {
                    const states = yield Promise.all(transformedNodes.map((d)=>initializeMarks(d, context)));
                    // Note!!!
                    // This will mutate scales for marks.
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["syncFacetsScales"])(states);
                    for(let i = 0; i < transformedNodes.length; i++){
                        const nodeT = transformedNodes[i];
                        const state = states[i];
                        nodeState.set(nodeT, state);
                    }
                }
            } else {
                // Apply transform to get data in advance for non-mark composition
                // node, which makes sure that composition node can preprocess the
                // data to produce more nodes based on it.
                const n = isMark(node) ? node : yield applyTransform(node, context);
                const N = transform(n);
                if (Array.isArray(N)) discovered.push(...N);
                else if (typeof N === 'function') nodeGenerators.push(N());
            }
        }
        context.emitter.emit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].BEFORE_PAINT);
        // Plot chart.
        const enterContainer = new Map();
        const updateContainer = new Map();
        const transitions = [];
        selection.selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VIEW_CLASS_NAME"])).data(views, (d)=>d.key).join((enter)=>enter.append('g').attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VIEW_CLASS_NAME"]).attr('id', (view)=>view.key).call(applyTranslate).each(function(view, i, element) {
                plotView(view, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(element), transitions, context);
                enterContainer.set(view, element);
            }), (update)=>update.call(applyTranslate).each(function(view, i, element) {
                plotView(view, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(element), transitions, context);
                updateContainer.set(view, element);
            }), (exit)=>exit.each(function(d, i, element) {
                // Remove existed interactions.
                const interactions = element['nameInteraction'].values();
                for (const interaction of interactions){
                    interaction.destroy();
                }
            }).remove());
        // Apply interactions.
        const viewInstanceof = (viewContainer, updateInteractions, oldStore)=>{
            return Array.from(viewContainer.entries()).map(([view, container])=>{
                // Index state by component or interaction name,
                // such as legend, scrollbar, brushFilter.
                // Each state transform options to another options.
                const store = oldStore || new Map();
                const setState = (key, reducer = (x)=>x)=>store.set(key, reducer);
                const options = viewNode.get(view);
                const update = createUpdateView((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(container), options, context);
                const target = {
                    view,
                    container,
                    options,
                    setState,
                    update: (from, updateTypes)=>__awaiter(this, void 0, void 0, function*() {
                            // Apply all state functions to get new options.
                            const reducer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"])(Array.from(store.values()));
                            const newOptions = reducer(options);
                            return yield update(newOptions, from, ()=>{
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isArray$3e$__["isArray"])(updateTypes)) {
                                    updateInteractions(viewContainer, updateTypes, store);
                                }
                            });
                        })
                };
                context.externals.update = target.update;
                context.externals.setState = setState;
                return target;
            });
        };
        const updateInteractions = (container = updateContainer, updateType, oldStore)=>{
            var _a;
            // Interactions for update views.
            const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
            for (const target of updateViewInstances){
                const { options, container } = target;
                const nameInteraction = container['nameInteraction'];
                let typeOptions = inferInteraction(options);
                if (updateType) {
                    typeOptions = typeOptions.filter((v)=>updateType.includes(v[0]));
                }
                for (const typeOption of typeOptions){
                    const [type, option] = typeOption;
                    // Remove interaction for existed views.
                    const prevInteraction = nameInteraction.get(type);
                    if (prevInteraction) (_a = prevInteraction.destroy) === null || _a === void 0 ? void 0 : _a.call(prevInteraction);
                    // Apply new interaction.
                    if (option) {
                        const interaction = useThemeInteraction(target.view, type, option, useInteraction);
                        const destroy = interaction(target, updateViewInstances, context.emitter);
                        nameInteraction.set(type, {
                            destroy
                        });
                    }
                }
            }
        };
        // Interactions for enter views.
        const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
        for (const target of enterViewInstances){
            const { options } = target;
            // A Map index interaction by interaction name.
            const nameInteraction = new Map();
            target.container['nameInteraction'] = nameInteraction;
            // Apply interactions.
            for (const typeOption of inferInteraction(options)){
                const [type, option] = typeOption;
                if (option) {
                    const interaction = useThemeInteraction(target.view, type, option, useInteraction);
                    const destroy = interaction(target, enterViewInstances, context.emitter);
                    nameInteraction.set(type, {
                        destroy
                    });
                }
            }
        }
        updateInteractions();
        // Author animations.
        const { width, height } = options;
        const keyframes = [];
        for (const nodeGenerator of nodeGenerators){
            // Delay the rendering of animation keyframe. Different animation
            // created by different nodeGenerator will play in the same time.
            // eslint-disable-next-line no-async-promise-executor
            const keyframe = new Promise((resolve)=>__awaiter(this, void 0, void 0, function*() {
                    for (const node of nodeGenerator){
                        const sizedNode = Object.assign({
                            width,
                            height
                        }, node);
                        yield plot(sizedNode, selection, context);
                    }
                    resolve();
                }));
            keyframes.push(keyframe);
        }
        context.views = views;
        // Clear and update animation.
        (_a = context.animations) === null || _a === void 0 ? void 0 : _a.forEach((animation)=>animation === null || animation === void 0 ? void 0 : animation.cancel());
        context.animations = transitions;
        context.emitter.emit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].AFTER_PAINT);
        // Note!!!
        // The returned promise will never resolved if one of nodeGenerator
        // never stop to yield node, which may created by a keyframe composition
        // with iteration count set to infinite.
        const finished = transitions.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]).map(cancel).map((d)=>d.finished);
        return Promise.all([
            ...finished,
            ...keyframes
        ]);
    });
}
function applyTranslate(selection) {
    selection.style('transform', (d)=>`translate(${d.layout.x}, ${d.layout.y})`);
}
function definedInteraction(library) {
    const [, createInteraction] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('interaction', library);
    return (d)=>{
        const [name, options] = d;
        try {
            return [
                name,
                createInteraction(name)
            ];
        } catch (_a) {
            return [
                name,
                options.type
            ];
        }
    };
}
function createUpdateView(selection, options, context) {
    const { library } = context;
    const createDefinedInteraction = definedInteraction(library);
    const filter = (d)=>d[1] && d[1].props && d[1].props.reapplyWhenUpdate;
    const interactions = inferInteraction(options);
    const updates = interactions.map(createDefinedInteraction).filter(filter).map((d)=>d[0]);
    return (newOptions, source, callback)=>__awaiter(this, void 0, void 0, function*() {
            const transitions = [];
            const [newView, newChildren] = yield initializeView(newOptions, context);
            plotView(newView, selection, transitions, context);
            // Update interaction need to reapply when update.
            for (const name of updates.filter((d)=>d !== source)){
                updateInteraction(name, selection, newOptions, newView, context);
            }
            for (const child of newChildren){
                plot(child, selection, context);
            }
            callback();
            return {
                options: newOptions,
                view: newView
            };
        });
}
function updateInteraction(name, selection, options, view, context) {
    var _a;
    const { library } = context;
    const [useInteraction] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('interaction', library);
    // Instances for interaction.
    const container = selection.node();
    const nameInteraction = container['nameInteraction'];
    const interactionOptions = inferInteraction(options).find(([d])=>d === name);
    // Destroy older interaction.
    const interaction = nameInteraction.get(name);
    if (!interaction) return;
    (_a = interaction.destroy) === null || _a === void 0 ? void 0 : _a.call(interaction);
    if (!interactionOptions[1]) return;
    // Apply new interaction.
    const applyInteraction = useThemeInteraction(view, name, interactionOptions[1], useInteraction);
    const target = {
        options,
        view,
        container: selection.node(),
        update: (options)=>Promise.resolve(options)
    };
    const destroy = applyInteraction(target, [], context.emitter);
    nameInteraction.set(name, {
        destroy
    });
}
function initializeView(options, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const flattenOptions = yield transformMarks(options, context);
        const mergedOptions = bubbleOptions(flattenOptions);
        // @todo Remove this.
        // !!! NOTE: Mute original view options.
        // Update interaction and coordinate for this view.
        options.interaction = mergedOptions.interaction;
        options.coordinate = mergedOptions.coordinate;
        // @ts-ignore
        options.marks = [
            ...mergedOptions.marks,
            ...mergedOptions.components
        ];
        const transformedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordinate2Transform"])(mergedOptions, library);
        const state = yield initializeMarks(transformedOptions, context);
        return initializeState(state, transformedOptions, library);
    });
}
function bubbleOptions(options) {
    const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest(options, [
        "coordinate",
        "interaction",
        "style",
        "marks"
    ]);
    const markCoordinates = marks.map((d)=>d.coordinate || {});
    const markInteractions = marks.map((d)=>d.interaction || {});
    const markViewStyles = marks.map((d)=>d.viewStyle || {});
    const newCoordinate = [
        ...markCoordinates,
        viewCoordinate
    ].reduceRight((prev, cur)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(prev, cur), {});
    const newInteraction = [
        viewInteraction,
        ...markInteractions
    ].reduce((prev, cur)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(prev, cur), {});
    const newStyle = [
        ...markViewStyles,
        viewStyle
    ].reduce((prev, cur)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(prev, cur), {});
    return Object.assign(Object.assign({}, rest), {
        marks,
        coordinate: newCoordinate,
        interaction: newInteraction,
        style: newStyle
    });
}
function transformMarks(options, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const [useMark, createMark] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('mark', library);
        const staticMarks = new Set(Object.keys(library).map((d)=>{
            var _a;
            return (_a = /component\.(.*)/.exec(d)) === null || _a === void 0 ? void 0 : _a[1];
        }).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]));
        const { marks } = options;
        const flattenMarks = [];
        const components = [];
        const discovered = [
            ...marks
        ];
        const { width, height } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeRoughPlotSize"])(options);
        const markOptions = {
            options,
            width,
            height
        };
        // Pre order traversal.
        while(discovered.length){
            const [node] = discovered.splice(0, 1);
            // Apply data transform to get data.
            const mark = yield applyTransform(node, context);
            const { type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])('G2Mark type is required.'), key } = mark;
            // For components.
            if (staticMarks.has(type)) components.push(mark);
            else {
                const { props = {} } = createMark(type);
                const { composite = true } = props;
                if (!composite) flattenMarks.push(mark);
                else {
                    // Unwrap data from { value: data } to data,
                    // then the composite mark can process the normalized data.
                    const { data } = mark;
                    const newMark = Object.assign(Object.assign({}, mark), {
                        data: data ? Array.isArray(data) ? data : data.value : data
                    });
                    // Convert composite mark to marks.
                    const marks = yield useMark(newMark, markOptions);
                    const M = Array.isArray(marks) ? marks : [
                        marks
                    ];
                    discovered.unshift(...M.map((d, i)=>Object.assign(Object.assign({}, d), {
                            key: `${key}-${i}`
                        })));
                }
            }
        }
        return Object.assign(Object.assign({}, options), {
            marks: flattenMarks,
            components
        });
    });
}
function initializeMarks(options, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const [useTheme] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('theme', library);
        const [, createMark] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('mark', library);
        const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
        const theme = useTheme(inferTheme(partialTheme));
        const markState = new Map();
        // Initialize channels for marks.
        for (const markOptions of partialMarks){
            const { type } = markOptions;
            const { props = {} } = createMark(type);
            const markAndState = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$mark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeMark"])(markOptions, props, context);
            if (markAndState) {
                const [initializedMark, state] = markAndState;
                markState.set(initializedMark, state);
            }
        }
        // Group channels by scale key, each group has scale.
        const scaleChannels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(Array.from(markState.values()).flatMap((d)=>d.channels), ({ scaleKey })=>scaleKey);
        // Infer scale for each channel groups.
        for (const channels of scaleChannels.values()){
            // Merge scale options for these channels.
            const scaleOptions = channels.reduce((total, { scale })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(total, scale), {});
            const { scaleKey } = channels[0];
            // Use the fields of the first channel as the title.
            const { values: FV } = channels[0];
            const fields = Array.from(new Set(FV.map((d)=>d.field).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])));
            const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
                guide: {
                    title: fields.length === 0 ? undefined : fields
                },
                field: fields[0]
            }, scaleOptions);
            // Use the name of the first channel as the scale name.
            const { name } = channels[0];
            const values = channels.flatMap(({ values })=>values.map((d)=>d.value));
            const scale = Object.assign(Object.assign({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inferScale"])(name, values, options, coordinates, theme, library)), {
                uid: Symbol('scale'),
                key: scaleKey
            });
            channels.forEach((channel)=>channel.scale = scale);
        }
        return markState;
    });
}
function useThemeInteraction(view, type, option, useInteraction) {
    const theme = view.theme;
    const defaults = typeof type === 'string' ? theme[type] || {} : {};
    const interaction = useInteraction((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(defaults, Object.assign({
        type
    }, option)));
    return interaction;
}
function initializeState(markState, options, library) {
    var _a;
    const [useMark] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('mark', library);
    const [useTheme] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('theme', library);
    const [useLabelTransform] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('labelTransform', library);
    const { key, frame = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    // Infer components and compute layout.
    const states = Array.from(markState.values());
    const scales = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectScales"])(states, options);
    const components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeComponents"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inferComponent"])(inferComponentScales(Array.from(scales), states, markState), options, library));
    const layout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeLayout"])(components, options, theme, library);
    const coordinate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoordinate"])(layout, options, library);
    const framedStyle = frame ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
        mainLineWidth: 1,
        mainStroke: '#000'
    }, style) : style;
    // Place components and mutate their bbox.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["placeComponents"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupComponents"])(components), coordinate, layout);
    // AxisZ need a copy of axisX and axisY to show grids in X-Z & Y-Z planes.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["processAxisZ"])(components);
    // Index scale instance by uid.
    const uidScale = new Map(Array.from(markState.values()).flatMap((state)=>{
        const { channels } = state;
        return channels.map(({ scale })=>[
                scale.uid,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationScale"])(scale, library)
            ]);
    }));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupTransform"])(markState, uidScale);
    // Scale from marks and components.
    const scaleInstance = {};
    // Initialize scale from components.
    for (const component of components){
        const { scales: scaleDescriptors = [] } = component;
        const scales = [];
        for (const descriptor of scaleDescriptors){
            const { name, uid } = descriptor;
            const scale = (_a = uidScale.get(uid)) !== null && _a !== void 0 ? _a : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRelationScale"])(descriptor, library);
            scales.push(scale);
            // Delivery the scale of axisX to the AxisY,
            // in order to calculate the angle of axisY component when rendering radar chart.
            if (name === 'y') {
                scale.update(Object.assign(Object.assign({}, scale.getOptions()), {
                    xScale: scaleInstance.x
                }));
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assignScale"])(scaleInstance, {
                [name]: scale
            });
        }
        component.scaleInstances = scales;
    }
    // Calc data to be rendered for each mark.
    // @todo More readable APIs for Container which stays
    // the same style with JS standard and lodash APIs.
    // @todo More proper way to index scale for different marks.
    const children = [];
    const dataMap = new Map();
    for (const [mark, state] of markState.entries()){
        const { // scale,
        // Callback to create children options based on this mark.
        children: createChildren, // The total count of data (both show and hide)for this facet.
        // This is for unit visualization to sync data domain.
        dataDomain, modifier, key: markKey, data } = mark;
        dataMap.set(markKey, data);
        const { index, channels, tooltip } = state;
        const scale = Object.fromEntries(channels.map(({ name, scale })=>[
                name,
                scale
            ]));
        // Transform abstract value to visual value by scales.
        const markScaleInstance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(scale, ({ uid })=>uidScale.get(uid));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assignScale"])(scaleInstance, markScaleInstance);
        const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyScale"])(channels, markScaleInstance);
        // Calc points and transformation for each data,
        // and then transform visual value to visual data.
        const calcPoints = useMark(mark);
        const [I, P, S] = filterValid(calcPoints(index, markScaleInstance, value, coordinate));
        const count = dataDomain || I.length;
        const T = modifier ? modifier(P, count, layout) : [];
        const titleOf = (i)=>{
            var _a, _b;
            return (_b = (_a = tooltip.title) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.value;
        };
        const itemsOf = (i)=>tooltip.items.map((V)=>V[i]);
        const visualData = I.map((d, i)=>{
            const datum = Object.assign({
                points: P[i],
                transform: T[i],
                index: d,
                markKey,
                viewKey: key,
                data: data[d]
            }, tooltip && {
                title: titleOf(d),
                items: itemsOf(d)
            });
            for (const [k, V] of Object.entries(value)){
                datum[k] = V[d];
                if (S) datum[`series${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(k)}`] = S[i].map((i)=>V[i]);
            }
            if (S) datum['seriesIndex'] = S[i];
            if (S && tooltip) {
                datum['seriesItems'] = S[i].map((si)=>itemsOf(si));
                datum['seriesTitle'] = S[i].map((si)=>titleOf(si));
            }
            return datum;
        });
        state.data = visualData;
        state.index = I;
        // Create children options by children callback,
        // and then propagate data to each child.
        const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
        children.push(...markChildren || []);
    }
    const view = {
        layout,
        theme,
        coordinate,
        markState,
        key,
        clip,
        scale: scaleInstance,
        style: framedStyle,
        components,
        data: dataMap,
        options: options,
        labelTransform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"])(labelTransform.map(useLabelTransform))
    };
    return [
        view,
        children
    ];
}
function plotView(view, selection, transitions, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { library } = context;
        const { components, theme, layout, markState, coordinate, key, style, clip, scale } = view;
        // Render background for the different areas.
        const { x, y, width, height } = layout, rest = __rest(layout, [
            "x",
            "y",
            "width",
            "height"
        ]);
        const areaKeys = [
            'view',
            'plot',
            'main',
            'content'
        ];
        const I = areaKeys.map((_, i)=>i);
        const sizeKeys = [
            'a',
            'margin',
            'padding',
            'inset'
        ];
        const areaStyles = areaKeys.map((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeSubObject"])(Object.assign({}, theme.view, style), d));
        const areaSizes = sizeKeys.map((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, d));
        const styleArea = (selection)=>selection.style('x', (i)=>areaLayouts[i].x).style('y', (i)=>areaLayouts[i].y).style('width', (i)=>areaLayouts[i].width).style('height', (i)=>areaLayouts[i].height).each(function(i, d, element) {
                applyStyle((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(element), areaStyles[i]);
            });
        let px = 0;
        let py = 0;
        let pw = width;
        let ph = height;
        const areaLayouts = I.map((i)=>{
            const size = areaSizes[i];
            const { left = 0, top = 0, bottom = 0, right = 0 } = size;
            px += left;
            py += top;
            pw -= left + right;
            ph -= top + bottom;
            return {
                x: px,
                y: py,
                width: pw,
                height: ph
            };
        });
        selection.selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AREA_CLASS_NAME"])).data(// Only render area with defined style.
        I.filter((i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(areaStyles[i])), (i)=>areaKeys[i]).join((enter)=>enter.append('rect').attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AREA_CLASS_NAME"]).style('zIndex', -2).call(styleArea), (update)=>update.call(styleArea), (exit)=>exit.remove());
        const animationExtent = computeAnimationExtent(markState);
        const componentAnimateOptions = animationExtent ? {
            duration: animationExtent[1]
        } : false;
        // Render components.
        // @todo renderComponent return ctor and options.
        // Key for each type of component.
        // Index them grouped by position.
        for (const [, C] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groups"])(components, (d)=>`${d.type}-${d.position}`)){
            C.forEach((d, i)=>d.index = i);
        }
        const componentsTransitions = selection.selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPONENT_CLASS_NAME"])).data(components, (d)=>`${d.type}-${d.position}-${d.index}`).join((enter)=>enter.append('g').style('zIndex', ({ zIndex })=>zIndex || -1).attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPONENT_CLASS_NAME"]).append((options)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderComponent"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
                    animate: componentAnimateOptions,
                    scale
                }, options), coordinate, theme, library, markState)), (update)=>update.transition(function(options, i, element) {
                const { preserve = false } = options;
                if (preserve) return;
                const newComponent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderComponent"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
                    animate: componentAnimateOptions,
                    scale
                }, options), coordinate, theme, library, markState);
                const { attributes } = newComponent;
                const [node] = element.childNodes;
                return node.update(attributes, false);
            })).transitions();
        transitions.push(...componentsTransitions.flat().filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]));
        // Main layer is for showing the main visual representation such as marks. There
        // may be multiple main layers for a view, each main layer correspond to one of marks.
        // @todo Test DOM structure.
        const T = selection.selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"])).data([
            layout
        ], ()=>key).join((enter)=>enter// Make this layer interactive, such as click and mousemove events.
            .append('rect').style('zIndex', 0).style('fill', 'transparent').attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"]).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update)=>update.call(updateLayers, Array.from(markState.keys())).call(updateBBox)// .call((selection) => {
            //   return animationExtent
            //     ? animateBBox(selection, animationExtent)
            //     : updateBBox(selection);
            // })
            .call(applyClip, clip)).transitions();
        transitions.push(...T.flat());
        // Render marks with corresponding data.
        for (const [mark, state] of markState.entries()){
            const { data } = state;
            const { key, class: cls, type } = mark;
            const viewNode = selection.select(`#${key}`);
            const shapeFunction = createMarkShapeFunction(mark, state, view, context);
            const enterFunction = createEnterFunction(mark, state, view, library);
            const updateFunction = createUpdateFunction(mark, state, view, library);
            const exitFunction = createExitFunction(mark, state, view, library);
            const facetElements = selectFacetElements(selection, viewNode, cls, 'element');
            const T = viewNode.selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"])).selectFacetAll(facetElements).data(data, (d)=>d.key, (d)=>d.groupKey).join((enter)=>enter.append(shapeFunction)// Note!!! Only one className can be set.
                // Using attribute as alternative for other classNames.
                .attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]).attr('markType', type).transition(function(data, i, element) {
                    return enterFunction(data, [
                        element
                    ]);
                }), (update)=>update.call((selection)=>{
                    const parent = selection.parent();
                    const origin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                        "plotView.T.useMemo[origin]": (node)=>{
                            const [x, y] = node.getBounds().min;
                            return [
                                x,
                                y
                            ];
                        }
                    }["plotView.T.useMemo[origin]"]);
                    selection.transition(function(data, index, element) {
                        maybeFacetElement(element, parent, origin);
                        const node = shapeFunction(data, index);
                        const animation = updateFunction(data, [
                            element
                        ], [
                            node
                        ]);
                        if (animation === null || animation === void 0 ? void 0 : animation.length) return animation;
                        if (element.nodeName === node.nodeName && node.nodeName !== 'g') {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyAttributes"])(element, node);
                        } else {
                            element.parentNode.replaceChild(node, element);
                            node.className = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"];
                            // @ts-ignore
                            node.markType = type;
                            // @ts-ignore
                            node.__data__ = element.__data__;
                        }
                        return animation;
                    }).each(function(d, i, element) {
                        if (element.__removed__) {
                            element.__removed__ = false;
                        }
                    }).attr('markType', type).attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]);
                }), (exit)=>{
                return exit.each(function(d, i, element) {
                    element.__removed__ = true;
                }).transition(function(data, i, element) {
                    return exitFunction(data, [
                        element
                    ]);
                }).remove();
            }, (merge)=>merge// Append elements to be merged.
                .append(shapeFunction).attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]).attr('markType', type).transition(function(data, i, element) {
                    // Remove merged elements after animation finishing.
                    const { __fromElements__: fromElements } = element;
                    const transition = updateFunction(data, fromElements, [
                        element
                    ]);
                    const exit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Selection"](fromElements, null, element.parentNode);
                    exit.transition(transition).remove();
                    return transition;
                }), (split)=>split.transition(function(data, i, element) {
                    // Append splitted shapes.
                    const enter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Selection"]([], element.__toData__, element.parentNode);
                    const toElements = enter.append(shapeFunction).attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]).attr('markType', type).nodes();
                    return updateFunction(data, [
                        element
                    ], toElements);
                })// Remove elements to be splitted after animation finishing.
                .remove()).transitions();
            transitions.push(...T.flat());
        }
        // Plot label for this view.
        plotLabel(view, selection, transitions, library, context);
        plotBreak(view, selection, library, context);
    });
}
/**
 * Auto hide labels be specify label layout.
 */ function plotLabel(view, selection, transitions, library, context) {
    const [useLabelTransform] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('labelTransform', library);
    const { markState, labelTransform } = view;
    const labelLayer = selection.select(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_LAYER_CLASS_NAME"])).node();
    // A Map index shapeFunction by label.
    const labelShapeFunction = new Map();
    // A Map index options by label.
    const labelDescriptor = new Map();
    // Get all labels for this view.
    const labels = Array.from(markState.entries()).flatMap(([mark, state])=>{
        const { labels: labelOptions = [], key } = mark;
        const shapeFunction = createLabelShapeFunction(mark, state, view, library, context);
        const elements = selection.select(`#${key}`).selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"])).nodes()// Only select the valid element.
        .filter((n)=>!n.__removed__);
        return labelOptions.flatMap((labelOption, i)=>{
            const { transform = [] } = labelOption, options = __rest(labelOption, [
                "transform"
            ]);
            return elements.flatMap((e)=>{
                const L = getLabels(options, i, e);
                L.forEach((l)=>{
                    labelShapeFunction.set(l, (data)=>shapeFunction(Object.assign(Object.assign({}, data), {
                            element: e
                        })));
                    labelDescriptor.set(l, labelOption);
                });
                return L;
            });
        });
    });
    // Render all labels.
    const labelShapes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(labelLayer).selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_CLASS_NAME"])).data(labels, (d)=>d.key).join((enter)=>enter.append((d)=>labelShapeFunction.get(d)(d)).attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_CLASS_NAME"]), (update)=>update.each(function(d, i, element) {
            // @todo Handle Label with different type.
            const shapeFunction = labelShapeFunction.get(d);
            const node = shapeFunction(d);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyAttributes"])(element, node);
        }), (exit)=>exit.remove()).nodes();
    // Apply group-level transforms.
    const labelGroups = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(labelShapes, (d)=>labelDescriptor.get(d.__data__));
    const { coordinate, layout } = view;
    const labelTransformContext = {
        canvas: context.canvas,
        coordinate,
        layout
    };
    for (const [label, shapes] of labelGroups){
        const { transform = [] } = label;
        const transformFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"])(transform.map(useLabelTransform));
        transformFunction(shapes, labelTransformContext);
    }
    // Apply view-level transform.
    if (labelTransform) {
        labelTransform(labelShapes, labelTransformContext);
    }
}
function getLabels(label, labelIndex, element) {
    const { seriesIndex: SI, seriesKey, points, key, index } = element.__data__;
    const bounds = getLocalBounds(element);
    if (!SI) {
        return [
            Object.assign(Object.assign({}, label), {
                key: `${key}-${labelIndex}`,
                bounds,
                index,
                points,
                dependentElement: element
            })
        ];
    }
    const selector = normalizeLabelSelector(label);
    const F = SI.map((index, i)=>Object.assign(Object.assign({}, label), {
            key: `${seriesKey[i]}-${labelIndex}`,
            bounds: [
                points[i]
            ],
            index,
            points,
            dependentElement: element
        }));
    return selector ? selector(F) : F;
}
/**
 * Plot break shapes.
 */ function plotBreak(view, selection, library, context) {
    const scale = view.scale;
    const breaks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(scale, 'y.options.breaks', []);
    const { document } = context.canvas;
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BREAK_CLASS_NAME"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BREAK_GROUP_CLASS_NAME"]
    ].forEach((d)=>{
        document.getElementsByClassName(d).forEach((e)=>{
            e.remove();
        });
    });
    if (!breaks.length) {
        return;
    }
    const breakLayer = selection.select(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"])).node();
    const [useShape] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('shape', library);
    const breaksShapeFunction = new Map();
    breaks.forEach((breakConfig, index)=>{
        breaksShapeFunction.set(breakConfig, useShape({
            type: 'break'
        }, {
            view,
            selection,
            context
        }));
    });
    // Render all breaks.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(breakLayer).selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BREAK_CLASS_NAME"])).data(breaks, (d)=>d.key).join((enter)=>enter.append((d, index)=>breaksShapeFunction.get(d)(d, index)).attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BREAK_CLASS_NAME"]), (update)=>update.each(function(d, i, element) {
            const shapeFunction = breaksShapeFunction.get(d);
            const node = shapeFunction(d, i);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyAttributes"])(element, node);
        }), (exit)=>exit.remove()).nodes();
}
function filterValid([I, P, S]) {
    if (S) return [
        I,
        P,
        S
    ];
    const definedIndex = [];
    const definedPoints = [];
    for(let i = 0; i < I.length; i++){
        const d = I[i];
        const p = P[i];
        if (p.every(([x, y])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(x) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(y))) {
            definedIndex.push(d);
            definedPoints.push(p);
        }
    }
    return [
        definedIndex,
        definedPoints
    ];
}
function normalizeLabelSelector(label) {
    const { selector } = label;
    if (!selector) return null;
    if (typeof selector === 'function') return selector;
    if (selector === 'first') return (I)=>[
            I[0]
        ];
    if (selector === 'last') return (I)=>[
            I[I.length - 1]
        ];
    throw new Error(`Unknown selector: ${selector}`);
}
/**
 * Avoid getting error bounds caused by element animations.
 * @todo Remove this temporary handle method, if runtime supports
 * correct process: drawElement, do label layout and then do
 * transitions together.
 */ function getLocalBounds(element) {
    const cloneElement = element.cloneNode(true);
    const animations = element.getAnimations();
    cloneElement.style.visibility = 'hidden';
    animations.forEach((animation)=>{
        const keyframes = animation.effect.getKeyframes();
        cloneElement.attr(keyframes[keyframes.length - 1]);
    });
    element.parentNode.appendChild(cloneElement);
    const bounds = cloneElement.getLocalBounds();
    cloneElement.destroy();
    const { min, max } = bounds;
    return [
        min,
        max
    ];
}
function createLabelShapeFunction(mark, state, view, library, context) {
    const [useShape] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('shape', library);
    const { data: abstractData, encode } = mark;
    const { data: visualData, defaultLabelShape } = state;
    const point2d = visualData.map((d)=>d.points);
    const channel = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(encode, (d)=>d.value);
    // Assemble Context.
    const { theme, coordinate } = view;
    const shapeContext = Object.assign(Object.assign({}, context), {
        document: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["documentOf"])(context),
        theme,
        coordinate
    });
    return (options)=>{
        // Computed values from data and styles.
        const { index, points } = options;
        const datum = abstractData[index];
        const { formatter = (d)=>`${d}`, transform, style: abstractStyle, render, selector, element } = options, abstractOptions = __rest(options, [
            "formatter",
            "transform",
            "style",
            "render",
            "selector",
            "element"
        ]);
        const visualOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d)=>valueOf(d, datum, index, abstractData, {
                channel,
                element
            }));
        const { shape = defaultLabelShape, text } = visualOptions, style = __rest(visualOptions, [
            "shape",
            "text"
        ]);
        const f = typeof formatter === 'string' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$format$2f$src$2f$defaultLocale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(formatter) : formatter;
        const value = Object.assign(Object.assign({}, style), {
            text: f(text, datum, index, abstractData),
            datum
        });
        // Params for create shape.
        const shapeOptions = Object.assign({
            type: `label.${shape}`,
            render
        }, style);
        const shapeFunction = useShape(shapeOptions, shapeContext);
        const defaults = getDefaultsStyle(theme, 'label', shape, 'label');
        return shapeFunction(points, value, defaults, point2d);
    };
}
function valueOf(value, datum, i, data, options) {
    if (typeof value === 'function') return value(datum, i, data, options);
    if (typeof value !== 'string') return value;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStrictObject"])(datum) && datum[value] !== undefined) return datum[value];
    return value;
}
/**
 * Compute max duration for this frame.
 */ function computeAnimationExtent(markState) {
    let maxDuration = -Infinity;
    let minDelay = Infinity;
    for (const [mark, state] of markState){
        const { animate = {} } = mark;
        const { data } = state;
        const { enter = {}, update = {}, exit = {} } = animate;
        const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update;
        const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
        const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
        for (const d of data){
            const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d;
            if (updateType === undefined || updateType) {
                maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
                minDelay = Math.min(minDelay, updateDelay);
            }
            if (exitType === undefined || exitType) {
                maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
                minDelay = Math.min(minDelay, exitDelay);
            }
            if (enterType === undefined || enterType) {
                maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
                minDelay = Math.min(minDelay, enterDelay);
            }
        }
    }
    if (maxDuration === -Infinity) return null;
    return [
        minDelay,
        maxDuration - minDelay
    ];
}
function selectFacetElements(selection, current, facetClassName, elementClassName) {
    const group = selection.node().parentElement;
    if (!group || typeof group.findAll !== 'function') return [];
    return group.findAll((node)=>node.style.facet !== undefined && node.style.facet === facetClassName && node !== current.node()).flatMap((node)=>node.getElementsByClassName(elementClassName));
}
/**
 * Update the parent of element and apply transform to make it
 * stay in original position.
 */ function maybeFacetElement(element, parent, originOf) {
    if (!element.__facet__) return;
    // element -> g#main -> rect#plot
    const prePlot = element.parentNode.parentNode;
    // g#main -> rect#plot
    const newPlot = parent.parentNode;
    const [px, py] = originOf(prePlot);
    const [x, y] = originOf(newPlot);
    const translate = `translate(${px - x}, ${py - y})`;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["appendTransform"])(element, translate);
    parent.append(element);
}
function createMarkShapeFunction(mark, state, view, context) {
    const { library } = context;
    const [useShape] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('shape', library);
    const { data: abstractData, encode } = mark;
    const { defaultShape, data, shape: shapeLibrary } = state;
    const channel = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(encode, (d)=>d.value);
    const point2d = data.map((d)=>d.points);
    const { theme, coordinate } = view;
    const { type: markType, style = {} } = mark;
    const shapeContext = Object.assign(Object.assign({}, context), {
        document: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["documentOf"])(context),
        coordinate,
        theme
    });
    return (data)=>{
        const { shape: styleShape = defaultShape } = style;
        const { shape = styleShape, points, seriesIndex, index: i } = data, v = __rest(data, [
            "shape",
            "points",
            "seriesIndex",
            "index"
        ]);
        const value = Object.assign(Object.assign({}, v), {
            index: i
        });
        // Get data-driven style.
        // If it is a series shape, such as area and line,
        // provides the series of abstract data and indices
        // for this shape, otherwise the single datum and
        // index.
        const abstractDatum = seriesIndex ? seriesIndex.map((i)=>abstractData[i]) : abstractData[i];
        const I = seriesIndex ? seriesIndex : i;
        const visualStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(style, (d)=>valueOf(d, abstractDatum, I, abstractData, {
                channel
            }));
        // Try get shape from mark first, then from library.
        const shapeFunction = shapeLibrary[shape] ? shapeLibrary[shape](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), {
            type: shapeName(mark, shape)
        }), shapeContext);
        const defaults = getDefaultsStyle(theme, markType, shape, defaultShape);
        return shapeFunction(points, value, defaults, point2d);
    };
}
function getDefaultsStyle(theme, mark, shape, defaultShape) {
    if (typeof mark !== 'string') return;
    const { color } = theme;
    const markTheme = theme[mark] || {};
    const shapeTheme = markTheme[shape] || markTheme[defaultShape];
    return Object.assign({
        color
    }, shapeTheme);
}
function createAnimationFunction(type, mark, state, view, library) {
    var _a, _b;
    const [, createShape] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('shape', library);
    const [useAnimation] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$library$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLibrary"])('animation', library);
    const { defaultShape, shape: shapeLibrary } = state;
    const { theme, coordinate } = view;
    const upperType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(type);
    const key = `default${upperType}Animation`;
    // Get shape from mark first, then from library.
    const { [key]: defaultAnimation } = ((_a = shapeLibrary[defaultShape]) === null || _a === void 0 ? void 0 : _a.props) || createShape(shapeName(mark, defaultShape)).props;
    const { [type]: defaultEffectTiming = {} } = theme;
    const animate = ((_b = mark.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
    const context = {
        coordinate
    };
    return (data, from, to)=>{
        const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data;
        const options = Object.assign({
            type: animation || defaultAnimation
        }, animate);
        if (!options.type) return null;
        const animateFunction = useAnimation(options, context);
        const value = {
            delay,
            duration,
            easing
        };
        const A = animateFunction(from, to, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(defaultEffectTiming, value));
        let an = [];
        if (!Array.isArray(A)) {
            an = [
                A
            ];
        } else {
            an = A;
        }
        return an.filter(Boolean);
    };
}
function createEnterFunction(mark, state, view, library) {
    return createAnimationFunction('enter', mark, state, view, library);
}
/**
 * Animation will not cancel automatically, it should be canceled
 * manually. This is very important for performance.
 */ function cancel(animation) {
    animation.finished.then(()=>{
        animation.cancel();
    });
    return animation;
}
function createUpdateFunction(mark, state, view, library) {
    return createAnimationFunction('update', mark, state, view, library);
}
function createExitFunction(mark, state, view, library) {
    return createAnimationFunction('exit', mark, state, view, library);
}
function inferTheme(theme = {}) {
    if (typeof theme === 'string') return {
        type: theme
    };
    const { type = 'light' } = theme, rest = __rest(theme, [
        "type"
    ]);
    return Object.assign(Object.assign({}, rest), {
        type
    });
}
/**
 * @todo Infer builtin tooltips.
 */ function inferInteraction(view) {
    const defaults = {
        event: true,
        tooltip: true,
        // @todo Inferred by slider self.
        sliderFilter: true,
        legendFilter: true,
        scrollbarFilter: true
    };
    const { interaction = {} } = view;
    return Object.entries((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(defaults, interaction)).reverse();
}
function applyTransform(node, context) {
    return __awaiter(this, void 0, void 0, function*() {
        const { data } = node, rest = __rest(node, [
            "data"
        ]);
        if (data == undefined) return node;
        const [, { data: newData }] = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyDataTransform"])([], {
            data
        }, context);
        return Object.assign({
            data: newData
        }, rest);
    });
}
function updateBBox(selection) {
    selection.style('transform', (d)=>`translate(${d.paddingLeft + d.marginLeft}, ${d.paddingTop + d.marginTop})`).style('width', (d)=>d.innerWidth).style('height', (d)=>d.innerHeight);
}
function animateBBox(selection, extent) {
    const [delay, duration] = extent;
    selection.transition(function(data, i, element) {
        const { transform, width, height } = element.style;
        const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data;
        const keyframes = [
            {
                transform,
                width,
                height
            },
            {
                transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,
                width: innerWidth,
                height: innerHeight
            }
        ];
        return element.animate(keyframes, {
            delay,
            duration,
            fill: 'both'
        });
    });
}
function shapeName(mark, name) {
    const { type } = mark;
    if (typeof name === 'string') return `${type}.${name}`;
    return name;
}
/**
 * Create and update layer for each mark.
 * All the layers created here are treated as main layers.
 */ function updateLayers(selection, marks) {
    const facet = (d)=>d.class !== undefined ? `${d.class}` : '';
    // Skip for empty selection, it can't append nodes.
    const nodes = selection.nodes();
    if (nodes.length === 0) return;
    selection.selectAll(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAIN_LAYER_CLASS_NAME"])).data(marks, (d)=>d.key).join((enter)=>enter.append('g').attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAIN_LAYER_CLASS_NAME"]).attr('id', (d)=>d.key).style('facet', facet).style('fill', 'transparent').style('zIndex', (d)=>{
            var _a;
            return (_a = d.zIndex) !== null && _a !== void 0 ? _a : 0;
        }), (update)=>update.style('facet', facet).style('fill', 'transparent').style('zIndex', (d)=>{
            var _a;
            return (_a = d.zIndex) !== null && _a !== void 0 ? _a : 0;
        }), (exit)=>exit.remove());
    const labelLayer = selection.select(className(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_LAYER_CLASS_NAME"])).node();
    if (labelLayer) return;
    selection.append('g').attr('className', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_LAYER_CLASS_NAME"]).style('zIndex', 0);
}
function className(...names) {
    return names.map((d)=>`.${d}`).join('');
}
function applyClip(selection, clip) {
    if (!selection.node()) return;
    selection.style('clipPath', (data)=>{
        if (!clip) return null;
        const { paddingTop: y, paddingLeft: x, marginLeft: x1, marginTop: y1, innerWidth: width, innerHeight: height } = data;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            style: {
                x: x + x1,
                y: y + y1,
                width,
                height
            }
        });
    });
}
function inferComponentScales(scales, states, markState) {
    // add shape scale to state.
    var _a;
    // for cell, omit shape scale.
    // @todo support shape scale for cell.
    for (const [key] of markState.entries()){
        if (key.type === 'cell') {
            return scales.filter((scale)=>scale.name !== 'shape');
        }
    }
    // can't infer shape scale if there are multiple states.
    if (states.length !== 1 || scales.some((scale)=>scale.name === 'shape')) {
        return scales;
    }
    const { defaultShape: shape } = states[0];
    const acceptMarkTypes = [
        'point',
        'line',
        'rect',
        'hollow'
    ];
    if (!acceptMarkTypes.includes(shape)) return scales;
    const shapeMap = {
        point: 'point',
        line: 'hyphen',
        rect: 'square',
        hollow: 'hollow'
    };
    // create shape scale
    const field = ((_a = scales.find((scale)=>scale.name === 'color')) === null || _a === void 0 ? void 0 : _a.field) || null;
    const shapeScale = {
        field,
        name: 'shape',
        type: 'constant',
        domain: [],
        range: [
            shapeMap[shape]
        ]
    };
    return [
        ...scales,
        shapeScale
    ];
}
function applyStyle(selection, style) {
    for (const [key, value] of Object.entries(style)){
        selection.style(key, value);
    }
} //# sourceMappingURL=plot.js.map
}}),
"[project]/node_modules/@antv/g2/esm/runtime/render.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "destroy": (()=>destroy),
    "render": (()=>render),
    "renderToMountedElement": (()=>renderToMountedElement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$canvas$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g-canvas/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$plugin$2d$dragndrop$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$event$2d$emitter$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/event-emitter/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$canvas$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g-canvas/dist/index.esm.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$expr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/expr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$option$2d$preprocess$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/option-preprocess/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$plot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/plot.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Infer key for each node of view tree.
 * Each key should be unique in the entire view tree.
 * The key is for incremental render when view tree is changed.
 * @todo Fix custom key equals to inferred key.
 */ function inferKeys(options) {
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, options);
    const nodeParent = new Map([
        [
            root,
            null
        ]
    ]);
    const nodeIndex = new Map([
        [
            null,
            -1
        ]
    ]);
    const discovered = [
        root
    ];
    while(discovered.length){
        const node = discovered.shift();
        // If key of node is not specified, using parentKey and the index for it
        // in parent.children as its key.
        // e.g. The key of node named 'a' will be 'a', and the key of node named
        // 'b' will be 'parent-1' in the following view tree specification.
        // { key: 'parent', children: [{ name: 'a', key: 'a' }, { name: 'b' }] }
        if (node.key === undefined) {
            const parent = nodeParent.get(node);
            const index = nodeIndex.get(node);
            const key = parent === null ? `${0}` : `${parent.key}-${index}`;
            node.key = key;
        }
        const { children = [] } = node;
        if (Array.isArray(children)) {
            for(let i = 0; i < children.length; i++){
                // Clone node as well.
                const child = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, children[i]);
                children[i] = child;
                nodeParent.set(child, node);
                nodeIndex.set(child, i);
                discovered.push(child);
            }
        }
    }
    return root;
}
function Canvas(width, height) {
    const renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$canvas$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Renderer"]();
    // DragAndDropPlugin is for interaction.
    renderer.registerPlugin(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$plugin$2d$dragndrop$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plugin"]());
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Canvas"]({
        width,
        height,
        container: document.createElement('div'),
        renderer: renderer
    });
}
function render(options, context = {}, resolve = ()=>{}, reject = (e)=>{
    throw e;
}) {
    const afterParsedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$expr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseOptionsExpr"])(options);
    // Initialize the context if it is not provided.
    const { width = 640, height = 480, depth = 0 } = afterParsedOptions;
    // Preprocessing here, such as syntactic sugar.
    const preprocessedOption = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$option$2d$preprocess$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["preprocessOption"])(afterParsedOptions);
    const keyed = inferKeys(preprocessedOption);
    const { canvas = Canvas(width, height), emitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$event$2d$emitter$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](), library } = context;
    context.canvas = canvas;
    context.emitter = emitter;
    context.externals = {};
    const { width: prevWidth, height: prevHeight } = canvas.getConfig();
    if (prevWidth !== width || prevHeight !== height) {
        canvas.resize(width, height);
    }
    emitter.emit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].BEFORE_RENDER);
    // Plot the chart and mutate context.
    // Make sure that plot chart after container is ready for every time.
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(canvas.document.documentElement);
    canvas.ready.then(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$plot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["plot"])(Object.assign(Object.assign({}, keyed), {
            width,
            height,
            depth
        }), selection, context)).then(()=>{
        // Place the center of whole scene at z axis' origin.
        if (depth) {
            const [x, y] = canvas.document.documentElement.getPosition();
            // Since `render` method can be called for multiple times, use setPosition instead of translate here.
            canvas.document.documentElement.setPosition(x, y, -depth / 2);
        }
        // Wait for the next tick.
        // FIXME: Use `rendered?` event instead of `requestAnimationFrame`.
        canvas.requestAnimationFrame(()=>{
            canvas.requestAnimationFrame(()=>{
                emitter.emit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].AFTER_RENDER);
                resolve === null || resolve === void 0 ? void 0 : resolve();
            });
        });
    }).catch((e)=>{
        reject === null || reject === void 0 ? void 0 : reject(e);
    });
    // Return the container HTML element wraps the canvas or svg element.
    return normalizeContainer(canvas.getConfig().container);
}
function renderToMountedElement(options, context = {}, resolve = ()=>{}, reject = (e)=>{
    throw e;
}) {
    var _a;
    // Initialize the context if it is not provided.
    const { width = 640, height = 480 } = options;
    const keyed = inferKeys(options);
    const { group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"](), emitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$event$2d$emitter$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](), library } = context;
    if (!(group === null || group === void 0 ? void 0 : group.parentElement)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(`renderToMountedElement can't render chart to unmounted group.`);
    }
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(group);
    context.group = group;
    context.emitter = emitter;
    context.externals = {};
    context.canvas = context.canvas || ((_a = group === null || group === void 0 ? void 0 : group.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
    emitter.emit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].BEFORE_RENDER);
    // Plot the chart and mutate context.
    // Make sure that plot chart after container is ready for every time.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$plot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["plot"])(Object.assign(Object.assign({}, keyed), {
        width,
        height
    }), selection, context).then(()=>{
        var _a;
        (_a = context.canvas) === null || _a === void 0 ? void 0 : _a.requestAnimationFrame(()=>{
            emitter.emit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].AFTER_RENDER);
            resolve === null || resolve === void 0 ? void 0 : resolve();
        });
    }).catch((e)=>{
        reject === null || reject === void 0 ? void 0 : reject(e);
    });
    // Return the Group wraps the canvas or svg element.
    return group;
}
function destroy(options, context = {}, isDestroyCanvas = false, isClearEvents = true) {
    const { canvas, emitter } = context;
    if (canvas) {
        destroyAllInteractions(canvas);
        isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
    }
    if (isClearEvents) {
        emitter.off();
    }
}
/**
 * Destroy all interactions mounted on the canvas.
 */ function destroyAllInteractions(canvas) {
    const viewGroups = canvas.getRoot().querySelectorAll(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VIEW_CLASS_NAME"]}`);
    viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group)=>{
        const { nameInteraction = new Map() } = group;
        if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
            Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value)=>{
                value === null || value === void 0 ? void 0 : value.destroy();
            });
        }
    });
}
function normalizeContainer(container) {
    return typeof container === 'string' ? document.getElementById(container) : container;
} //# sourceMappingURL=render.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40antv_g2_esm_runtime_1cffd5._.js.map