(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@antv_g2_esm_data_66e59a._.js", {

"[project]/node_modules/@antv/g2/esm/data/utils/arc/sort.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "frequency": (()=>frequency),
    "id": (()=>id),
    "name": (()=>name),
    "weight": (()=>weight)
});
function weight(a, b) {
    return b.value - a.value;
}
function frequency(a, b) {
    return b.frequency - a.frequency;
}
function id(a, b) {
    return `${a.id}`.localeCompare(`${b.id}`);
}
function name(a, b) {
    return `${a.name}`.localeCompare(`${b.name}`);
} //# sourceMappingURL=sort.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/arc/arc.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Arc": (()=>Arc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sum.js [app-client] (ecmascript) <export default as sum>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$arc$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/arc/sort.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
;
;
;
const DEFAULT_OPTIONS = {
    y: 0,
    thickness: 0.05,
    weight: false,
    marginRatio: 0.1,
    id: (node)=>node.id,
    source: (edge)=>edge.source,
    target: (edge)=>edge.target,
    sourceWeight: (edge)=>edge.value || 1,
    targetWeight: (edge)=>edge.value || 1,
    sortBy: null
};
function Arc(options) {
    const { y, thickness, weight, marginRatio, id, source, target, sourceWeight, targetWeight, sortBy } = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    function arc(data) {
        // Clone first.
        const nodes = data.nodes.map((n)=>Object.assign({}, n));
        const edges = data.edges.map((n)=>Object.assign({}, n));
        // Keep reference in below functions.
        preprocess(nodes, edges);
        sortNodes(nodes, edges);
        layoutNodes(nodes, edges);
        layoutEdges(nodes, edges);
        return {
            nodes,
            edges
        };
    }
    /**
     * Calculate id, value, frequency for node, and source,target for edge.
     */ function preprocess(nodes, edges) {
        edges.forEach((edge)=>{
            edge.source = source(edge);
            edge.target = target(edge);
            edge.sourceWeight = sourceWeight(edge);
            edge.targetWeight = targetWeight(edge);
        });
        // Group edges by source, target.
        const edgesBySource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(edges, (e)=>e.source);
        const edgesByTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(edges, (e)=>e.target);
        nodes.forEach((node)=>{
            node.id = id(node);
            const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
            const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
            node.frequency = sources.length + targets.length;
            node.value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(sources, (d)=>d.sourceWeight) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(targets, (d)=>d.targetWeight);
        });
        return {
            nodes,
            edges
        };
    }
    function sortNodes(nodes, edges) {
        const method = typeof sortBy === 'function' ? sortBy : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$arc$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[sortBy];
        if (method) {
            nodes.sort(method);
        }
    }
    function layoutNodes(nodes, edges) {
        const size = nodes.length;
        if (!size) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])("Invalid nodes: it's empty!");
        }
        // No weight.
        if (!weight) {
            const deltaX = 1 / size;
            nodes.forEach((node, i)=>{
                node.x = (i + 0.5) * deltaX;
                node.y = y;
            });
            return {
                nodes,
                edges
            };
        }
        // todo: marginRatio should be in [0, 1)
        // todo: thickness shoule be in (0, 1)
        const margin = marginRatio / (2 * size);
        const total = nodes.reduce((prev, node)=>prev += node.value, 0);
        nodes.reduce((deltaX, node)=>{
            node.weight = node.value / total;
            node.width = node.weight * (1 - marginRatio);
            node.height = thickness;
            /* points
             * 3---2
             * |   |
             * 0---1
             */ const minX = margin + deltaX;
            const maxX = minX + node.width;
            const minY = y - thickness / 2;
            const maxY = minY + thickness;
            node.x = [
                minX,
                maxX,
                maxX,
                minX
            ];
            node.y = [
                minY,
                minY,
                maxY,
                maxY
            ];
            // Return next deltaX.
            return deltaX + node.width + 2 * margin;
        }, 0);
        return {
            nodes,
            edges
        };
    }
    /**
     * Get edge layout information from nodes, and save into edge object.
     */ function layoutEdges(nodes, edges) {
        const nodesMap = new Map(nodes.map((d)=>[
                d.id,
                d
            ]));
        if (!weight) {
            edges.forEach((edge)=>{
                const sourceId = source(edge);
                const targetId = target(edge);
                const sourceNode = nodesMap.get(sourceId);
                const targetNode = nodesMap.get(targetId);
                // Edge's layout information is Equal with node.
                if (sourceNode && targetNode) {
                    edge.x = [
                        sourceNode.x,
                        targetNode.x
                    ];
                    edge.y = [
                        sourceNode.y,
                        targetNode.y
                    ];
                }
            });
            return {
                nodes,
                edges
            };
        }
        // Initial edge.x, edge.y.
        edges.forEach((edge)=>{
            edge.x = [
                0,
                0,
                0,
                0
            ];
            edge.y = [
                y,
                y,
                y,
                y
            ];
        });
        // Group edges by source, target.
        const edgesBySource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(edges, (e)=>e.source);
        const edgesByTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(edges, (e)=>e.target);
        // When weight = true, we need to calculation the bbox of edge start/end.
        nodes.forEach((node)=>{
            const { edges, width, x, y, value, id } = node;
            const sourceEdges = edgesBySource.get(id) || [];
            const targetEdges = edgesByTarget.get(id) || [];
            let offset = 0;
            /* points
             * 0----------2
             * |          |
             * 1----------3
             */ sourceEdges.map((edge)=>{
                const w = edge.sourceWeight / value * width;
                edge.x[0] = x[0] + offset;
                edge.x[1] = x[0] + offset + w;
                offset += w;
            });
            targetEdges.forEach((edge)=>{
                const w = edge.targetWeight / value * width;
                edge.x[3] = x[0] + offset;
                edge.x[2] = x[0] + offset + w;
                offset += w;
            });
        });
    }
    return arc;
} //# sourceMappingURL=arc.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/arc.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Arc": (()=>Arc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$arc$2f$arc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/arc/arc.js [app-client] (ecmascript)");
;
const Arc = (options)=>{
    return (data)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$arc$2f$arc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Arc"])(options)(data);
    };
};
Arc.props = {}; //# sourceMappingURL=arc.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/cluster.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Cluster": (()=>Cluster),
    "hierarchyFunction": (()=>hierarchyFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$hierarchy$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-hierarchy.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$hierarchy$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__hierarchy$3e$__ = __turbopack_import__("[project]/node_modules/d3-hierarchy/src/hierarchy/index.js [app-client] (ecmascript) <export default as hierarchy>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$cluster$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__cluster$3e$__ = __turbopack_import__("[project]/node_modules/d3-hierarchy/src/cluster.js [app-client] (ecmascript) <export default as cluster>");
;
const hierarchyFunction = (layoutFunction)=>(options)=>{
        return (data)=>{
            const { field = 'value', nodeSize, separation, sortBy, as = [
                'x',
                'y'
            ] } = options;
            const [x, y] = as;
            // Process root data.
            const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$hierarchy$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__hierarchy$3e$__["hierarchy"])(data, (d)=>d.children).sum((d)=>d[field]).sort(sortBy);
            // Layout
            const c = layoutFunction();
            c.size([
                1,
                1
            ]);
            if (nodeSize) c.nodeSize(nodeSize);
            if (separation) c.separation(separation);
            c(root);
            const nodes = [];
            root.each((node)=>{
                node[x] = node.x;
                node[y] = node.y;
                node.name = node.data.name;
                nodes.push(node);
            });
            const edges = root.links();
            edges.forEach((edge)=>{
                edge[x] = [
                    edge.source[x],
                    edge.target[x]
                ];
                edge[y] = [
                    edge.source[y],
                    edge.target[y]
                ];
            });
            return {
                nodes,
                edges
            };
        };
    };
const Cluster = (options)=>{
    return hierarchyFunction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$cluster$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__cluster$3e$__["cluster"])(options);
};
Cluster.props = {}; //# sourceMappingURL=cluster.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/tree.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Tree": (()=>Tree)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$hierarchy$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-hierarchy.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$cluster$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/cluster.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$tree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__tree$3e$__ = __turbopack_import__("[project]/node_modules/d3-hierarchy/src/tree.js [app-client] (ecmascript) <export default as tree>");
;
;
const Tree = (options)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$cluster$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hierarchyFunction"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$hierarchy$2f$src$2f$tree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__tree$3e$__["tree"])(options);
};
Tree.props = {}; //# sourceMappingURL=tree.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "center": (()=>center),
    "justify": (()=>justify),
    "left": (()=>left),
    "right": (()=>right)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript) <export default as min>");
;
function targetDepth(d) {
    return d.target.depth;
}
function left(node) {
    return node.depth;
}
function right(node, n) {
    return n - 1 - node.height;
}
function justify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__["min"])(node.sourceLinks, targetDepth) - 1 : 0;
} //# sourceMappingURL=align.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "constant": (()=>constant)
});
function constant(x) {
    return function() {
        return x;
    };
} //# sourceMappingURL=constant.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Sankey": (()=>Sankey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sum.js [app-client] (ecmascript) <export default as sum>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript) <export default as min>");
;
;
;
function ascendingSourceBreadth(a, b) {
    return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
    return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
    return a.y0 - b.y0;
}
function value(d) {
    return d.value;
}
function defaultId(d) {
    return d.index;
}
function defaultNodes(graph) {
    return graph.nodes;
}
function defaultLinks(graph) {
    return graph.links;
}
function find(nodeById, id) {
    const node = nodeById.get(id);
    if (!node) throw new Error('missing: ' + id);
    return node;
}
function computeLinkBreadths({ nodes }) {
    for (const node of nodes){
        let y0 = node.y0;
        let y1 = y0;
        for (const link of node.sourceLinks){
            link.y0 = y0 + link.width / 2;
            y0 += link.width;
        }
        for (const link of node.targetLinks){
            link.y1 = y1 + link.width / 2;
            y1 += link.width;
        }
    }
}
function Sankey() {
    let x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent
    let dx = 24; // nodeWidth
    let dy = 8, py; // nodePadding
    let id = defaultId;
    let align = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["justify"];
    let depth;
    let sort;
    let linkSort;
    let nodes = defaultNodes;
    let links = defaultLinks;
    let iterations = 6;
    function sankey(arg) {
        const graph = {
            nodes: nodes(arg),
            links: links(arg)
        };
        computeNodeLinks(graph);
        computeNodeValues(graph);
        computeNodeDepths(graph);
        computeNodeHeights(graph);
        computeNodeBreadths(graph);
        computeLinkBreadths(graph);
        return graph;
    }
    sankey.update = function(graph) {
        computeLinkBreadths(graph);
        return graph;
    };
    sankey.nodeId = function(_) {
        return arguments.length ? (id = typeof _ === 'function' ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])(_), sankey) : id;
    };
    sankey.nodeAlign = function(_) {
        return arguments.length ? (align = typeof _ === 'function' ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])(_), sankey) : align;
    };
    sankey.nodeDepth = function(_) {
        return arguments.length ? (depth = typeof _ === 'function' ? _ : _, sankey) : depth;
    };
    sankey.nodeSort = function(_) {
        return arguments.length ? (sort = _, sankey) : sort;
    };
    sankey.nodeWidth = function(_) {
        return arguments.length ? (dx = +_, sankey) : dx;
    };
    sankey.nodePadding = function(_) {
        return arguments.length ? (dy = py = +_, sankey) : dy;
    };
    sankey.nodes = function(_) {
        return arguments.length ? (nodes = typeof _ === 'function' ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])(_), sankey) : nodes;
    };
    sankey.links = function(_) {
        return arguments.length ? (links = typeof _ === 'function' ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])(_), sankey) : links;
    };
    sankey.linkSort = function(_) {
        return arguments.length ? (linkSort = _, sankey) : linkSort;
    };
    sankey.size = function(_) {
        return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [
            x1 - x0,
            y1 - y0
        ];
    };
    sankey.extent = function(_) {
        return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [
            [
                x0,
                y0
            ],
            [
                x1,
                y1
            ]
        ];
    };
    sankey.iterations = function(_) {
        return arguments.length ? (iterations = +_, sankey) : iterations;
    };
    function computeNodeLinks({ nodes, links }) {
        nodes.forEach((node, idx)=>{
            node.index = idx;
            node.sourceLinks = [];
            node.targetLinks = [];
        });
        const nodeById = new Map(nodes.map((d)=>[
                id(d),
                d
            ]));
        links.forEach((link, idx)=>{
            link.index = idx;
            let { source, target } = link;
            if (typeof source !== 'object') source = link.source = find(nodeById, source);
            if (typeof target !== 'object') target = link.target = find(nodeById, target);
            source.sourceLinks.push(link);
            target.targetLinks.push(link);
        });
        if (linkSort != null) {
            for (const { sourceLinks, targetLinks } of nodes){
                sourceLinks.sort(linkSort);
                targetLinks.sort(linkSort);
            }
        }
    }
    function computeNodeValues({ nodes }) {
        for (const node of nodes){
            node.value = node.fixedValue === undefined ? Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(node.sourceLinks, value), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(node.targetLinks, value)) : node.fixedValue;
        }
    }
    function computeNodeDepths({ nodes }) {
        const n = nodes.length;
        let current = new Set(nodes);
        let next = new Set();
        let x = 0;
        while(current.size){
            current.forEach((node)=>{
                node.depth = x;
                for (const { target } of node.sourceLinks){
                    next.add(target);
                }
            });
            if (++x > n) throw new Error('circular link');
            current = next;
            next = new Set();
        }
        // 如果配置了 depth，则设置自定义 depth
        if (depth) {
            const maxDepth = Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(nodes, (d)=>d.depth) + 1, 0);
            let node;
            for(let i = 0; i < nodes.length; i++){
                node = nodes[i];
                node.depth = depth.call(null, node, maxDepth);
            }
        }
    }
    function computeNodeHeights({ nodes }) {
        const n = nodes.length;
        let current = new Set(nodes);
        let next = new Set();
        let x = 0;
        while(current.size){
            current.forEach((node)=>{
                node.height = x;
                for (const { source } of node.targetLinks){
                    next.add(source);
                }
            });
            if (++x > n) throw new Error('circular link');
            current = next;
            next = new Set();
        }
    }
    function computeNodeLayers({ nodes }) {
        const x = Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(nodes, (d)=>d.depth) + 1, 0);
        const kx = (x1 - x0 - dx) / (x - 1);
        const columns = new Array(x).fill(0).map(()=>[]);
        for (const node of nodes){
            const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
            node.layer = i;
            node.x0 = x0 + i * kx;
            node.x1 = node.x0 + dx;
            if (columns[i]) columns[i].push(node);
            else columns[i] = [
                node
            ];
        }
        if (sort) for (const column of columns){
            column.sort(sort);
        }
        return columns;
    }
    function initializeNodeBreadths(columns) {
        const ky = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__["min"])(columns, (c)=>(y1 - y0 - (c.length - 1) * py) / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sum$3e$__["sum"])(c, value));
        for (const nodes of columns){
            let y = y0;
            for (const node of nodes){
                node.y0 = y;
                node.y1 = y + node.value * ky;
                y = node.y1 + py;
                for (const link of node.sourceLinks){
                    link.width = link.value * ky;
                }
            }
            y = (y1 - y + py) / (nodes.length + 1);
            for(let i = 0; i < nodes.length; ++i){
                const node = nodes[i];
                node.y0 += y * (i + 1);
                node.y1 += y * (i + 1);
            }
            reorderLinks(nodes);
        }
    }
    function computeNodeBreadths(graph) {
        const columns = computeNodeLayers(graph);
        py = Math.min(dy, (y1 - y0) / ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(columns, (c)=>c.length) - 1));
        initializeNodeBreadths(columns);
        for(let i = 0; i < iterations; ++i){
            const alpha = Math.pow(0.99, i);
            const beta = Math.max(1 - alpha, (i + 1) / iterations);
            relaxRightToLeft(columns, alpha, beta);
            relaxLeftToRight(columns, alpha, beta);
        }
    }
    // Reposition each node based on its incoming (target) links.
    function relaxLeftToRight(columns, alpha, beta) {
        for(let i = 1, n = columns.length; i < n; ++i){
            const column = columns[i];
            for (const target of column){
                let y = 0;
                let w = 0;
                for (const { source, value } of target.targetLinks){
                    const v = value * (target.layer - source.layer);
                    y += targetTop(source, target) * v;
                    w += v;
                }
                if (!(w > 0)) continue;
                const dy = (y / w - target.y0) * alpha;
                target.y0 += dy;
                target.y1 += dy;
                reorderNodeLinks(target);
            }
            if (sort === undefined) column.sort(ascendingBreadth);
            if (column.length) resolveCollisions(column, beta);
        }
    }
    // Reposition each node based on its outgoing (source) links.
    function relaxRightToLeft(columns, alpha, beta) {
        for(let n = columns.length, i = n - 2; i >= 0; --i){
            const column = columns[i];
            for (const source of column){
                let y = 0;
                let w = 0;
                for (const { target, value } of source.sourceLinks){
                    const v = value * (target.layer - source.layer);
                    y += sourceTop(source, target) * v;
                    w += v;
                }
                if (!(w > 0)) continue;
                const dy = (y / w - source.y0) * alpha;
                source.y0 += dy;
                source.y1 += dy;
                reorderNodeLinks(source);
            }
            if (sort === undefined) column.sort(ascendingBreadth);
            if (column.length) resolveCollisions(column, beta);
        }
    }
    function resolveCollisions(nodes, alpha) {
        const i = nodes.length >> 1;
        const subject = nodes[i];
        resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
        resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
        resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
        resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
    }
    // Push any overlapping nodes down.
    function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
        for(; i < nodes.length; ++i){
            const node = nodes[i];
            const dy = (y - node.y0) * alpha;
            if (dy > 1e-6) node.y0 += dy, node.y1 += dy;
            y = node.y1 + py;
        }
    }
    // Push any overlapping nodes up.
    function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
        for(; i >= 0; --i){
            const node = nodes[i];
            const dy = (node.y1 - y) * alpha;
            if (dy > 1e-6) node.y0 -= dy, node.y1 -= dy;
            y = node.y0 - py;
        }
    }
    function reorderNodeLinks({ sourceLinks, targetLinks }) {
        if (linkSort === undefined) {
            for (const { source: { sourceLinks } } of targetLinks){
                sourceLinks.sort(ascendingTargetBreadth);
            }
            for (const { target: { targetLinks } } of sourceLinks){
                targetLinks.sort(ascendingSourceBreadth);
            }
        }
    }
    function reorderLinks(nodes) {
        if (linkSort === undefined) {
            for (const { sourceLinks, targetLinks } of nodes){
                sourceLinks.sort(ascendingTargetBreadth);
                targetLinks.sort(ascendingSourceBreadth);
            }
        }
    }
    // Returns the target.y0 that would produce an ideal link from source to target.
    function targetTop(source, target) {
        let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
        for (const { target: node, width } of source.sourceLinks){
            if (node === target) break;
            y += width + py;
        }
        for (const { source: node, width } of target.targetLinks){
            if (node === source) break;
            y -= width;
        }
        return y;
    }
    // Returns the source.y0 that would produce an ideal link from source to target.
    function sourceTop(source, target) {
        let y = target.y0 - (target.targetLinks.length - 1) * py / 2;
        for (const { source: node, width } of target.targetLinks){
            if (node === source) break;
            y += width + py;
        }
        for (const { target: node, width } of source.sourceLinks){
            if (node === target) break;
            y -= width;
        }
        return y;
    }
    return sankey;
} //# sourceMappingURL=sankey.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js [app-client] (ecmascript) <export Sankey as sankey>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "sankey": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$sankey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sankey"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$sankey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@antv/g2/esm/data/sankey.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Sankey": (()=>Sankey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$sankey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__Sankey__as__sankey$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js [app-client] (ecmascript) <export Sankey as sankey>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js [app-client] (ecmascript)");
;
const DEFAULT_OPTIONS = {
    nodeAlign: 'justify',
    nodeWidth: 0.008,
    nodePadding: 0.03,
    nodes: (graph)=>graph.nodes,
    links: (graph)=>graph.links,
    nodeSort: undefined,
    linkSort: undefined,
    iterations: 6
};
const ALIGN_METHOD = {
    left: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["left"],
    right: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["right"],
    center: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["center"],
    justify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["justify"]
};
function getNodeAlignFunction(nodeAlign) {
    const type = typeof nodeAlign;
    if (type === 'string') return ALIGN_METHOD[nodeAlign] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["justify"];
    if (type === 'function') return nodeAlign;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$align$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["justify"];
}
const Sankey = (options)=>{
    return (data)=>{
        const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations } = Object.assign({}, DEFAULT_OPTIONS, options);
        const sankeyProcessor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$sankey$2f$sankey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__Sankey__as__sankey$3e$__["sankey"])().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations).extent([
            [
                0,
                0
            ],
            [
                1,
                1
            ]
        ]);
        if (typeof nodeId === 'function') {
            sankeyProcessor.nodeId(nodeId);
        }
        const layoutData = sankeyProcessor(data);
        const { nodes: N, links: L } = layoutData;
        const nodes = N.map((node)=>{
            const { x0, x1, y0, y1 } = node;
            /* points
             * 3---2
             * |   |
             * 0---1
             */ return Object.assign(Object.assign({}, node), {
                x: [
                    x0,
                    x1,
                    x1,
                    x0
                ],
                y: [
                    y0,
                    y0,
                    y1,
                    y1
                ]
            });
        });
        const links = L.map((edge)=>{
            const { source, target } = edge;
            const sx = source.x1;
            const tx = target.x0;
            const offset = edge.width / 2;
            return Object.assign(Object.assign({}, edge), {
                x: [
                    sx,
                    sx,
                    tx,
                    tx
                ],
                y: [
                    edge.y0 + offset,
                    edge.y0 - offset,
                    edge.y1 + offset,
                    edge.y1 - offset
                ]
            });
        });
        return {
            nodes,
            links
        };
    };
};
Sankey.props = {}; //# sourceMappingURL=sankey.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// need some basic operations on vectors, rather than adding a dependency,
// just define here
__turbopack_esm__({
    "dot": (()=>dot),
    "gemv": (()=>gemv),
    "norm2": (()=>norm2),
    "scale": (()=>scale),
    "weightedSum": (()=>weightedSum),
    "zeros": (()=>zeros),
    "zerosM": (()=>zerosM)
});
function zeros(x) {
    const r = new Array(x);
    for(let i = 0; i < x; ++i){
        r[i] = 0;
    }
    return r;
}
function zerosM(x, y) {
    return zeros(x).map(()=>zeros(y));
}
function dot(a, b) {
    let ret = 0;
    for(let i = 0; i < a.length; ++i){
        ret += a[i] * b[i];
    }
    return ret;
}
function norm2(a) {
    return Math.sqrt(dot(a, a));
}
function scale(ret, value, c) {
    for(let i = 0; i < value.length; ++i){
        ret[i] = value[i] * c;
    }
}
function weightedSum(ret, w1, v1, w2, v2) {
    for(let j = 0; j < ret.length; ++j){
        ret[j] = w1 * v1[j] + w2 * v2[j];
    }
}
function gemv(output, A, x) {
    for(let i = 0; i < output.length; ++i){
        output[i] = dot(A[i], x);
    }
} //# sourceMappingURL=blas1.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/nelderMead.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "nelderMead": (()=>nelderMead)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js [app-client] (ecmascript)");
;
function nelderMead(f, x0, parameters) {
    parameters = parameters || {};
    const maxIterations = parameters.maxIterations || x0.length * 200;
    const nonZeroDelta = parameters.nonZeroDelta || 1.05;
    const zeroDelta = parameters.zeroDelta || 0.001;
    const minErrorDelta = parameters.minErrorDelta || 1e-6;
    const minTolerance = parameters.minErrorDelta || 1e-5;
    const rho = parameters.rho !== undefined ? parameters.rho : 1;
    const chi = parameters.chi !== undefined ? parameters.chi : 2;
    const psi = parameters.psi !== undefined ? parameters.psi : -0.5;
    const sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5;
    let maxDiff;
    // initialize simplex.
    const N = x0.length;
    const simplex = new Array(N + 1);
    simplex[0] = x0;
    simplex[0].fx = f(x0);
    simplex[0].id = 0;
    for(let i = 0; i < N; ++i){
        const point = x0.slice();
        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
        simplex[i + 1] = point;
        simplex[i + 1].fx = f(point);
        simplex[i + 1].id = i + 1;
    }
    function updateSimplex(value) {
        for(let i = 0; i < value.length; i++){
            simplex[N][i] = value[i];
        }
        simplex[N].fx = value.fx;
    }
    const sortOrder = (a, b)=>a.fx - b.fx;
    const centroid = x0.slice();
    const reflected = x0.slice();
    const contracted = x0.slice();
    const expanded = x0.slice();
    for(let iteration = 0; iteration < maxIterations; ++iteration){
        simplex.sort(sortOrder);
        if (parameters.history) {
            // copy the simplex (since later iterations will mutate) and
            // sort it to have a consistent order between iterations
            const sortedSimplex = simplex.map((x)=>{
                const state = x.slice();
                state.fx = x.fx;
                state.id = x.id;
                return state;
            });
            sortedSimplex.sort((a, b)=>a.id - b.id);
            parameters.history.push({
                x: simplex[0].slice(),
                fx: simplex[0].fx,
                simplex: sortedSimplex
            });
        }
        maxDiff = 0;
        for(let i = 0; i < N; ++i){
            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
        }
        if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
            break;
        }
        // compute the centroid of all but the worst point in the simplex
        for(let i = 0; i < N; ++i){
            centroid[i] = 0;
            for(let j = 0; j < N; ++j){
                centroid[i] += simplex[j][i];
            }
            centroid[i] /= N;
        }
        // reflect the worst point past the centroid  and compute loss at reflected
        // point
        const worst = simplex[N];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(reflected, 1 + rho, centroid, -rho, worst);
        reflected.fx = f(reflected);
        // if the reflected point is the best seen, then possibly expand
        if (reflected.fx < simplex[0].fx) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(expanded, 1 + chi, centroid, -chi, worst);
            expanded.fx = f(expanded);
            if (expanded.fx < reflected.fx) {
                updateSimplex(expanded);
            } else {
                updateSimplex(reflected);
            }
        } else if (reflected.fx >= simplex[N - 1].fx) {
            let shouldReduce = false;
            if (reflected.fx > worst.fx) {
                // do an inside contraction
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(contracted, 1 + psi, centroid, -psi, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < worst.fx) {
                    updateSimplex(contracted);
                } else {
                    shouldReduce = true;
                }
            } else {
                // do an outside contraction
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(contracted, 1 - psi * rho, centroid, psi * rho, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < reflected.fx) {
                    updateSimplex(contracted);
                } else {
                    shouldReduce = true;
                }
            }
            if (shouldReduce) {
                // if we don't contract here, we're done
                if (sigma >= 1) break;
                // do a reduction
                for(let i = 1; i < simplex.length; ++i){
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                    simplex[i].fx = f(simplex[i]);
                }
            }
        } else {
            updateSimplex(reflected);
        }
    }
    simplex.sort(sortOrder);
    return {
        fx: simplex[0].fx,
        x: simplex[0]
    };
} //# sourceMappingURL=nelderMead.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/bisect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/** finds the zeros of a function, given two starting points (which must
 * have opposite signs */ __turbopack_esm__({
    "bisect": (()=>bisect)
});
function bisect(f, a, b, parameters) {
    parameters = parameters || {};
    const maxIterations = parameters.maxIterations || 100;
    const tolerance = parameters.tolerance || 1e-10;
    const fA = f(a);
    const fB = f(b);
    let delta = b - a;
    if (fA * fB > 0) {
        throw 'Initial bisect points must have opposite signs';
    }
    if (fA === 0) return a;
    if (fB === 0) return b;
    for(let i = 0; i < maxIterations; ++i){
        delta /= 2;
        const mid = a + delta;
        const fMid = f(mid);
        if (fMid * fA >= 0) {
            a = mid;
        }
        if (Math.abs(delta) < tolerance || fMid === 0) {
            return mid;
        }
    }
    return a + delta;
} //# sourceMappingURL=bisect.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "circleArea": (()=>circleArea),
    "circleCircleIntersection": (()=>circleCircleIntersection),
    "circleOverlap": (()=>circleOverlap),
    "containedInCircles": (()=>containedInCircles),
    "distance": (()=>distance),
    "getCenter": (()=>getCenter),
    "intersectionArea": (()=>intersectionArea)
});
const SMALL = 1e-10;
function intersectionArea(circles, stats) {
    // Get all the intersection points of the circles
    const intersectionPoints = getIntersectionPoints(circles);
    // Filter out points that aren't included in all the circles
    const innerPoints = intersectionPoints.filter(function(p) {
        return containedInCircles(p, circles);
    });
    let arcArea = 0, polygonArea = 0, i;
    const arcs = [];
    // If we have intersection points that are within all the circles,
    // then figure out the area contained by them
    if (innerPoints.length > 1) {
        // Sort the points by angle from the center of the polygon, which lets
        // us just iterate over points to get the edges
        const center = getCenter(innerPoints);
        for(i = 0; i < innerPoints.length; ++i){
            const p = innerPoints[i];
            p.angle = Math.atan2(p.x - center.x, p.y - center.y);
        }
        innerPoints.sort(function(a, b) {
            return b.angle - a.angle;
        });
        // Iterate over all points, get arc between the points
        // and update the areas
        let p2 = innerPoints[innerPoints.length - 1];
        for(i = 0; i < innerPoints.length; ++i){
            const p1 = innerPoints[i];
            // Polygon area updates easily ...
            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
            // Updating the arc area is a little more involved
            const midPoint = {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
            let arc = null;
            for(let j = 0; j < p1.parentIndex.length; ++j){
                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
                    // Figure out the angle halfway between the two points
                    // on the current circle
                    const circle = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y), a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);
                    let angleDiff = a2 - a1;
                    if (angleDiff < 0) {
                        angleDiff += 2 * Math.PI;
                    }
                    // and use that angle to figure out the width of the
                    // arc
                    const a = a2 - angleDiff / 2;
                    let width = distance(midPoint, {
                        x: circle.x + circle.radius * Math.sin(a),
                        y: circle.y + circle.radius * Math.cos(a)
                    });
                    // Clamp the width to the largest is can actually be
                    // (sometimes slightly overflows because of FP errors)
                    if (width > circle.radius * 2) {
                        width = circle.radius * 2;
                    }
                    // Pick the circle whose arc has the smallest width
                    if (arc === null || arc.width > width) {
                        arc = {
                            circle: circle,
                            width: width,
                            p1: p1,
                            p2: p2
                        };
                    }
                }
            }
            if (arc !== null) {
                arcs.push(arc);
                arcArea += circleArea(arc.circle.radius, arc.width);
                p2 = p1;
            }
        }
    } else {
        // No intersection points, is either disjoint - or is completely
        // overlapped. figure out which by examining the smallest circle
        let smallest = circles[0];
        for(i = 1; i < circles.length; ++i){
            if (circles[i].radius < smallest.radius) {
                smallest = circles[i];
            }
        }
        // Make sure the smallest circle is completely contained in all
        // the other circles
        let disjoint = false;
        for(i = 0; i < circles.length; ++i){
            if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
                disjoint = true;
                break;
            }
        }
        if (disjoint) {
            arcArea = polygonArea = 0;
        } else {
            arcArea = smallest.radius * smallest.radius * Math.PI;
            arcs.push({
                circle: smallest,
                p1: {
                    x: smallest.x,
                    y: smallest.y + smallest.radius
                },
                p2: {
                    x: smallest.x - SMALL,
                    y: smallest.y + smallest.radius
                },
                width: smallest.radius * 2
            });
        }
    }
    polygonArea /= 2;
    if (stats) {
        stats.area = arcArea + polygonArea;
        stats.arcArea = arcArea;
        stats.polygonArea = polygonArea;
        stats.arcs = arcs;
        stats.innerPoints = innerPoints;
        stats.intersectionPoints = intersectionPoints;
    }
    return arcArea + polygonArea;
}
function containedInCircles(point, circles) {
    for(let i = 0; i < circles.length; ++i){
        if (distance(point, circles[i]) > circles[i].radius + SMALL) {
            return false;
        }
    }
    return true;
}
/** Gets all intersection points between a bunch of circles */ function getIntersectionPoints(circles) {
    const ret = [];
    for(let i = 0; i < circles.length; ++i){
        for(let j = i + 1; j < circles.length; ++j){
            const intersect = circleCircleIntersection(circles[i], circles[j]);
            for(let k = 0; k < intersect.length; ++k){
                const p = intersect[k];
                p.parentIndex = [
                    i,
                    j
                ];
                ret.push(p);
            }
        }
    }
    return ret;
}
function circleArea(r, width) {
    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance(p1, p2) {
    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d) {
    // no overlap
    if (d >= r1 + r2) {
        return 0;
    }
    // Completely overlapped
    if (d <= Math.abs(r1 - r2)) {
        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
    }
    const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
    return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
    const d = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
    // If to far away, or self contained - can't be done
    if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
        return [];
    }
    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + a * (p2.x - p1.x) / d, y0 = p1.y + a * (p2.y - p1.y) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);
    return [
        {
            x: x0 + rx,
            y: y0 - ry
        },
        {
            x: x0 - rx,
            y: y0 + ry
        }
    ];
}
function getCenter(points) {
    const center = {
        x: 0,
        y: 0
    };
    for(let i = 0; i < points.length; ++i){
        center.x += points[i].x;
        center.y += points[i].y;
    }
    center.x /= points.length;
    center.y /= points.length;
    return center;
} //# sourceMappingURL=circleintersection.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/linesearch.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "wolfeLineSearch": (()=>wolfeLineSearch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js [app-client] (ecmascript)");
;
function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
    const phi0 = current.fx;
    const phiPrime0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(current.fxprime, pk);
    let phi = phi0;
    let phi_old = phi0;
    let phiPrime = phiPrime0;
    let a0 = 0;
    a = a || 1;
    c1 = c1 || 1e-6;
    c2 = c2 || 0.1;
    function zoom(a_lo, a_high, phi_lo) {
        for(let iteration = 0; iteration < 16; ++iteration){
            a = (a_lo + a_high) / 2;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(next.fxprime, pk);
            if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {
                a_high = a;
            } else {
                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                    return a;
                }
                if (phiPrime * (a_high - a_lo) >= 0) {
                    a_high = a_lo;
                }
                a_lo = a;
                phi_lo = phi;
            }
        }
        return 0;
    }
    for(let iteration = 0; iteration < 10; ++iteration){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(next.x, 1.0, current.x, a, pk);
        phi = next.fx = f(next.x, next.fxprime);
        phiPrime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(next.fxprime, pk);
        if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {
            return zoom(a0, a, phi_old);
        }
        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
            return a;
        }
        if (phiPrime >= 0) {
            return zoom(a, a0, phi);
        }
        phi_old = phi;
        a0 = a;
        a *= 2;
    }
    return a;
} //# sourceMappingURL=linesearch.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/conjugateGradient.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "conjugateGradient": (()=>conjugateGradient),
    "conjugateGradientSolve": (()=>conjugateGradientSolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$linesearch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/linesearch.js [app-client] (ecmascript)");
;
;
function conjugateGradient(f, initial, params) {
    // allocate all memory up front here, keep out of the loop for perfomance
    // reasons
    let current = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
    };
    let next = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
    };
    const yk = initial.slice();
    let temp;
    let a = 1;
    params = params || {};
    const maxIterations = params.maxIterations || initial.length * 20;
    current.fx = f(current.x, current.fxprime);
    const pk = current.fxprime.slice();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(pk, current.fxprime, -1);
    for(let i = 0; i < maxIterations; ++i){
        a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$linesearch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wolfeLineSearch"])(f, pk, current, next, a);
        // todo: history in wrong spot?
        if (params.history) {
            params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice(),
                alpha: a
            });
        }
        if (!a) {
            // faiiled to find point that satifies wolfe conditions.
            // reset direction for next iteration
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(pk, current.fxprime, -1);
        } else {
            // update direction using Polak–Ribiere CG method
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(yk, 1, next.fxprime, -1, current.fxprime);
            const delta_k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(current.fxprime, current.fxprime);
            const beta_k = Math.max(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(yk, next.fxprime) / delta_k);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(pk, beta_k, pk, -1, next.fxprime);
            temp = current;
            current = next;
            next = temp;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["norm2"])(current.fxprime) <= 1e-5) {
            break;
        }
    }
    if (params.history) {
        params.history.push({
            x: current.x.slice(),
            fx: current.fx,
            fxprime: current.fxprime.slice(),
            alpha: a
        });
    }
    return current;
}
function conjugateGradientSolve(A, b, x, history) {
    const r = x.slice();
    const Ap = x.slice();
    let rsold;
    let rsnew;
    let alpha;
    // r = b - A*x
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gemv"])(Ap, A, x);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(r, 1, b, -1, Ap);
    const p = r.slice();
    rsold = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(r, r);
    for(let i = 0; i < b.length; ++i){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gemv"])(Ap, A, p);
        alpha = rsold / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(p, Ap);
        if (history) {
            history.push({
                x: x.slice(),
                p: p.slice(),
                alpha: alpha
            });
        }
        //x=x+alpha*p;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(x, 1, x, alpha, p);
        // r=r-alpha*Ap;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(r, 1, r, -alpha, Ap);
        rsnew = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dot"])(r, r);
        if (Math.sqrt(rsnew) <= 1e-10) break;
        // p=r+(rsnew/rsold)*p;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weightedSum"])(p, 1, r, rsnew / rsold, p);
        rsold = rsnew;
    }
    if (history) {
        history.push({
            x: x.slice(),
            p: p.slice(),
            alpha: alpha
        });
    }
    return x;
} //# sourceMappingURL=conjugateGradient.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/layout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bestInitialLayout": (()=>bestInitialLayout),
    "constrainedMDSLayout": (()=>constrainedMDSLayout),
    "disjointCluster": (()=>disjointCluster),
    "distanceFromIntersectArea": (()=>distanceFromIntersectArea),
    "getDistanceMatrices": (()=>getDistanceMatrices),
    "greedyLayout": (()=>greedyLayout),
    "lossFunction": (()=>lossFunction),
    "normalizeSolution": (()=>normalizeSolution),
    "scaleSolution": (()=>scaleSolution),
    "venn": (()=>venn)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$nelderMead$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/nelderMead.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/bisect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$conjugateGradient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/fmin/conjugateGradient.js [app-client] (ecmascript)");
;
;
function venn(areas, parameters) {
    parameters = parameters || {};
    parameters.maxIterations = parameters.maxIterations || 500;
    const initialLayout = parameters.initialLayout || bestInitialLayout;
    const loss = parameters.lossFunction || lossFunction;
    // add in missing pairwise areas as having 0 size
    areas = addMissingAreas(areas);
    // initial layout is done greedily
    const circles = initialLayout(areas, parameters);
    // transform x/y coordinates to a vector to optimize
    const initial = [], setids = [];
    let setid;
    for(setid in circles){
        // eslint-disable-next-line
        if (circles.hasOwnProperty(setid)) {
            initial.push(circles[setid].x);
            initial.push(circles[setid].y);
            setids.push(setid);
        }
    }
    // optimize initial layout from our loss function
    const solution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$nelderMead$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nelderMead"])(function(values) {
        const current = {};
        for(let i = 0; i < setids.length; ++i){
            const setid = setids[i];
            current[setid] = {
                x: values[2 * i],
                y: values[2 * i + 1],
                radius: circles[setid].radius
            };
        }
        return loss(current, areas);
    }, initial, parameters);
    // transform solution vector back to x/y points
    const positions = solution.x;
    for(let i = 0; i < setids.length; ++i){
        setid = setids[i];
        circles[setid].x = positions[2 * i];
        circles[setid].y = positions[2 * i + 1];
    }
    return circles;
}
const SMALL = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap) {
    // handle complete overlapped circles
    if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {
        return Math.abs(r1 - r2);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bisect"])(function(distance) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circleOverlap"])(r1, r2, distance) - overlap;
    }, 0, r1 + r2);
}
/** Missing pair-wise intersection area data can cause problems:
 treating as an unknown means that sets will be laid out overlapping,
 which isn't what people expect. To reflect that we want disjoint sets
 here, set the overlap to 0 for all missing pairwise set intersections */ function addMissingAreas(areas) {
    areas = areas.slice();
    // two circle intersections that aren't defined
    const ids = [], pairs = {};
    let i, j, a, b;
    for(i = 0; i < areas.length; ++i){
        const area = areas[i];
        if (area.sets.length == 1) {
            ids.push(area.sets[0]);
        } else if (area.sets.length == 2) {
            a = area.sets[0];
            b = area.sets[1];
            // @ts-ignore
            pairs[[
                a,
                b
            ]] = true;
            // @ts-ignore
            pairs[[
                b,
                a
            ]] = true;
        }
    }
    ids.sort((a, b)=>{
        return a > b ? 1 : -1;
    });
    for(i = 0; i < ids.length; ++i){
        a = ids[i];
        for(j = i + 1; j < ids.length; ++j){
            b = ids[j];
            // @ts-ignore
            if (!([
                a,
                b
            ] in pairs)) {
                areas.push({
                    sets: [
                        a,
                        b
                    ],
                    size: 0
                });
            }
        }
    }
    return areas;
}
function getDistanceMatrices(areas, sets, setids) {
    // initialize an empty distance matrix between all the points
    const distances = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zerosM"])(sets.length, sets.length), constraints = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zerosM"])(sets.length, sets.length);
    // compute required distances between all the sets such that
    // the areas match
    areas.filter(function(x) {
        return x.sets.length == 2;
    }).map(function(current) {
        const left = setids[current.sets[0]], right = setids[current.sets[1]], r1 = Math.sqrt(sets[left].size / Math.PI), r2 = Math.sqrt(sets[right].size / Math.PI), distance = distanceFromIntersectArea(r1, r2, current.size);
        distances[left][right] = distances[right][left] = distance;
        // also update constraints to indicate if its a subset or disjoint
        // relationship
        let c = 0;
        if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {
            c = 1;
        } else if (current.size <= 1e-10) {
            c = -1;
        }
        constraints[left][right] = constraints[right][left] = c;
    });
    return {
        distances: distances,
        constraints: constraints
    };
}
/// computes the gradient and loss simulatenously for our constrained MDS optimizer
function constrainedMDSGradient(x, fxprime, distances, constraints) {
    let loss = 0, i;
    for(i = 0; i < fxprime.length; ++i){
        fxprime[i] = 0;
    }
    for(i = 0; i < distances.length; ++i){
        const xi = x[2 * i], yi = x[2 * i + 1];
        for(let j = i + 1; j < distances.length; ++j){
            const xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
            const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
            if (constraint > 0 && distance <= dij || constraint < 0 && distance >= dij) {
                continue;
            }
            loss += 2 * delta * delta;
            fxprime[2 * i] += 4 * delta * (xi - xj);
            fxprime[2 * i + 1] += 4 * delta * (yi - yj);
            fxprime[2 * j] += 4 * delta * (xj - xi);
            fxprime[2 * j + 1] += 4 * delta * (yj - yi);
        }
    }
    return loss;
}
function bestInitialLayout(areas, params) {
    let initial = greedyLayout(areas, params);
    const loss = params.lossFunction || lossFunction;
    // greedylayout is sufficient for all 2/3 circle cases. try out
    // constrained MDS for higher order problems, take its output
    // if it outperforms. (greedy is aesthetically better on 2/3 circles
    // since it axis aligns)
    if (areas.length >= 8) {
        const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
        if (constrainedLoss + 1e-8 < greedyLoss) {
            initial = constrained;
        }
    }
    return initial;
}
function constrainedMDSLayout(areas, params) {
    params = params || {};
    const restarts = params.restarts || 10;
    // bidirectionally map sets to a rowid  (so we can create a matrix)
    const sets = [], setids = {};
    let i;
    for(i = 0; i < areas.length; ++i){
        const area = areas[i];
        if (area.sets.length == 1) {
            setids[area.sets[0]] = sets.length;
            sets.push(area);
        }
    }
    const matrices = getDistanceMatrices(areas, sets, setids);
    let distances = matrices.distances;
    const constraints = matrices.constraints;
    // keep distances bounded, things get messed up otherwise.
    // TODO: proper preconditioner?
    const norm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["norm2"])(distances.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["norm2"])) / distances.length;
    distances = distances.map(function(row) {
        return row.map(function(value) {
            return value / norm;
        });
    });
    const obj = function(x, fxprime) {
        return constrainedMDSGradient(x, fxprime, distances, constraints);
    };
    let best, current;
    for(i = 0; i < restarts; ++i){
        const initial = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zeros"])(distances.length * 2).map(Math.random);
        current = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$conjugateGradient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conjugateGradient"])(obj, initial, params);
        if (!best || current.fx < best.fx) {
            best = current;
        }
    }
    const positions = best.x;
    // translate rows back to (x,y,radius) coordinates
    const circles = {};
    for(i = 0; i < sets.length; ++i){
        const set = sets[i];
        circles[set.sets[0]] = {
            x: positions[2 * i] * norm,
            y: positions[2 * i + 1] * norm,
            radius: Math.sqrt(set.size / Math.PI)
        };
    }
    if (params.history) {
        for(i = 0; i < params.history.length; ++i){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$fmin$2f$blas1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(params.history[i].x, norm);
        }
    }
    return circles;
}
function greedyLayout(areas, params) {
    const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
    // define a circle for each set
    const circles = {}, setOverlaps = {};
    let set;
    for(let i = 0; i < areas.length; ++i){
        const area = areas[i];
        if (area.sets.length == 1) {
            set = area.sets[0];
            circles[set] = {
                x: 1e10,
                y: 1e10,
                // rowid: circles.length, // fix to ->
                rowid: Object.keys(circles).length,
                size: area.size,
                radius: Math.sqrt(area.size / Math.PI)
            };
            setOverlaps[set] = [];
        }
    }
    areas = areas.filter(function(a) {
        return a.sets.length == 2;
    });
    // map each set to a list of all the other sets that overlap it
    for(let i = 0; i < areas.length; ++i){
        const current = areas[i];
        // eslint-disable-next-line
        let weight = current.hasOwnProperty('weight') ? current.weight : 1.0;
        const left = current.sets[0], right = current.sets[1];
        // completely overlapped circles shouldn't be positioned early here
        if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {
            weight = 0;
        }
        setOverlaps[left].push({
            set: right,
            size: current.size,
            weight: weight
        });
        setOverlaps[right].push({
            set: left,
            size: current.size,
            weight: weight
        });
    }
    // get list of most overlapped sets
    const mostOverlapped = [];
    for(set in setOverlaps){
        // eslint-disable-next-line
        if (setOverlaps.hasOwnProperty(set)) {
            let size = 0;
            for(let i = 0; i < setOverlaps[set].length; ++i){
                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;
            }
            mostOverlapped.push({
                set: set,
                size: size
            });
        }
    }
    // sort by size desc
    function sortOrder(a, b) {
        return b.size - a.size;
    }
    mostOverlapped.sort(sortOrder);
    // keep track of what sets have been laid out
    const positioned = {};
    function isPositioned(element) {
        return element.set in positioned;
    }
    // adds a point to the output
    function positionSet(point, index) {
        circles[index].x = point.x;
        circles[index].y = point.y;
        positioned[index] = true;
    }
    // add most overlapped set at (0,0)
    positionSet({
        x: 0,
        y: 0
    }, mostOverlapped[0].set);
    // get distances between all points. TODO, necessary?
    // answer: probably not
    // var distances = venn.getDistanceMatrices(circles, areas).distances;
    for(let i = 1; i < mostOverlapped.length; ++i){
        const setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
        set = circles[setIndex];
        overlap.sort(sortOrder);
        if (overlap.length === 0) {
            // this shouldn't happen anymore with addMissingAreas
            throw 'ERROR: missing pairwise overlap information';
        }
        const points = [];
        for(let j = 0; j < overlap.length; ++j){
            // get appropriate distance from most overlapped already added set
            const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);
            // sample positions at 90 degrees for maximum aesthetics
            points.push({
                x: p1.x + d1,
                y: p1.y
            });
            points.push({
                x: p1.x - d1,
                y: p1.y
            });
            points.push({
                y: p1.y + d1,
                x: p1.x
            });
            points.push({
                y: p1.y - d1,
                x: p1.x
            });
            // if we have at least 2 overlaps, then figure out where the
            // set should be positioned analytically and try those too
            for(let k = j + 1; k < overlap.length; ++k){
                const p2 = circles[overlap[k].set], d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);
                const extraPoints = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circleCircleIntersection"])({
                    x: p1.x,
                    y: p1.y,
                    radius: d1
                }, {
                    x: p2.x,
                    y: p2.y,
                    radius: d2
                });
                for(let l = 0; l < extraPoints.length; ++l){
                    points.push(extraPoints[l]);
                }
            }
        }
        // we have some candidate positions for the set, examine loss
        // at each position to figure out where to put it at
        let bestLoss = 1e50, bestPoint = points[0];
        for(let j = 0; j < points.length; ++j){
            circles[setIndex].x = points[j].x;
            circles[setIndex].y = points[j].y;
            const localLoss = loss(circles, areas);
            if (localLoss < bestLoss) {
                bestLoss = localLoss;
                bestPoint = points[j];
            }
        }
        positionSet(bestPoint, setIndex);
    }
    return circles;
}
function lossFunction(sets, overlaps) {
    let output = 0;
    function getCircles(indices) {
        return indices.map(function(i) {
            return sets[i];
        });
    }
    for(let i = 0; i < overlaps.length; ++i){
        const area = overlaps[i];
        let overlap;
        if (area.sets.length == 1) {
            continue;
        } else if (area.sets.length == 2) {
            const left = sets[area.sets[0]], right = sets[area.sets[1]];
            overlap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circleOverlap"])(left.radius, right.radius, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(left, right));
        } else {
            overlap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersectionArea"])(getCircles(area.sets));
        }
        // eslint-disable-next-line
        const weight = area.hasOwnProperty('weight') ? area.weight : 1.0;
        output += weight * (overlap - area.size) * (overlap - area.size);
    }
    return output;
}
// orientates a bunch of circles to point in orientation
function orientateCircles(circles, orientation, orientationOrder) {
    if (orientationOrder === null) {
        circles.sort(function(a, b) {
            return b.radius - a.radius;
        });
    } else {
        circles.sort(orientationOrder);
    }
    let i;
    // shift circles so largest circle is at (0, 0)
    if (circles.length > 0) {
        const largestX = circles[0].x, largestY = circles[0].y;
        for(i = 0; i < circles.length; ++i){
            circles[i].x -= largestX;
            circles[i].y -= largestY;
        }
    }
    if (circles.length == 2) {
        // if the second circle is a subset of the first, arrange so that
        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120
        const dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(circles[0], circles[1]);
        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {
            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;
            circles[1].y = circles[0].y;
        }
    }
    // rotate circles so that second largest is at an angle of 'orientation'
    // from largest
    if (circles.length > 1) {
        const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;
        let x, y;
        const c = Math.cos(rotation), s = Math.sin(rotation);
        for(i = 0; i < circles.length; ++i){
            x = circles[i].x;
            y = circles[i].y;
            circles[i].x = c * x - s * y;
            circles[i].y = s * x + c * y;
        }
    }
    // mirror solution if third solution is above plane specified by
    // first two circles
    if (circles.length > 2) {
        let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;
        while(angle < 0){
            angle += 2 * Math.PI;
        }
        while(angle > 2 * Math.PI){
            angle -= 2 * Math.PI;
        }
        if (angle > Math.PI) {
            const slope = circles[1].y / (1e-10 + circles[1].x);
            for(i = 0; i < circles.length; ++i){
                const d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);
                circles[i].x = 2 * d - circles[i].x;
                circles[i].y = 2 * d * slope - circles[i].y;
            }
        }
    }
}
function disjointCluster(circles) {
    // union-find clustering to get disjoint sets
    circles.map(function(circle) {
        circle.parent = circle;
    });
    // path compression step in union find
    function find(circle) {
        if (circle.parent !== circle) {
            circle.parent = find(circle.parent);
        }
        return circle.parent;
    }
    function union(x, y) {
        const xRoot = find(x), yRoot = find(y);
        xRoot.parent = yRoot;
    }
    // get the union of all overlapping sets
    for(let i = 0; i < circles.length; ++i){
        for(let j = i + 1; j < circles.length; ++j){
            const maxDistance = circles[i].radius + circles[j].radius;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(circles[i], circles[j]) + 1e-10 < maxDistance) {
                union(circles[j], circles[i]);
            }
        }
    }
    // find all the disjoint clusters and group them together
    const disjointClusters = {};
    let setid;
    for(let i = 0; i < circles.length; ++i){
        setid = find(circles[i]).parent.setid;
        if (!(setid in disjointClusters)) {
            disjointClusters[setid] = [];
        }
        disjointClusters[setid].push(circles[i]);
    }
    // cleanup bookkeeping
    circles.map(function(circle) {
        delete circle.parent;
    });
    // return in more usable form
    const ret = [];
    for(setid in disjointClusters){
        // eslint-disable-next-line
        if (disjointClusters.hasOwnProperty(setid)) {
            ret.push(disjointClusters[setid]);
        }
    }
    return ret;
}
function getBoundingBox(circles) {
    const minMax = function(d) {
        const hi = Math.max.apply(null, circles.map(function(c) {
            return c[d] + c.radius;
        })), lo = Math.min.apply(null, circles.map(function(c) {
            return c[d] - c.radius;
        }));
        return {
            max: hi,
            min: lo
        };
    };
    return {
        xRange: minMax('x'),
        yRange: minMax('y')
    };
}
function normalizeSolution(solution, orientation, orientationOrder) {
    if (orientation === null) {
        orientation = Math.PI / 2;
    }
    // work with a list instead of a dictionary, and take a copy so we
    // don't mutate input
    let circles = [], i, setid;
    for(setid in solution){
        // eslint-disable-next-line
        if (solution.hasOwnProperty(setid)) {
            const previous = solution[setid];
            circles.push({
                x: previous.x,
                y: previous.y,
                radius: previous.radius,
                setid: setid
            });
        }
    }
    // get all the disjoint clusters
    const clusters = disjointCluster(circles);
    // orientate all disjoint sets, get sizes
    for(i = 0; i < clusters.length; ++i){
        orientateCircles(clusters[i], orientation, orientationOrder);
        const bounds = getBoundingBox(clusters[i]);
        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);
        clusters[i].bounds = bounds;
    }
    clusters.sort(function(a, b) {
        return b.size - a.size;
    });
    // orientate the largest at 0,0, and get the bounds
    circles = clusters[0];
    // @ts-ignore fixme 从逻辑上看似乎是不对的，后续看看
    let returnBounds = circles.bounds;
    const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;
    function addCluster(cluster, right, bottom) {
        if (!cluster) return;
        const bounds = cluster.bounds;
        let xOffset, yOffset, centreing;
        if (right) {
            xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;
        } else {
            xOffset = returnBounds.xRange.max - bounds.xRange.max;
            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;
            if (centreing < 0) xOffset += centreing;
        }
        if (bottom) {
            yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;
        } else {
            yOffset = returnBounds.yRange.max - bounds.yRange.max;
            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;
            if (centreing < 0) yOffset += centreing;
        }
        for(let j = 0; j < cluster.length; ++j){
            cluster[j].x += xOffset;
            cluster[j].y += yOffset;
            circles.push(cluster[j]);
        }
    }
    let index = 1;
    while(index < clusters.length){
        addCluster(clusters[index], true, false);
        addCluster(clusters[index + 1], false, true);
        addCluster(clusters[index + 2], true, true);
        index += 3;
        // have one cluster (in top left). lay out next three relative
        // to it in a grid
        returnBounds = getBoundingBox(circles);
    }
    // convert back to solution form
    const ret = {};
    for(i = 0; i < circles.length; ++i){
        ret[circles[i].setid] = circles[i];
    }
    return ret;
}
function scaleSolution(solution, width, height, padding) {
    const circles = [], setids = [];
    for(const setid in solution){
        // eslint-disable-next-line
        if (solution.hasOwnProperty(setid)) {
            setids.push(setid);
            circles.push(solution[setid]);
        }
    }
    width -= 2 * padding;
    height -= 2 * padding;
    const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
    if (xRange.max == xRange.min || yRange.max == yRange.min) {
        console.log('not scaling solution: zero size detected');
        return solution;
    }
    const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), // while we're at it, center the diagram too
    xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
    const scaled = {};
    for(let i = 0; i < circles.length; ++i){
        const circle = circles[i];
        scaled[setids[i]] = {
            radius: scaling * circle.radius,
            x: padding + xOffset + (circle.x - xRange.min) * scaling,
            y: padding + yOffset + (circle.y - yRange.min) * scaling
        };
    }
    return scaled;
} //# sourceMappingURL=layout.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/venn/diagram.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "intersectionAreaPath": (()=>intersectionAreaPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js [app-client] (ecmascript)");
;
/**
 * 根据圆心(x, y) 半径 r 返回圆的绘制 path
 * @param x 圆心点 x
 * @param y 圆心点 y
 * @param r 圆的半径
 * @returns 圆的 path
 */ function circlePath(x, y, r) {
    const ret = [];
    // ret.push('\nM', x, y);
    // ret.push('\nm', -r, 0);
    // ret.push('\na', r, r, 0, 1, 0, r * 2, 0);
    // ret.push('\na', r, r, 0, 1, 0, -r * 2, 0);
    const x0 = x - r;
    const y0 = y;
    ret.push('M', x0, y0);
    ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);
    ret.push('A', r, r, 0, 1, 0, x0, y0);
    return ret.join(' ');
}
function intersectionAreaPath(circles) {
    const stats = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$circleintersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersectionArea"])(circles, stats);
    const arcs = stats.arcs;
    if (arcs.length === 0) {
        return 'M 0 0';
    } else if (arcs.length == 1) {
        const circle = arcs[0].circle;
        return circlePath(circle.x, circle.y, circle.radius);
    } else {
        // draw path around arcs
        const ret = [
            '\nM',
            arcs[0].p2.x,
            arcs[0].p2.y
        ];
        for(let i = 0; i < arcs.length; ++i){
            const arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
            ret.push('\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
        }
        return ret.join(' ');
    }
} //# sourceMappingURL=diagram.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/venn.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Venn": (()=>Venn)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/venn/diagram.js [app-client] (ecmascript)");
;
const Venn = (options)=>{
    const { sets = 'sets', size = 'size', as = [
        'key',
        'path'
    ], padding = 0 } = options;
    const [key, path] = as;
    return (data)=>{
        // Transform the data, venn layout use `sets` and `size` field.
        const vennData = data.map((d)=>Object.assign(Object.assign({}, d), {
                sets: d[sets],
                size: d[size],
                [key]: d.sets.join('&')
            }));
        // Sort data, avoid data occlusion.
        vennData.sort((a, b)=>a.sets.length - b.sets.length);
        // Layout venn data.
        const solution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["venn"])(vennData);
        let circles;
        return vennData.map((datum)=>{
            const setsValue = datum[sets];
            const pathFunc = ({ width, height })=>{
                circles = circles ? circles : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scaleSolution"])(solution, width, height, padding);
                const setCircles = setsValue.map((set)=>circles[set]);
                let p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$venn$2f$diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersectionAreaPath"])(setCircles);
                // Close the path for event picker.
                if (!/[zZ]$/.test(p)) p += ' Z';
                return p;
            };
            return Object.assign(Object.assign({}, datum), {
                [path]: pathFunc
            });
        });
    };
};
Venn.props = {}; //# sourceMappingURL=venn.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/fetch.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Fetch": (()=>Fetch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$dsv$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-dsv.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$dsv$2f$src$2f$dsv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__dsvFormat$3e$__ = __turbopack_import__("[project]/node_modules/d3-dsv/src/dsv.js [app-client] (ecmascript) <export default as dsvFormat>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$dsv$2f$src$2f$autoType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__autoType$3e$__ = __turbopack_import__("[project]/node_modules/d3-dsv/src/autoType.js [app-client] (ecmascript) <export default as autoType>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
const Fetch = (options)=>{
    const { value, format = value.split('.').pop(), delimiter = ',', autoType = true } = options;
    return ()=>__awaiter(void 0, void 0, void 0, function*() {
            const response = yield fetch(value);
            if (format === 'csv') {
                // @see: https://github.com/d3/d3-dsv#dsv_parse
                const str = yield response.text();
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$dsv$2f$src$2f$dsv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__dsvFormat$3e$__["dsvFormat"])(delimiter).parse(str, autoType ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$dsv$2f$src$2f$autoType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__autoType$3e$__["autoType"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"]);
            }
            if (format === 'json') {
                return yield response.json();
            }
            throw new Error(`Unknown format: ${format}.`);
        });
};
Fetch.props = {}; //# sourceMappingURL=fetch.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/inline.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Inline": (()=>Inline)
});
const Inline = (options)=>{
    const { value } = options;
    return ()=>value;
};
Inline.props = {}; //# sourceMappingURL=inline.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/fields.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 *
 * @description Converts a random format array into a regular two-dimensional array
 * @example ['a', 'b', ['c', value]] => [['a', defaultValue], ['b', defaultValue], ['c', value]]
 */ __turbopack_esm__({
    "normalizeFields": (()=>normalizeFields)
});
function normalizeFields(fields, defaultValue) {
    return fields.map((d)=>{
        if (Array.isArray(d)) {
            const [field, value = defaultValue] = d;
            return [
                field,
                value
            ];
        }
        return [
            d,
            defaultValue
        ];
    });
} //# sourceMappingURL=fields.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/sortBy.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SortBy": (()=>SortBy)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$fields$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/fields.js [app-client] (ecmascript)");
;
const SortBy = (options)=>{
    const { fields: F = [] } = options;
    const normalizedF = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$fields$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeFields"])(F, true);
    return (data)=>{
        const comparator = (a, b)=>normalizedF.reduce((ret, [field, order = true])=>{
                if (ret !== 0) {
                    return ret;
                }
                if (order) {
                    return a[field] < b[field] ? -1 : +(a[field] !== b[field]);
                } else {
                    return a[field] > b[field] ? -1 : +(a[field] !== b[field]);
                }
            }, 0);
        return [
            ...data
        ].sort(comparator);
    };
};
SortBy.props = {}; //# sourceMappingURL=sortBy.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/sort.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Sort": (()=>Sort),
    "defined": (()=>defined)
});
function defined(d) {
    return d !== undefined && d !== null && !Number.isNaN(d);
}
const Sort = (options)=>{
    const { callback } = options;
    return (data)=>Array.isArray(data) ? [
            ...data
        ].sort(callback) : data;
};
Sort.props = {}; //# sourceMappingURL=sort.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/filter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Filter": (()=>Filter),
    "defined": (()=>defined)
});
function defined(d) {
    return d !== undefined && d !== null && !Number.isNaN(d);
}
const Filter = (options)=>{
    const { callback = defined } = options;
    return (data)=>data.filter(callback);
};
Filter.props = {}; //# sourceMappingURL=filter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/pick.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Pick": (()=>Pick)
});
function pick(v, fields = []) {
    return fields.reduce((datum, field)=>{
        // Pick the data deeply.
        if (field in v) {
            datum[field] = v[field];
        }
        return datum;
    }, {});
}
const Pick = (options)=>{
    const { fields } = options;
    return (data)=>data.map((d)=>pick(d, fields));
};
Pick.props = {}; //# sourceMappingURL=pick.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/rename.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Rename": (()=>Rename),
    "isEmpty": (()=>isEmpty)
});
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
const Rename = (options)=>{
    return (data)=>{
        if (!options || isEmpty(options)) return data;
        const rename = (v)=>Object.entries(v).reduce((datum, [key, value])=>(datum[options[key] || key] = value, datum), {});
        return data.map(rename);
    };
};
Rename.props = {}; //# sourceMappingURL=rename.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/fold.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Fold": (()=>Fold),
    "isEmpty": (()=>isEmpty)
});
function isEmpty(obj) {
    return !obj || Object.keys(obj).length === 0;
}
const Fold = (options)=>{
    const { fields, key = 'key', value = 'value' } = options;
    return (data)=>{
        if (isEmpty(fields)) return data;
        return data.flatMap((d)=>fields.map((f)=>Object.assign(Object.assign({}, d), {
                    [key]: f,
                    [value]: d[f]
                })));
    };
};
Fold.props = {}; //# sourceMappingURL=fold.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/slice.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Slice data between `start` ~ `end`.
 * Same with https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
 */ __turbopack_esm__({
    "Slice": (()=>Slice)
});
const Slice = (options)=>{
    const { start, end } = options;
    return (data)=>data.slice(start, end);
};
Slice.props = {}; //# sourceMappingURL=slice.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/custom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Custom": (()=>Custom)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
;
const Custom = (options)=>{
    const { callback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"] } = options;
    return (data)=>callback(data);
};
Custom.props = {}; //# sourceMappingURL=custom.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/map.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Map": (()=>Map)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
;
const Map = (options)=>{
    const { callback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"] } = options;
    return (data)=>Array.isArray(data) ? data.map(callback) : data;
};
Map.props = {}; //# sourceMappingURL=map.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/join.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Join": (()=>Join)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
;
function field(key) {
    return typeof key === 'string' ? (d)=>d[key] : key;
}
const Join = (options)=>{
    // const { fromKey, from, key, unknown = NaN, ...rest } = options;
    const { join, on, select = [], as = select, unknown = NaN } = options;
    const [key, fromKey] = on;
    const fk = field(fromKey);
    const k = field(key);
    const keyData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rollup"])(join, ([d])=>d, (d)=>fk(d));
    return (data)=>data.map((d)=>{
            const source = keyData.get(k(d));
            return Object.assign(Object.assign({}, d), select.reduce((prev, key, idx)=>(prev[as[idx]] = source ? source[key] : unknown, prev), {}));
        });
};
Join.props = {}; //# sourceMappingURL=join.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/kde.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "KDE": (()=>KDE),
    "defined": (()=>defined)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdfast$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/pdfast/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
;
;
function defined(d) {
    return d !== undefined && d !== null && !Number.isNaN(d);
}
const KDE = (options)=>{
    const { field, groupBy, as = [
        'y',
        'size'
    ], min, max, size = 10, width } = options;
    const [yField, sizeField] = as;
    return (data)=>{
        const gs = Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(data, (d)=>groupBy.map((gb)=>d[gb]).join('-')).values());
        return gs.map((g)=>{
            const pdfResult = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdfast$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].create(g.map((i)=>i[field]), {
                min,
                max,
                size,
                width
            });
            const _y = pdfResult.map((result)=>result.x);
            const _size = pdfResult.map((result)=>result.y);
            return Object.assign(Object.assign({}, g[0]), {
                [yField]: _y,
                [sizeField]: _size
            });
        });
    };
};
KDE.props = {}; //# sourceMappingURL=kde.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/log.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Console.log the data section for dev debugger.
 */ __turbopack_esm__({
    "Log": (()=>Log)
});
const Log = ()=>{
    return (data)=>{
        console.log('G2 data section:', data);
        return data;
    };
};
Log.props = {}; //# sourceMappingURL=log.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "tagCloud": (()=>tagCloud)
});
const cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
function cloudText(d) {
    return d.text;
}
function cloudFont() {
    return 'serif';
}
function cloudFontNormal() {
    return 'normal';
}
function cloudFontSize(d) {
    return d.value;
}
function cloudRotate() {
    return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
    return 1;
}
function cloudDispatch() {
    return;
}
// Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.
function cloudSprite(contextAndRatio, d, data, di) {
    if (d.sprite) return;
    const c = contextAndRatio.context, ratio = contextAndRatio.ratio;
    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
    let x = 0, y = 0, maxh = 0;
    const n = data.length;
    --di;
    while(++di < n){
        d = data[di];
        c.save();
        c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
        let w = c.measureText(d.text + 'm').width * ratio, h = d.size << 1;
        if (d.rotate) {
            const sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
            w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
            h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
        } else {
            w = w + 0x1f >> 5 << 5;
        }
        if (h > maxh) maxh = h;
        if (x + w >= cw << 5) {
            x = 0;
            y += maxh;
            maxh = 0;
        }
        if (y + h >= ch) break;
        c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
        if (d.rotate) c.rotate(d.rotate * cloudRadians);
        c.fillText(d.text, 0, 0);
        if (d.padding) {
            c.lineWidth = 2 * d.padding;
            c.strokeText(d.text, 0, 0);
        }
        c.restore();
        d.width = w;
        d.height = h;
        d.xoff = x;
        d.yoff = y;
        d.x1 = w >> 1;
        d.y1 = h >> 1;
        d.x0 = -d.x1;
        d.y0 = -d.y1;
        d.hasText = true;
        x += w;
    }
    const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
    while(--di >= 0){
        d = data[di];
        if (!d.hasText) continue;
        const w = d.width, w32 = w >> 5;
        let h = d.y1 - d.y0;
        // Zero the buffer
        for(let i = 0; i < h * w32; i++)sprite[i] = 0;
        x = d.xoff;
        if (x == null) return;
        y = d.yoff;
        let seen = 0, seenRow = -1;
        for(let j = 0; j < h; j++){
            for(let i = 0; i < w; i++){
                const k = w32 * j + (i >> 5), m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
                sprite[k] |= m;
                seen |= m;
            }
            if (seen) seenRow = j;
            else {
                d.y0++;
                h--;
                j--;
                y++;
            }
        }
        d.y1 = d.y0 + seenRow;
        d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
    }
}
// Use mask-based collision detection.
function cloudCollide(tag, board, sw) {
    sw >>= 5;
    const sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;
    let x = (tag.y + tag.y0) * sw + (lx >> 5), last;
    for(let j = 0; j < h; j++){
        last = 0;
        for(let i = 0; i <= w; i++){
            if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
        }
        x += sw;
    }
    return false;
}
function cloudBounds(bounds, d) {
    const b0 = bounds[0], b1 = bounds[1];
    if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
    if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
    if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
    if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}
function collideRects(a, b) {
    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size) {
    const e = size[0] / size[1];
    return function(t) {
        return [
            e * (t *= 0.1) * Math.cos(t),
            t * Math.sin(t)
        ];
    };
}
function rectangularSpiral(size) {
    const dy = 4, dx = dy * size[0] / size[1];
    let x = 0, y = 0;
    return function(t) {
        const sign = t < 0 ? -1 : 1;
        // See triangular numbers: T_n = n * (n + 1) / 2.
        switch(Math.sqrt(1 + 4 * sign * t) - sign & 3){
            case 0:
                x += dx;
                break;
            case 1:
                y += dy;
                break;
            case 2:
                x -= dx;
                break;
            default:
                y -= dy;
                break;
        }
        return [
            x,
            y
        ];
    };
}
// TODO reuse arrays?
function zeroArray(n) {
    const a = [];
    let i = -1;
    while(++i < n)a[i] = 0;
    return a;
}
function cloudCanvas() {
    return document.createElement('canvas');
}
function functor(d) {
    return typeof d === 'function' ? d : function() {
        return d;
    };
}
const spirals = {
    archimedean: archimedeanSpiral,
    rectangular: rectangularSpiral
};
function tagCloud() {
    let size = [
        256,
        256
    ], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random = Math.random, event = cloudDispatch, words = [], timer = null, timeInterval = Infinity, canvas = cloudCanvas;
    const fontStyle = cloudFontNormal;
    const cloud = {};
    cloud.start = function() {
        const [width, height] = size;
        const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]), n = words.length, tags = [], data = words.map(function(d, i, data) {
            d.text = text.call(this, d, i, data);
            d.font = font.call(this, d, i, data);
            d.style = fontStyle.call(this, d, i, data);
            d.weight = fontWeight.call(this, d, i, data);
            d.rotate = rotate.call(this, d, i, data);
            d.size = ~~fontSize.call(this, d, i, data);
            d.padding = padding.call(this, d, i, data);
            return d;
        }).sort(function(a, b) {
            return b.size - a.size;
        });
        let i = -1, bounds = !cloud.board ? undefined : [
            {
                x: 0,
                y: 0
            },
            {
                x: width,
                y: height
            }
        ];
        if (timer) clearInterval(timer);
        timer = setInterval(step, 0);
        step();
        function step() {
            const start = Date.now();
            while(Date.now() - start < timeInterval && ++i < n){
                const d = data[i];
                d.x = width * (random() + 0.5) >> 1;
                d.y = height * (random() + 0.5) >> 1;
                cloudSprite(contextAndRatio, d, data, i);
                if (d.hasText && place(board, d, bounds)) {
                    event.call(null, 'word', {
                        cloud,
                        word: d
                    });
                    tags.push(d);
                    if (bounds) {
                        if (!cloud.hasImage) {
                            // update bounds if image mask not set
                            cloudBounds(bounds, d);
                        }
                    } else {
                        bounds = [
                            {
                                x: d.x + d.x0,
                                y: d.y + d.y0
                            },
                            {
                                x: d.x + d.x1,
                                y: d.y + d.y1
                            }
                        ];
                    }
                    // Temporary hack
                    d.x -= size[0] >> 1;
                    d.y -= size[1] >> 1;
                }
            }
            cloud._tags = tags;
            cloud._bounds = bounds;
            if (i >= n) {
                cloud.stop();
                event.call(null, 'end', {
                    cloud,
                    words: tags,
                    bounds
                });
            }
        }
        return cloud;
    };
    cloud.stop = function() {
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
        return cloud;
    };
    function getContext(canvas) {
        canvas.width = canvas.height = 1;
        const ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
        canvas.width = (cw << 5) / ratio;
        canvas.height = ch / ratio;
        const context = canvas.getContext('2d');
        context.fillStyle = context.strokeStyle = 'red';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        return {
            context,
            ratio
        };
    }
    function place(board, tag, bounds) {
        // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],
        const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random() < 0.5 ? 1 : -1;
        let dxdy, t = -dt, dx, dy;
        while(dxdy = s(t += dt)){
            dx = ~~dxdy[0];
            dy = ~~dxdy[1];
            if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
            tag.x = startX + dx;
            tag.y = startY + dy;
            if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
            // TODO only check for collisions within current bounds.
            if (!bounds || !cloudCollide(tag, board, size[0])) {
                if (!bounds || collideRects(tag, bounds)) {
                    const sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;
                    let last, x = (tag.y + tag.y0) * sw + (lx >> 5);
                    for(let j = 0; j < h; j++){
                        last = 0;
                        for(let i = 0; i <= w; i++){
                            board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                        }
                        x += sw;
                    }
                    delete tag.sprite;
                    return true;
                }
            }
        }
        return false;
    }
    cloud.createMask = (img)=>{
        const can = document.createElement('canvas');
        const [width, height] = size;
        // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错
        if (!width || !height) {
            return;
        }
        const w32 = width >> 5;
        const board = zeroArray((width >> 5) * height);
        can.width = width;
        can.height = height;
        const cxt = can.getContext('2d');
        cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
        const imageData = cxt.getImageData(0, 0, width, height).data;
        for(let j = 0; j < height; j++){
            for(let i = 0; i < width; i++){
                const k = w32 * j + (i >> 5);
                const tmp = j * width + i << 2;
                const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
                const m = flag ? 1 << 31 - i % 32 : 0;
                board[k] |= m;
            }
        }
        cloud.board = board;
        cloud.hasImage = true;
    };
    cloud.timeInterval = function(_) {
        timeInterval = _ == null ? Infinity : _;
    };
    cloud.words = function(_) {
        words = _;
    };
    cloud.size = function(_ = []) {
        size = [
            +_[0],
            +_[1]
        ];
    };
    cloud.text = function(_) {
        text = functor(_);
    };
    cloud.font = function(_) {
        font = functor(_);
    };
    cloud.fontWeight = function(_) {
        fontWeight = functor(_);
    };
    cloud.rotate = function(_) {
        rotate = functor(_);
    };
    cloud.canvas = function(_) {
        canvas = functor(_);
    };
    cloud.spiral = function(_) {
        spiral = spirals[_] || _;
    };
    cloud.fontSize = function(_) {
        fontSize = functor(_);
    };
    cloud.padding = function(_) {
        padding = functor(_);
    };
    cloud.random = function(_) {
        random = functor(_);
    };
    cloud.on = function(_) {
        event = functor(_);
    };
    return cloud;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/utils/flow.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "flow": (()=>flow)
});
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function flow(target, source) {
    return {
        set (key, normalize, callback) {
            if (source[key] === undefined) return this;
            const value = normalize ? normalize.call(null, source[key]) : source[key];
            if (callback) callback.call(null, value);
            else if (typeof target[key] === 'function') target[key](value);
            else target[key] = value;
            return this;
        },
        setAsync (key, normalize, callback) {
            return __awaiter(this, void 0, void 0, function*() {
                if (source[key] === undefined) return this;
                const value = normalize ? yield normalize.call(null, source[key]) : source[key];
                if (callback) callback.call(null, value);
                else if (typeof target[key] === 'function') target[key](value);
                else target[key] = value;
                return this;
            });
        }
    };
} //# sourceMappingURL=flow.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/wordCloud.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "WordCloud": (()=>WordCloud),
    "normalizeFontSize": (()=>normalizeFontSize),
    "processImageMask": (()=>processImageMask)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$cloud$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$flow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/data/utils/flow.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript) <export default as min>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
const DEFAULT_OPTIONS = {
    fontSize: [
        20,
        60
    ],
    font: 'Impact',
    padding: 2,
    rotate: function() {
        return (~~(Math.random() * 6) - 3) * 30;
    }
};
function processImageMask(img) {
    return new Promise((res, rej)=>{
        if (img instanceof HTMLImageElement) {
            res(img);
            return;
        }
        if (typeof img === 'string') {
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.src = img;
            image.onload = ()=>res(image);
            image.onerror = ()=>{
                console.error(`'image ${img} load failed !!!'`);
                rej();
            };
            return;
        }
        rej();
    });
}
function normalizeFontSize(fontSize, range) {
    if (typeof fontSize === 'function') return fontSize;
    if (Array.isArray(fontSize)) {
        const [fMin, fMax] = fontSize;
        if (!range) return ()=>(fMax + fMin) / 2;
        const [min, max] = range;
        if (max === min) return ()=>(fMax + fMin) / 2;
        return ({ value })=>(fMax - fMin) / (max - min) * (value - min) + fMin;
    }
    return ()=>fontSize;
}
const WordCloud = (options, context)=>{
    return (data)=>__awaiter(void 0, void 0, void 0, function*() {
            const cloudOptions = Object.assign({}, DEFAULT_OPTIONS, options, {
                canvas: context.createCanvas
            });
            const layout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$d3$2d$cloud$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tagCloud"])();
            yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$data$2f$utils$2f$flow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flow"])(layout, cloudOptions).set('fontSize', (v)=>{
                const arr = data.map((d)=>d.value);
                return normalizeFontSize(v, [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__["min"])(arr),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(arr)
                ]);
            }).set('font').set('fontStyle').set('fontWeight').set('padding').set('rotate').set('size').set('spiral').set('timeInterval').set('random').set('text').set('on').set('canvas').setAsync('imageMask', processImageMask, layout.createMask);
            layout.words([
                ...data
            ]);
            const result = layout.start();
            const [cw, ch] = cloudOptions.size;
            const defaultBounds = [
                {
                    x: 0,
                    y: 0
                },
                {
                    x: cw,
                    y: ch
                }
            ];
            const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
            const tags = _tags.map((_a)=>{
                var { x, y, font } = _a, rest = __rest(_a, [
                    "x",
                    "y",
                    "font"
                ]);
                return Object.assign(Object.assign({}, rest), {
                    x: x + cw / 2,
                    y: y + ch / 2,
                    fontFamily: font
                });
            });
            // Append two data to replace the corner of top-left and bottom-right, avoid calculate the actual bounds will occur some error.
            const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
            const invisibleText = {
                text: '',
                value: 0,
                opacity: 0,
                fontSize: 0
            };
            tags.push(Object.assign(Object.assign({}, invisibleText), {
                x: hasImage ? 0 : tlx,
                y: hasImage ? 0 : tly
            }), Object.assign(Object.assign({}, invisibleText), {
                x: hasImage ? cw : brx,
                y: hasImage ? ch : bry
            }));
            return tags;
        });
};
WordCloud.props = {}; //# sourceMappingURL=wordCloud.js.map
}}),
"[project]/node_modules/@antv/g2/esm/data/ema.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "EMA": (()=>EMA),
    "ema": (()=>ema)
});
function ema(values, alpha) {
    if (alpha < 0 || alpha > 1) {
        throw new Error('alpha must be between 0 and 1.');
    }
    if (values.length === 0) {
        return [];
    }
    let last = values[0];
    const smoothed = [];
    for (const point of values){
        if (point === null || point === undefined) {
            // 如果没有数据的话，使用最近的值
            smoothed.push(point);
            console.warn('EMA：The value is null or undefined', values);
            continue;
        }
        if (last === null || last === undefined) {
            last = point;
        }
        const smoothedVal = last * alpha + (1 - alpha) * point;
        smoothed.push(smoothedVal);
        last = smoothedVal;
    }
    return smoothed;
}
const EMA = (options)=>{
    const { field = 'y', alpha = 0.6, as = field } = options;
    return (data)=>{
        const values = data.map((d)=>{
            return d[field];
        });
        const out = ema(values, alpha);
        return data.map((d, i)=>{
            return Object.assign(Object.assign({}, d), {
                [as]: out[i]
            });
        });
    };
};
EMA.props = {}; //# sourceMappingURL=ema.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40antv_g2_esm_data_66e59a._.js.map