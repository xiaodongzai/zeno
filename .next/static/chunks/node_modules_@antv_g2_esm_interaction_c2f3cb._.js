(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@antv_g2_esm_interaction_c2f3cb._.js", {

"[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "VALID_FIND_BY_X_MARKS": (()=>VALID_FIND_BY_X_MARKS),
    "bboxOf": (()=>bboxOf),
    "boundsOfBrushArea": (()=>boundsOfBrushArea),
    "brushMousePosition": (()=>brushMousePosition),
    "calculateAllIndependentScaleInfo": (()=>calculateAllIndependentScaleInfo),
    "calculateMultiAxisChannelDomains": (()=>calculateMultiAxisChannelDomains),
    "calculateSensitivityMultiplier": (()=>calculateSensitivityMultiplier),
    "createColorKey": (()=>createColorKey),
    "createDatumof": (()=>createDatumof),
    "createFindElementByEvent": (()=>createFindElementByEvent),
    "createUseState": (()=>createUseState),
    "createValueof": (()=>createValueof),
    "createXKey": (()=>createXKey),
    "extractChannelValues": (()=>extractChannelValues),
    "getElements": (()=>getElements),
    "getPointsPath": (()=>getPointsPath),
    "getPointsR": (()=>getPointsR),
    "getThetaPath": (()=>getThetaPath),
    "hasIndependentXYScale": (()=>hasIndependentXYScale),
    "isFalsyValue": (()=>isFalsyValue),
    "maybeRoot": (()=>maybeRoot),
    "mergeState": (()=>mergeState),
    "mousePosition": (()=>mousePosition),
    "offsetTransform": (()=>offsetTransform),
    "renderBackground": (()=>renderBackground),
    "renderLink": (()=>renderLink),
    "restoreCursor": (()=>restoreCursor),
    "selectElementByData": (()=>selectElementByData),
    "selectFacetG2Elements": (()=>selectFacetG2Elements),
    "selectFacetViews": (()=>selectFacetViews),
    "selectG2Elements": (()=>selectG2Elements),
    "selectPlotArea": (()=>selectPlotArea),
    "setCursor": (()=>setCursor),
    "useState": (()=>useState)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-path.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$traverse$2d$elements$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/traverse-elements.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sort.js [app-client] (ecmascript) <export default as sort>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$path$2f$src$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-path/src/path.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/shape/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$interval$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/shape/interval/color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__filter$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/filter.js [app-client] (ecmascript) <export default as filter>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript) <export default as bisector>");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function selectG2Elements(root) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(root).selectAll(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]}`).nodes().filter((d)=>!d.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
    return selectFacetViews(target, viewInstances).flatMap(({ container })=>selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
    return viewInstances.filter((d)=>d !== target && d.options.parentKey === target.options.key);
}
function selectPlotArea(root) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(root).select(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"]}`).node();
}
function bboxOf(element) {
    // The geometry bounds of a group is empty, so return the render bounds.
    if (element.tagName === 'g') return element.getRenderBounds();
    // Compute the geometry bounds related to the parent.
    const bounds = element.getGeometryBounds();
    const aabb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AABB"]();
    aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
    return aabb;
}
function mousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const bbox = bboxOf(target);
    const { min: [x, y], max: [x1, y1] } = bbox;
    const isOutX = offsetX < x || offsetX > x1;
    const isOutY = offsetY < y || offsetY > y1;
    if (isOutX || isOutY) return null;
    return [
        offsetX - x,
        offsetY - y
    ];
}
function brushMousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const [x, y, x1, y1] = boundsOfBrushArea(target);
    return [
        Math.min(x1, Math.max(x, offsetX)) - x,
        Math.min(y1, Math.max(y, offsetY)) - y
    ];
}
function boundsOfBrushArea(target) {
    // Calc bbox after clipping.
    const bbox = target.getRenderBounds();
    const { min: [x0, y0], max: [x1, y1] } = bbox;
    return [
        x0,
        y0,
        x1,
        y1
    ];
}
function createColorKey(view) {
    return (element)=>element.__data__.color;
}
function createXKey(view) {
    return (element)=>element.__data__.x;
}
function createDatumof(view) {
    const views = Array.isArray(view) ? view : [
        view
    ];
    const keyData = new Map(views.flatMap((view)=>{
        const marks = Array.from(view.markState.keys());
        return marks.map((mark)=>[
                keyed(view.key, mark.key),
                mark.data
            ]);
    }));
    return (element)=>{
        const { index, markKey, viewKey } = element.__data__;
        const data = keyData.get(keyed(viewKey, markKey));
        return data[index];
    };
}
/**
 * A state manager for G2Element.
 * The keys for each state's style start with the state name.
 * { selectedFill, selectedStroke } is for selected state.
 * { unselectedFill, unselectedStroke } is for unselected state.
 */ /**
 * Define state priorities, higher number means higher priority.
 */ const STATE_PRIORITIES = {
    selected: 3,
    unselected: 3,
    active: 2,
    inactive: 2,
    default: 1
};
/**
 * Define state groups, states in the same group are mutually exclusive.
 */ const STATE_GROUPS = {
    selection: [
        'selected',
        'unselected'
    ],
    highlight: [
        'active',
        'inactive'
    ]
};
const setElementAttribute = (element, k, v)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$traverse$2d$elements$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverseElements"])(element, (el)=>{
        if ('setAttribute' in el && typeof el.setAttribute === 'function') {
            el.setAttribute(k, v);
        }
    });
};
function createUseState(style, elements) {
    // Apply interaction style to all elements.
    elements.forEach((element)=>{
        // @ts-ignore
        const currentStyle = element.__interactionStyle__;
        if (currentStyle) {
            // @ts-ignore
            element.__interactionStyle__ = Object.assign(Object.assign({}, currentStyle), style);
        } else {
            // @ts-ignore
            element.__interactionStyle__ = style;
        }
    });
    return (valueof = (d, element)=>d, setAttribute = setElementAttribute)=>useState(undefined, valueof, setAttribute);
}
function useState(style, valueof = (d, element)=>d, setAttribute = setElementAttribute) {
    const STATES = '__states__';
    const ORIGINAL = '__ordinal__';
    // Get state priority.
    const getStatePriority = (stateName)=>STATE_PRIORITIES[stateName] || STATE_PRIORITIES.default;
    // Get the group that a state belongs to.
    const getStateGroup = (stateName)=>{
        var _a;
        return (_a = Object.entries(STATE_GROUPS).find(([_, states])=>states.includes(stateName))) === null || _a === void 0 ? void 0 : _a[0];
    };
    // Mix style for each state and apply it to element.
    const applyState = (element)=>{
        var _a;
        const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
        // Sort states by priority.
        const sortedStates = [
            ...states
        ].sort((a, b)=>getStatePriority(b) - getStatePriority(a));
        // Create a Map to track the highest priority state for each style attribute.
        const styleAttributeMap = new Map();
        // Iterate through all states to find the highest priority state for each style attribute.
        for (const state of sortedStates){
            // If style exists, use it directly, else use interaction style on element.
            const stateStyles = ((_a = style !== null && style !== void 0 ? style : element.__interactionStyle__) === null || _a === void 0 ? void 0 : _a[state]) || {};
            for (const [key, value] of Object.entries(stateStyles)){
                if (!styleAttributeMap.has(key)) {
                    styleAttributeMap.set(key, value);
                }
            }
        }
        // Apply styles including original styles.
        const finalStyle = Object.assign({}, original);
        for (const [key, value] of styleAttributeMap.entries()){
            finalStyle[key] = value;
        }
        if (Object.keys(finalStyle).length === 0) return;
        // Apply final styles to the element.
        for (const [key, value] of Object.entries(finalStyle)){
            const currentValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStyle"])(element, key);
            const v = valueof(value, element);
            setAttribute(element, key, v);
            // Store the attribute if it does not exist in original.
            if (!(key in original)) original[key] = currentValue;
        }
        element[ORIGINAL] = original;
    };
    const initState = (element)=>{
        if (element[STATES]) return;
        element[STATES] = [];
        return;
    };
    /**
     * Update states and update element, handle conflict states automatically.
     */ const updateState = (element, ...states)=>{
        initState(element);
        const currentStates = element[STATES];
        // Collect all new state groups.
        const newStateGroups = new Set(states.map((state)=>getStateGroup(state)).filter((group)=>group !== undefined));
        // Exclude old states that are in the new state group.
        const remainingStates = currentStates.filter((existingState)=>!newStateGroups.has(getStateGroup(existingState)));
        element[STATES] = [
            ...remainingStates,
            ...states
        ];
        applyState(element);
    };
    /**
     * Set the states and update element.
     */ const setState = (element, ...states)=>{
        initState(element);
        element[STATES] = [
            ...states
        ];
        applyState(element);
    };
    /**
     * Remove the states and update element.
     */ const removeState = (element, ...states)=>{
        initState(element);
        for (const state of states){
            const index = element[STATES].indexOf(state);
            if (index !== -1) {
                element[STATES].splice(index, 1);
            }
        }
        applyState(element);
    };
    const hasState = (element, state)=>{
        initState(element);
        return element[STATES].indexOf(state) !== -1;
    };
    return {
        setState,
        updateState,
        removeState,
        hasState
    };
}
function isEmptyObject(obj) {
    if (obj === undefined) return true;
    if (typeof obj !== 'object') return false;
    return Object.keys(obj).length === 0;
}
// A function to generate key for mark each view.
function keyed(viewKey, markKey) {
    return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
    // Index state by mark key and view key.
    const views = Array.isArray(options) ? options : [
        options
    ];
    const markState = views.flatMap((view)=>view.marks.map((mark)=>[
                keyed(view.key, mark.key),
                mark.state
            ]));
    const state = {};
    // Update each specified state.
    for (const descriptor of states){
        const [key, defaults] = Array.isArray(descriptor) ? descriptor : [
            descriptor,
            {}
        ];
        // Update each specified mark state.
        state[key] = markState.reduce((merged, mark)=>{
            // Normalize state.
            const [markKey, markState = {}] = mark;
            const selectedState = isEmptyObject(markState[key]) ? defaults : markState[key];
            // Update each state attribute.
            for (const [attr, value] of Object.entries(selectedState)){
                const oldValue = merged[attr];
                const newValue = (data, index, array, element)=>{
                    const k = keyed(element.__data__.viewKey, element.__data__.markKey);
                    if (markKey !== k) return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data, index, array, element);
                    if (typeof value !== 'function') return value;
                    return value(data, index, array, element);
                };
                merged[attr] = newValue;
            }
            return merged;
        }, {});
    }
    return state;
}
function createValueof(elements, datum) {
    const elementIndex = new Map(elements.map((d, i)=>[
            d,
            i
        ]));
    const fa = datum ? elements.map(datum) : elements;
    return (d, e)=>{
        if (typeof d !== 'function') return d;
        const i = elementIndex.get(e);
        const fe = datum ? datum(e) : e;
        return d(fe, i, fa, e);
    };
}
function renderLink(_a) {
    var { link = false, valueof = (d, element)=>d, coordinate } = _a, style = __rest(_a, [
        "link",
        "valueof",
        "coordinate"
    ]);
    const LINK_CLASS_NAME = 'element-link';
    if (!link) return [
        ()=>{},
        ()=>{}
    ];
    const pointsOf = (element)=>element.__data__.points;
    const pathPointsOf = (P0, P1)=>{
        const [, p1, p2] = P0;
        const [p0, , , p3] = P1;
        const P = [
            p1,
            p0,
            p3,
            p2
        ];
        return P;
    };
    const append = (elements)=>{
        var _a;
        if (elements.length <= 1) return;
        // Sort elements by normalized x to avoid cross.
        const sortedElements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])(elements, (e0, e1)=>{
            const { x: x0 } = e0.__data__;
            const { x: x1 } = e1.__data__;
            const dx = x0 - x1;
            return dx;
        });
        for(let i = 1; i < sortedElements.length; i++){
            const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$path$2f$src$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["path"])();
            const e0 = sortedElements[i - 1];
            const e1 = sortedElements[i];
            const [p0, p1, p2, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
            p.moveTo(...p0);
            p.lineTo(...p1);
            p.lineTo(...p2);
            p.lineTo(...p3);
            p.closePath();
            const _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(style, (d)=>valueof(d, e0)), { fill = e0.getAttribute('fill') } = _b, rest = __rest(_b, [
                "fill"
            ]);
            const link = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]({
                className: LINK_CLASS_NAME,
                style: Object.assign({
                    d: p.toString(),
                    fill,
                    zIndex: -2
                }, rest)
            });
            // @ts-ignore
            (_a = e0.link) === null || _a === void 0 ? void 0 : _a.remove();
            e0.parentNode.appendChild(link);
            // @ts-ignore
            e0.link = link;
        }
    };
    const remove = (element)=>{
        var _a;
        (_a = element.link) === null || _a === void 0 ? void 0 : _a.remove();
        element.link = null;
    };
    return [
        append,
        remove
    ];
}
function offsetTransform(element, offset, coordinate) {
    const append = (t)=>{
        const { transform } = element.style;
        return transform ? `${transform} ${t}` : t;
    };
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate)) {
        const { points } = element.__data__;
        const [p0, p1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reorder"])(points) : points;
        const center = coordinate.getCenter();
        const v0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sub"])(p0, center);
        const v1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sub"])(p1, center);
        const a0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angle"])(v0);
        const da = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angleBetween"])(v0, v1);
        const amid = a0 + da / 2;
        const dx = offset * Math.cos(amid);
        const dy = offset * Math.sin(amid);
        return append(`translate(${dx}, ${dy})`);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate)) return append(`translate(${offset}, 0)`);
    return append(`translate(0, ${-offset})`);
}
function renderBackground(_a) {
    var { document, background, scale, coordinate, valueof } = _a, rest = __rest(_a, [
        "document",
        "background",
        "scale",
        "coordinate",
        "valueof"
    ]);
    const BACKGROUND_CLASS_NAME = 'element-background';
    // Don't have background.
    if (!background) return [
        ()=>{},
        ()=>{}
    ];
    const extentOf = (scale, x, padding)=>{
        const ax = scale.invert(x);
        const mid = x + scale.getBandWidth(ax) / 2;
        const half = scale.getStep(ax) / 2;
        const offset = half * padding;
        return [
            mid - half + offset,
            mid + half - offset
        ];
    };
    const sizeXOf = (element, padding)=>{
        const { x: scaleX } = scale;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(scaleX)) return [
            0,
            1
        ];
        const { __data__: data } = element;
        const { x } = data;
        const [e1, e2] = extentOf(scaleX, x, padding);
        return [
            e1,
            e2
        ];
    };
    const sizeYOf = (element, padding)=>{
        const { y: scaleY } = scale;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(scaleY)) return [
            0,
            1
        ];
        const { __data__: data } = element;
        const { y } = data;
        const [e1, e2] = extentOf(scaleY, y, padding);
        return [
            e1,
            e2
        ];
    };
    const bandShapeOf = (element, style)=>{
        const { padding } = style;
        const [x1, x2] = sizeXOf(element, padding);
        const [y1, y2] = sizeYOf(element, padding);
        const points = [
            [
                x1,
                y1
            ],
            [
                x2,
                y1
            ],
            [
                x2,
                y2
            ],
            [
                x1,
                y2
            ]
        ].map((d)=>coordinate.map(d));
        const { __data__: data } = element;
        const { y: dy, y1: dy1 } = data;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$interval$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rect"])(document, points, {
            y: dy,
            y1: dy1
        }, coordinate, style);
    };
    // Shape without ordinal style.
    // Clone and scale it.
    const cloneShapeOf = (element, style)=>{
        const { transform = 'scale(1.2, 1.2)', transformOrigin = 'center center', stroke = '' } = style, rest = __rest(style, [
            "transform",
            "transformOrigin",
            "stroke"
        ]);
        const finalStyle = Object.assign({
            transform,
            transformOrigin,
            stroke
        }, rest);
        const shape = element.cloneNode(true);
        for (const [key, value] of Object.entries(finalStyle)){
            shape.style[key] = value;
        }
        return shape;
    };
    const isOrdinalShape = ()=>{
        const { x, y } = scale;
        return [
            x,
            y
        ].some(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"]);
    };
    const append = (element)=>{
        if (element.background) element.background.remove();
        const _a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(rest, (d)=>valueof(d, element)), { fill = '#CCD6EC', fillOpacity = 0.3, zIndex = -2, padding = 0.001, lineWidth = 0 } = _a, style = __rest(_a, [
            "fill",
            "fillOpacity",
            "zIndex",
            "padding",
            "lineWidth"
        ]);
        const finalStyle = Object.assign(Object.assign({}, style), {
            fill,
            fillOpacity,
            zIndex,
            padding,
            lineWidth
        });
        const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
        const shape = shapeOf(element, finalStyle);
        shape.className = BACKGROUND_CLASS_NAME;
        element.parentNode.parentNode.appendChild(shape);
        element.background = shape;
    };
    const remove = (element)=>{
        var _a;
        (_a = element.background) === null || _a === void 0 ? void 0 : _a.remove();
        element.background = null;
    };
    const is = (element)=>{
        return element.className === BACKGROUND_CLASS_NAME;
    };
    return [
        append,
        remove,
        is
    ];
}
function setCursor(root, cursor) {
    // @ts-ignore
    const canvas = root.getRootNode().defaultView;
    const dom = canvas.getContextService().getDomElement();
    if (dom === null || dom === void 0 ? void 0 : dom.style) {
        root.cursor = dom.style.cursor;
        dom.style.cursor = cursor;
    }
}
function restoreCursor(root) {
    setCursor(root, root.cursor);
}
function selectElementByData(elements, data, datum) {
    return elements.find((d)=>Object.entries(data).every(([key, value])=>datum(d)[key] === value));
}
function getPointsR(point, nextPoint) {
    return Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2));
}
function getPointsPath(points, isClose = false) {
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__filter$3e$__["filter"])(points, (d)=>!!d).map((d, i)=>{
        return [
            i === 0 ? 'M' : 'L',
            ...d
        ];
    });
    if (isClose) {
        path.push([
            'Z'
        ]);
    }
    return path;
}
function getElements(plot) {
    return plot.querySelectorAll('.element');
}
function getThetaPath(center, points, isBig = 0) {
    const path = [
        [
            'M',
            ...points[1]
        ]
    ];
    const innerRadius = getPointsR(center, points[1]);
    const outerRadius = getPointsR(center, points[0]);
    if (innerRadius === 0) {
        path.push([
            'L',
            ...points[3]
        ], [
            'A',
            outerRadius,
            outerRadius,
            0,
            isBig,
            1,
            ...points[0]
        ], [
            'Z'
        ]);
    } else {
        path.push([
            'A',
            innerRadius,
            innerRadius,
            0,
            isBig,
            0,
            ...points[2]
        ], [
            'L',
            ...points[3]
        ], [
            'A',
            outerRadius,
            outerRadius,
            0,
            isBig,
            1,
            ...points[0]
        ], [
            'Z'
        ]);
    }
    return path;
}
function maybeRoot(node, rootOf) {
    if (rootOf(node)) return node;
    let root = node.parent;
    while(root && !rootOf(root))root = root.parent;
    return root;
}
const VALID_FIND_BY_X_MARKS = [
    'interval',
    'point',
    'density'
];
function createFindElementByEvent({ elementsof, root, coordinate, scale, validFindByXMarks = VALID_FIND_BY_X_MARKS }) {
    var _a, _b;
    let elements = elementsof(root);
    const getValidFindByXMarks = (d)=>validFindByXMarks.includes(d.markType);
    const hasValidFindByXMarks = elements.find(getValidFindByXMarks);
    // Try to find element by x position.
    if (hasValidFindByXMarks) {
        elements = elements.filter(getValidFindByXMarks);
        const scaleX = scale.x;
        const scaleSeries = scale.series;
        const bandWidth = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
        const xof = scaleSeries ? (d)=>{
            var _a, _b;
            const seriesCount = Math.round(1 / ((_a = scaleSeries.valueBandWidth) !== null && _a !== void 0 ? _a : 1));
            return d.__data__.x + ((_b = d.__data__.series) !== null && _b !== void 0 ? _b : 0) * bandWidth + bandWidth / (seriesCount * 2);
        } : (d)=>d.__data__.x + bandWidth / 2;
        // Sort for bisector search.
        elements.sort((a, b)=>xof(a) - xof(b));
        return (event)=>{
            const mouse = mousePosition(root, event);
            if (!mouse) return;
            const [abstractX] = coordinate.invert(mouse);
            const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])(xof).center;
            const i = search(elements, abstractX);
            const target = elements[i];
            return target;
        };
    }
    // If there is no valid element find by x, just return the target element.
    return (event)=>{
        const { target } = event;
        return maybeRoot(target, (node)=>{
            if (!node.classList) return false;
            return node.classList.includes('element');
        });
    };
}
function calculateSensitivityMultiplier(range) {
    // Base sensitivity factor (adjust this to tune overall responsiveness)
    const BASE_FACTOR = 0.01;
    const MIN_RANGE_FOR_SENSITIVITY = 0.0001;
    const MIN_MULTIPLIER = 0.1;
    const MAX_MULTIPLIER = 100;
    // Simple inverse relationship with reasonable bounds
    const multiplier = BASE_FACTOR / Math.max(range, MIN_RANGE_FOR_SENSITIVITY);
    // Clamp to reasonable range: 0.1x to 100x
    return Math.max(MIN_MULTIPLIER, Math.min(MAX_MULTIPLIER, multiplier));
}
function isFalsyValue(value) {
    return value === false || value === null || value === undefined;
}
function extractChannelValues(view) {
    var _a, _b;
    const allXChannelValues = [];
    const allYChannelValues = [];
    const markDataPairs = [];
    const marks = view.markState;
    if (marks) {
        for (const [mark, state] of marks.entries()){
            if (state === null || state === void 0 ? void 0 : state.channels) {
                const channelData = {};
                // Process each channel for the current mark
                for (const channel of state.channels){
                    if ((channel === null || channel === void 0 ? void 0 : channel.name) === 'x' && ((_a = channel.values) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        // Collect X values (supports bin transforms with multiple values)
                        let xValues = [];
                        for (const valueItem of channel.values){
                            if (valueItem === null || valueItem === void 0 ? void 0 : valueItem.value) {
                                xValues = xValues.concat(valueItem.value);
                                allXChannelValues.push(valueItem.value);
                            }
                        }
                        channelData['x'] = xValues;
                    } else if (channel && (channel.name === 'y' || channel.name.startsWith('y')) && // Support y, y1, y2, y3, etc.
                    ((_b = channel.values) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                        const channelName = channel.name;
                        const channelValues = [];
                        // Handle Y and Y1+ channels for multi-Y marks (e.g., area charts, candlestick charts)
                        for (const valueItem of channel.values){
                            if (valueItem === null || valueItem === void 0 ? void 0 : valueItem.value) {
                                const values = valueItem.value;
                                // Preserve G2's internal structure for array-encoded data
                                // Area charts: [[low1,low2,low3], [high1,high2,high3]]
                                // Line charts: [[value1,value2,value3]]
                                channelValues.push(values);
                                if (channelName === 'y' || channelName === 'y1') {
                                    // For global domain calculation, flatten only for allYChannelValues
                                    if (Array.isArray(values)) {
                                        allYChannelValues.push(values.flat());
                                    } else {
                                        allYChannelValues.push([
                                            values
                                        ]);
                                    }
                                }
                            }
                        }
                        // Store all Y-related channels
                        channelData[channelName] = channelValues;
                    }
                }
                // Store mark data with preserved X-Y relationships
                const xValues = channelData['x'] || [];
                const yValues = channelData['y'] || [];
                if (xValues.length > 0 && yValues.length > 0) {
                    markDataPairs.push({
                        markKey: mark.key || `mark_${markDataPairs.length}`,
                        channelData
                    });
                }
            }
        }
    }
    return {
        xChannelValues: allXChannelValues.flat(),
        yChannelValues: allYChannelValues.flat(),
        markDataPairs
    };
}
function hasIndependentXYScale(channel1, marks) {
    return marks.some((mark)=>{
        const { scale: markScale } = mark;
        const channelScale = markScale === null || markScale === void 0 ? void 0 : markScale[channel1];
        return !!(channelScale === null || channelScale === void 0 ? void 0 : channelScale.independent);
    });
}
function calculateMultiAxisChannelDomains(view, initDomain, scaleX, scaleY, independentInfo) {
    var _a, _b, _c, _d;
    const channelDomain = {
        x: initDomain.x || scaleX.getOptions().domain || [],
        y: initDomain.y || scaleY.getOptions().domain || []
    };
    // Use pre-computed info if available, otherwise calculate
    const info = independentInfo || calculateAllIndependentScaleInfo(view);
    const { hasIndependentX, hasIndependentY } = info;
    if (hasIndependentX || hasIndependentY) {
        let xIndex = 1;
        let yIndex = 1;
        // Iterate through marks to collect independent scale domains
        for (const [mark, state] of view.markState.entries()){
            if (state === null || state === void 0 ? void 0 : state.channels) {
                // Process independent X scales
                if (hasIndependentX) {
                    const xChannel = state.channels.find((ch)=>ch.name === 'x');
                    if ((_b = (_a = mark === null || mark === void 0 ? void 0 : mark.scale) === null || _a === void 0 ? void 0 : _a.x) === null || _b === void 0 ? void 0 : _b.independent) {
                        const xKey = `x${xIndex}`;
                        channelDomain[xKey] = xChannel.scale.domain;
                        xIndex++;
                    }
                }
                // Process independent Y scales
                if (hasIndependentY) {
                    const yChannel = state.channels.find((ch)=>ch.name === 'y');
                    if ((_d = (_c = mark === null || mark === void 0 ? void 0 : mark.scale) === null || _c === void 0 ? void 0 : _c.y) === null || _d === void 0 ? void 0 : _d.independent) {
                        const yKey = `y${yIndex}`;
                        channelDomain[yKey] = yChannel.scale.domain;
                        yIndex++;
                    }
                }
            }
        }
    }
    return channelDomain;
}
function calculateAllIndependentScaleInfo(view) {
    var _a, _b, _c, _d;
    const marks = Array.from(view.markState.keys());
    const hasIndependentX = hasIndependentXYScale('x', marks);
    const hasIndependentY = hasIndependentXYScale('y', marks);
    const marksWithSharedX = [];
    const marksWithIndependentX = [];
    const marksWithSharedY = [];
    const marksWithIndependentY = [];
    const markToXScaleMap = new Map();
    const markToYScaleMap = new Map();
    // Single traversal to compute all classifications and mappings
    let xIndex = 1;
    let yIndex = 1;
    for (const [mark] of view.markState.entries()){
        const markKey = mark.key;
        // X axis processing
        if ((_b = (_a = mark === null || mark === void 0 ? void 0 : mark.scale) === null || _a === void 0 ? void 0 : _a.x) === null || _b === void 0 ? void 0 : _b.independent) {
            marksWithIndependentX.push(markKey);
            markToXScaleMap.set(markKey, `x${xIndex++}`);
        } else {
            marksWithSharedX.push(markKey);
            markToXScaleMap.set(markKey, 'x');
        }
        // Y axis processing
        if ((_d = (_c = mark === null || mark === void 0 ? void 0 : mark.scale) === null || _c === void 0 ? void 0 : _c.y) === null || _d === void 0 ? void 0 : _d.independent) {
            marksWithIndependentY.push(markKey);
            markToYScaleMap.set(markKey, `y${yIndex++}`);
        } else {
            marksWithSharedY.push(markKey);
            markToYScaleMap.set(markKey, 'y');
        }
    }
    return {
        hasIndependentX,
        hasIndependentY,
        marksWithSharedX,
        marksWithIndependentX,
        marksWithSharedY,
        marksWithIndependentY,
        markToXScaleMap,
        markToYScaleMap
    };
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/event.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Event": (()=>Event)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/event.js [app-client] (ecmascript)");
;
;
;
// For extended component
function maybeComponentRoot(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(node, (node)=>node.className === 'component');
}
// For extended shape.
function maybeElementRoot(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(node, (node)=>node.className === 'element');
}
// For extended label.
function maybeLabelRoot(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(node, (node)=>node.className === 'label');
}
function bubblesEvent(eventType, view, emitter, predicate = (event)=>true) {
    return (e)=>{
        if (!predicate(e)) return;
        // Emit plot events.
        emitter.emit(`plot:${eventType}`, e);
        const { target } = e;
        // There is no target for pointerupoutside event if out of canvas.
        if (!target) return;
        const { className } = target;
        // If target area is plot area, do not emit extra events.
        if (className === 'plot') return;
        // If target is element or child of element.
        const elementRoot = maybeElementRoot(target);
        // If target is component or child of component.
        const componentRoot = maybeComponentRoot(target);
        //  If target is babel or child of babel.
        const babelRoot = maybeLabelRoot(target);
        const root = elementRoot || componentRoot || babelRoot;
        if (!root) return;
        const { className: elementType, markType } = root;
        const e1 = Object.assign(Object.assign({}, e), {
            nativeEvent: true
        });
        if (elementType === 'element') {
            e1['data'] = {
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataOf"])(root, view)
            };
            emitter.emit(`element:${eventType}`, e1);
            emitter.emit(`${markType}:${eventType}`, e1);
        } else if (elementType === 'label') {
            //label children [Text2, Rect2, Path2],
            e1['data'] = {
                data: root.attributes.datum
            };
            emitter.emit(`label:${eventType}`, e1);
            emitter.emit(`${className}:${eventType}`, e1);
        } else {
            emitter.emit(`component:${eventType}`, e1);
            emitter.emit(`${className}:${eventType}`, e1);
        }
    };
}
function Event() {
    return (context, _, emitter)=>{
        const { container, view } = context;
        // Click events.
        const click = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].CLICK, view, emitter, (e)=>e.detail === 1);
        const dblclick = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DBLCLICK, view, emitter, (e)=>e.detail === 2);
        // Pointer events.
        const pointertap = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_TAP, view, emitter);
        const pointerdown = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_DOWN, view, emitter);
        const pointerup = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_UP, view, emitter);
        const pointerover = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_OVER, view, emitter);
        const pointerout = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_OUT, view, emitter);
        const pointermove = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_MOVE, view, emitter);
        const pointerenter = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_ENTER, view, emitter);
        const pointerleave = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_LEAVE, view, emitter);
        const pointerupoutside = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_UPOUTSIDE, view, emitter);
        // Drag and drop events.
        const dragstart = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_START, view, emitter);
        const drag = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG, view, emitter);
        const dragend = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_END, view, emitter);
        const dragenter = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_ENTER, view, emitter);
        const dragleave = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_LEAVE, view, emitter);
        const dragover = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_OVER, view, emitter);
        const drop = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DROP, view, emitter);
        // For legacy usage.
        container.addEventListener('click', click);
        container.addEventListener('click', dblclick);
        // Recommend events.
        container.addEventListener('pointertap', pointertap);
        container.addEventListener('pointerdown', pointerdown);
        container.addEventListener('pointerup', pointerup);
        container.addEventListener('pointerover', pointerover);
        container.addEventListener('pointerout', pointerout);
        container.addEventListener('pointermove', pointermove);
        container.addEventListener('pointerenter', pointerenter);
        container.addEventListener('pointerleave', pointerleave);
        container.addEventListener('pointerupoutside', pointerupoutside);
        // Plugin events.
        container.addEventListener('dragstart', dragstart);
        container.addEventListener('drag', drag);
        container.addEventListener('dragend', dragend);
        container.addEventListener('dragenter', dragenter);
        container.addEventListener('dragleave', dragleave);
        container.addEventListener('dragover', dragover);
        container.addEventListener('drop', drop);
        return ()=>{
            container.removeEventListener('click', click);
            container.removeEventListener('click', dblclick);
            container.removeEventListener('pointertap', pointertap);
            container.removeEventListener('pointerdown', pointerdown);
            container.removeEventListener('pointerup', pointerup);
            container.removeEventListener('pointerover', pointerover);
            container.removeEventListener('pointerout', pointerout);
            container.removeEventListener('pointermove', pointermove);
            container.removeEventListener('pointerenter', pointerenter);
            container.removeEventListener('pointerleave', pointerleave);
            container.removeEventListener('pointerupoutside', pointerupoutside);
            container.removeEventListener('dragstart', dragstart);
            container.removeEventListener('drag', drag);
            container.removeEventListener('dragend', dragend);
            container.removeEventListener('dragenter', dragenter);
            container.removeEventListener('dragleave', dragleave);
            container.removeEventListener('dragover', dragover);
            container.removeEventListener('drop', drop);
        };
    };
}
Event.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=event.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/tooltip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Tooltip": (()=>Tooltip),
    "findSeriesElement": (()=>findSeriesElement),
    "findSingleElement": (()=>findSingleElement),
    "maybeValue": (()=>maybeValue),
    "seriesTooltip": (()=>seriesTooltip),
    "tooltip": (()=>tooltip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$component$2f$esm$2f$ui$2f$tooltip$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/component/esm/ui/tooltip/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__minIndex$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/minIndex.js [app-client] (ecmascript) <export default as minIndex>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mean$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/mean.js [app-client] (ecmascript) <export default as mean>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isNumber$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/is-number.js [app-client] (ecmascript) <export default as isNumber>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/last.js [app-client] (ecmascript) <export default as last>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__set$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/set.js [app-client] (ecmascript) <export default as set>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript) <export default as bisector>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sort.js [app-client] (ecmascript) <export default as sort>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$lower$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__lowerFirst$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/lower-first.js [app-client] (ecmascript) <export default as lowerFirst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
;
;
const LOCKED_SYMBOL = 'tooltipLocked';
function getContainer(group, mount) {
    var _a;
    if (mount) {
        return typeof mount === 'string' ? document.querySelector(mount) : mount;
    }
    const view = (_a = group.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    if (!view) return;
    const canvas = view.getContextService().getDomElement();
    return canvas.parentElement;
}
function getBounding(root) {
    const bbox = root.getRenderBounds();
    const { min: [x1, y1], max: [x2, y2] } = bbox;
    return {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: y2 - y1
    };
}
function getContainerOffset(container1, container2) {
    const r1 = container1.getBoundingClientRect();
    const r2 = container2.getBoundingClientRect();
    return {
        x: r1.x - r2.x,
        y: r1.y - r2.y
    };
}
function createTooltip(container, x0, y0, position, enterable, bounding, containerOffset, css = {}, offset = [
    10,
    10
]) {
    const defaults = {
        '.g2-tooltip': {},
        '.g2-tooltip-title': {
            overflow: 'hidden',
            'white-space': 'nowrap',
            'text-overflow': 'ellipsis'
        }
    };
    const tooltipElement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$component$2f$esm$2f$ui$2f$tooltip$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tooltip"]({
        className: 'tooltip',
        style: {
            x: x0,
            y: y0,
            container: containerOffset,
            data: [],
            bounding,
            position,
            enterable,
            title: '',
            offset,
            template: {
                prefixCls: 'g2-'
            },
            style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(defaults, css)
        }
    });
    container.appendChild(tooltipElement.HTMLTooltipElement);
    return tooltipElement;
}
function showTooltip({ root, data, x, y, render, event, single, position = 'right-bottom', enterable = false, css, mount, bounding, offset }) {
    const container = getContainer(root, mount);
    const canvasContainer = getContainer(root);
    // All the views share the same tooltip.
    const parent = single ? canvasContainer : root;
    const b = bounding || getBounding(root);
    const containerOffset = getContainerOffset(canvasContainer, container);
    const { tooltipElement = createTooltip(container, x, y, position, enterable, b, containerOffset, css, offset) } = parent;
    const { items, title = '' } = data;
    tooltipElement.update(Object.assign({
        x,
        y,
        data: items.map((item)=>Object.assign(Object.assign({}, item), {
                value: !item.value && item.value !== 0 ? '' : item.value
            })),
        title,
        position,
        enterable,
        container: containerOffset
    }, render !== undefined && {
        content: render(event, {
            items,
            title
        })
    }));
    parent.tooltipElement = tooltipElement;
}
function hideTooltip({ root, single, emitter, nativeEvent = true, event = null }) {
    if (nativeEvent) {
        emitter.emit('tooltip:hide', {
            nativeEvent
        });
    }
    const container = getContainer(root);
    const parent = single ? container : root;
    const { tooltipElement } = parent;
    if (tooltipElement) {
        // Must be clientX, clientY.
        tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
    }
    hideRuleY(root);
    hideRuleX(root);
    hideMarker(root);
}
function destroyTooltip({ root, single }) {
    const container = getContainer(root);
    const parent = single ? container : root;
    if (!parent) return;
    const { tooltipElement } = parent;
    if (tooltipElement) {
        tooltipElement.destroy();
        parent.tooltipElement = undefined;
    }
    hideRuleY(root);
    hideRuleX(root);
    hideMarker(root);
}
function showUndefined(item) {
    const { value } = item;
    return Object.assign(Object.assign({}, item), {
        value: value === undefined ? 'undefined' : value
    });
}
function heatmapItem(element) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { __data__: datum } = element;
    const { title, items = [] } = datum;
    // Check if there are user-defined items using the existing CALLBACK_ITEM_SYMBOL
    const hasCustomItems = items.some((item)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CALLBACK_ITEM_SYMBOL"] in item);
    if (hasCustomItems) {
        // User has defined custom items, pass them through as is
        const newItems = items.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]).map((_a)=>{
            var { color = itemColorOf(element) } = _a, item = __rest(_a, [
                "color"
            ]);
            return Object.assign(Object.assign({}, item), {
                color
            });
        }).map(showUndefined);
        return Object.assign(Object.assign({}, title && {
            title
        }), {
            items: newItems
        });
    }
    // No user-defined items, use special logic for heatmap
    const normalizedX = (_b = (_a = datum === null || datum === void 0 ? void 0 : datum.normalized) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
    const originalDatum = (_c = element.parentNode) === null || _c === void 0 ? void 0 : _c.__data__;
    const encode = (_d = originalDatum === null || originalDatum === void 0 ? void 0 : originalDatum.encode) !== null && _d !== void 0 ? _d : {};
    const { x = {}, y = {}, color = {} } = encode;
    const { value: vx = [] } = x;
    const { value: vy = [] } = y;
    const { value: vc = [] } = color;
    const index = Math.min(Math.round(vx.length * normalizedX), vx.length - 1);
    return {
        title: `${vx[index]}, ${vy[index]}`,
        items: [
            {
                name: (_e = color.field) !== null && _e !== void 0 ? _e : 'value',
                value: vc[index],
                color: ((_f = element.style) === null || _f === void 0 ? void 0 : _f.fill) || ((_g = element.getAttribute) === null || _g === void 0 ? void 0 : _g.call(element, 'color')) || '#000'
            }
        ]
    };
}
function singleItem(element) {
    const { __data__: datum } = element;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHeatmap"])(element)) return heatmapItem(element);
    const { title, items = [] } = datum;
    const newItems = items.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]).map((_a)=>{
        var { color = itemColorOf(element) } = _a, item = __rest(_a, [
            "color"
        ]);
        return Object.assign(Object.assign({}, item), {
            color
        });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, title && {
        title
    }), {
        items: newItems
    });
}
function itemColorOf(element) {
    const fill = element.getAttribute('fill');
    const stroke = element.getAttribute('stroke');
    const { __data__: datum } = element;
    const { color = fill && fill !== 'transparent' ? fill : stroke } = datum;
    return color;
}
function unique(items, key = (d)=>d) {
    const valueName = new Map(items.map((d)=>[
            key(d),
            d
        ]));
    return Array.from(valueName.values());
}
function groupItems(elements, scale, groupName, data = elements.map((d)=>d['__data__']), theme = {}) {
    const key = (d)=>d instanceof Date ? +d : d;
    const T = unique(data.map((d)=>d.title), key).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
    const newItems = data.flatMap((datum, i)=>{
        // Fix: Get the corresponding element from datum instead of using index i
        // When data and elements don't correspond one-to-one, using index will cause color errors
        const element = datum.element || elements[i];
        const { items = [], title } = datum;
        const definedItems = items.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
        // If there is only one item, use groupName as title by default.
        const useGroupName = groupName !== undefined ? groupName : items.length <= 1 ? true : false;
        return definedItems.map((_a)=>{
            var { color = itemColorOf(element) || theme.color, name } = _a, item = __rest(_a, [
                "color",
                "name"
            ]);
            const groupName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupNameOf"])(scale, datum);
            // callback's priority is higher than groupName.
            const name1 = useGroupName && !(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CALLBACK_ITEM_SYMBOL"] in item) ? groupName || name : name || groupName;
            return Object.assign(Object.assign({}, item), {
                color,
                name: name1 || title
            });
        });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, T.length > 0 && {
        title: T.join(',')
    }), {
        items: unique(newItems, (d)=>`(${key(d.name)}, ${key(d.value)}, ${key(d.color)})`)
    });
}
function updateRuleX(root, points, mouse, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest(_a, [
        "plotWidth",
        "plotHeight",
        "mainWidth",
        "mainHeight",
        "startX",
        "startY",
        "transposed",
        "polar",
        "insetLeft",
        "insetTop"
    ]);
    const defaults = Object.assign({
        lineWidth: 1,
        stroke: '#1b1e23',
        strokeOpacity: 0.5
    }, rest);
    const createCircle = (cx, cy, r)=>{
        const circle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
            style: Object.assign({
                cx,
                cy,
                r
            }, defaults)
        });
        root.appendChild(circle);
        return circle;
    };
    const createLine = (x1, x2, y1, y2)=>{
        const line = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"]({
            style: Object.assign({
                x1,
                x2,
                y1,
                y2
            }, defaults)
        });
        root.appendChild(line);
        return line;
    };
    const minDistPoint = (mouse, points)=>{
        // only one point do not need compute
        if (points.length === 1) {
            return points[0];
        }
        const dists = points.map((p)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dist"])(p, mouse));
        const minDistIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__minIndex$3e$__["minIndex"])(dists, (d)=>d);
        return points[minDistIndex];
    };
    const target = minDistPoint(mouse, points);
    const pointsOf = ()=>{
        if (transposed) return [
            startX + target[0],
            startX + target[0],
            startY,
            startY + plotHeight
        ];
        return [
            startX,
            startX + plotWidth,
            target[1] + startY,
            target[1] + startY
        ];
    };
    const pointsOfPolar = ()=>{
        const cx = startX + insetLeft + mainWidth / 2;
        const cy = startY + insetTop + mainHeight / 2;
        const cdist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dist"])([
            cx,
            cy
        ], target);
        return [
            cx,
            cy,
            cdist
        ];
    };
    if (polar) {
        const [cx, cy, r] = pointsOfPolar();
        const ruleX = root.ruleX || createCircle(cx, cy, r);
        ruleX.style.cx = cx;
        ruleX.style.cy = cy;
        ruleX.style.r = r;
        root.ruleX = ruleX;
    } else {
        const [x1, x2, y1, y2] = pointsOf();
        const ruleX = root.ruleX || createLine(x1, x2, y1, y2);
        ruleX.style.x1 = x1;
        ruleX.style.x2 = x2;
        ruleX.style.y1 = y1;
        ruleX.style.y2 = y2;
        root.ruleX = ruleX;
    }
}
function updateRuleY(root, points, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest(_a, [
        "plotWidth",
        "plotHeight",
        "mainWidth",
        "mainHeight",
        "startX",
        "startY",
        "transposed",
        "polar",
        "insetLeft",
        "insetTop"
    ]);
    const defaults = Object.assign({
        lineWidth: 1,
        stroke: '#1b1e23',
        strokeOpacity: 0.5
    }, rest);
    const Y = points.map((p)=>p[1]);
    const X = points.map((p)=>p[0]);
    const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mean$3e$__["mean"])(Y);
    const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mean$3e$__["mean"])(X);
    const pointsOf = ()=>{
        if (polar) {
            const r = Math.min(mainWidth, mainHeight) / 2;
            const cx = startX + insetLeft + mainWidth / 2;
            const cy = startY + insetTop + mainHeight / 2;
            const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angle"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sub"])([
                x,
                y
            ], [
                cx,
                cy
            ]));
            const x0 = cx + r * Math.cos(a);
            const y0 = cy + r * Math.sin(a);
            return [
                cx,
                x0,
                cy,
                y0
            ];
        }
        if (transposed) return [
            startX,
            startX + plotWidth,
            y + startY,
            y + startY
        ];
        return [
            x + startX,
            x + startX,
            startY,
            startY + plotHeight
        ];
    };
    const [x1, x2, y1, y2] = pointsOf();
    const createLine = ()=>{
        const line = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"]({
            style: Object.assign({
                x1,
                x2,
                y1,
                y2
            }, defaults)
        });
        root.appendChild(line);
        return line;
    };
    // Only update rule with defined series elements.
    if (X.length > 0) {
        const ruleY = root.ruleY || createLine();
        ruleY.style.x1 = x1;
        ruleY.style.x2 = x2;
        ruleY.style.y1 = y1;
        ruleY.style.y2 = y2;
        root.ruleY = ruleY;
    }
}
function hideRuleY(root) {
    if (root.ruleY) {
        root.ruleY.remove();
        root.ruleY = undefined;
    }
}
function hideRuleX(root) {
    if (root.ruleX) {
        root.ruleX.remove();
        root.ruleX = undefined;
    }
}
function updateMarker(root, { data, style, theme }) {
    if (root.markers) root.markers.forEach((d)=>d.remove());
    const { type = '' } = style;
    const markers = data.filter((d)=>{
        const [{ x, y }] = d;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(x) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(y);
    }).map((d)=>{
        const [{ color, element }, point] = d;
        const originColor = color || // encode value
        element.style.fill || element.style.stroke || theme.color;
        const fill = type === 'hollow' ? 'transparent' : originColor;
        const stroke = type === 'hollow' ? originColor : '#fff';
        const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
            className: 'g2-tooltip-marker',
            style: Object.assign({
                cx: point[0],
                cy: point[1],
                fill,
                r: 4,
                stroke,
                lineWidth: 2,
                // Prevents blocking clicks on elements behind.
                pointerEvents: 'none'
            }, style)
        });
        return shape;
    });
    for (const marker of markers)root.appendChild(marker);
    root.markers = markers;
}
function hideMarker(root) {
    if (root.markers) {
        root.markers.forEach((d)=>d.remove());
        root.markers = [];
    }
}
function interactionKeyof(markState, key) {
    return Array.from(markState.values()).some(// @ts-ignore
    (d)=>{
        var _a;
        return (_a = d.interaction) === null || _a === void 0 ? void 0 : _a[key];
    });
}
function maybeValue(specified, defaults) {
    return specified === undefined ? defaults : specified;
}
function isEmptyTooltipData(data) {
    const { title, items } = data;
    if (items.length === 0 && title === undefined) return true;
    return false;
}
function hasSeries(markState) {
    return Array.from(markState.values()).some(// @ts-ignore
    (d)=>{
        var _a;
        return ((_a = d.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d.tooltip;
    });
}
function normalizedPosition(coordinate, position) {
    const { innerWidth, innerHeight, marginLeft, paddingLeft, insetLeft, marginTop, paddingTop, insetTop } = coordinate.getOptions();
    return {
        x: (position.x - marginLeft - paddingLeft - insetLeft) / innerWidth,
        y: (position.y - marginTop - paddingTop - insetTop) / innerHeight
    };
}
/**
 * Determine whether the band widths occupied by different categories are the same.
 */ function equalBandWidth(scale) {
    const { x } = scale;
    if (!x || !x.valueBandWidth) return true;
    const { valueBandWidth } = x;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isNumber$3e$__["isNumber"])(valueBandWidth)) return true;
    return new Set(valueBandWidth.values()).size === 1;
}
/**
 * Get the index of the element closest to the abstractX
 */ function findNearestElementIndex(scale, abstractX) {
    const { adjustedRange, valueBandWidth, valueStep } = scale;
    const values = Array.from(valueBandWidth.values());
    const steps = Array.from(valueStep.values());
    const ranges = adjustedRange.map((v, i)=>{
        const halfStep = (steps[i] - values[i]) / 2;
        return [
            v - halfStep,
            v + values[i] + halfStep
        ];
    });
    const index = ranges.findIndex(([start, end])=>start <= abstractX && abstractX <= end);
    if (index !== -1) return index;
    return abstractX > 0.5 ? adjustedRange.length - 1 : 0;
}
function findSingleElement({ root, event, elements = [], coordinate, scale, shared }) {
    var _a, _b;
    const inInterval = (d)=>d.markType === 'interval';
    const isBar = elements.every(inInterval) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate);
    const scaleX = scale.x;
    const isEqualWidth = equalBandWidth(scale);
    const scaleSeries = scale.series;
    const bandWidth = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
    const xof = scaleSeries && scaleSeries.valueBandWidth ? (d)=>{
        const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
        return d.__data__.x + d.__data__.series * bandWidth + bandWidth / (seriesCount * 2);
    } : (d)=>d.__data__.x + bandWidth / 2;
    // Sort for bisector search.
    if (isBar) elements.sort((a, b)=>xof(a) - xof(b));
    const findElementByTarget = (event)=>{
        const { target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__["last"])(elements) } = event;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(target, (node)=>{
            if (!node.classList) return false;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHeatmap"])(node)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__set$3e$__["set"])(node, '__data__.normalized', normalizedPosition(coordinate, {
                    x: event.offsetX,
                    y: event.offsetY
                }));
            }
            return node.classList.includes('element');
        });
    };
    const element = isBar ? (event)=>{
        const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, event);
        if (!mouse) return;
        const [abstractX] = coordinate.invert(mouse);
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])(xof).center;
        const i = isEqualWidth ? search(elements, abstractX) : findNearestElementIndex(scaleX, abstractX);
        const target = elements[i];
        if (!shared) {
            // For grouped bar chart without shared options.
            const isGrouped = elements.find((d)=>d !== target && xof(d) === xof(target));
            if (isGrouped) return findElementByTarget(event) || isGrouped;
        }
        return target;
    } : findElementByTarget;
    return element(event);
}
function findSeriesElement({ root, event, elements, coordinate, scale, startX, startY }) {
    const transposed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate);
    // Split elements into series elements and item elements.
    const seriesElements = [];
    const itemElements = [];
    for (const element of elements){
        const { __data__: data } = element;
        const { seriesX, title, items } = data;
        if (seriesX) seriesElements.push(element);
        else if (title || items) itemElements.push(element);
    }
    const inInterval = (d)=>d.markType === 'interval';
    const isBar = itemElements.length && itemElements.every(inInterval) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate);
    const xof = (d)=>d.__data__.x;
    // For band scale x, find the closest series element to focus,
    // useful for interval + line mark.
    const isBandScale = !!scale.x.getBandWidth;
    const closest = isBandScale && itemElements.length > 0;
    // Sorted elements from top to bottom visually,
    // or from right to left in transpose coordinate.
    seriesElements.sort((a, b)=>{
        const index = transposed ? 0 : 1;
        const minY = (d)=>d.getBounds().min[index];
        return transposed ? minY(b) - minY(a) : minY(a) - minY(b);
    });
    const extent = (d)=>{
        const index = transposed ? 1 : 0;
        const { min, max } = d.getLocalBounds();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])([
            min[index],
            max[index]
        ]);
    };
    // Sort itemElements for bisector search.
    if (isBar) elements.sort((a, b)=>xof(a) - xof(b));
    else {
        itemElements.sort((a, b)=>{
            const [minA, maxA] = extent(a);
            const [minB, maxB] = extent(b);
            const midA = (minA + maxA) / 2;
            const midB = (minB + maxB) / 2;
            return transposed ? midB - midA : midA - midB;
        });
    }
    // Get sortedIndex and X for each series elements
    const elementSortedX = new Map(seriesElements.map((element)=>{
        const { __data__: data } = element;
        const { seriesX } = data;
        const seriesIndex = seriesX.map((_, i)=>i);
        const sortedIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])(seriesIndex, (i)=>seriesX[+i]);
        return [
            element,
            [
                sortedIndex,
                seriesX
            ]
        ];
    }));
    const { x: scaleX } = scale;
    // Apply offset for band scale x.
    const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;
    const abstractX = (focus1)=>{
        const [normalizedX] = coordinate.invert(focus1);
        return normalizedX - offsetX;
    };
    const indexByFocus = (event, focus1, I, X)=>{
        // _x is from emit event, to find the right element.
        const { _x } = event;
        const finalX = _x !== undefined ? scaleX.map(_x) : abstractX(focus1);
        const DX = X.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
        const [minX, maxX] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])([
            DX[0],
            DX[DX.length - 1]
        ]);
        // If only has one element(minX == maxX), show tooltip when hover whole chart
        const isOnlyOneElement = minX === maxX;
        // If closest is true, always find at least one element.
        // Otherwise, skip element out of plot area.
        if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement) return null;
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((i)=>X[+i]).center;
        const i = search(I, finalX);
        return I[i];
    };
    const elementsByFocus = isBar ? (focus1, elements)=>{
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])(xof).center;
        const i = search(elements, abstractX(focus1));
        const find = elements[i];
        const groups = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, xof);
        const selected = groups.get(xof(find));
        return selected;
    } : (focus1, elements)=>{
        const index = transposed ? 1 : 0;
        const x = focus1[index];
        const filtered = elements.filter((element)=>{
            const [min, max] = extent(element);
            return x >= min && x <= max;
        });
        // If closet is true, always find at least one element.
        if (!closest || filtered.length > 0) return filtered;
        // Search the closet element to the focus.
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((element)=>{
            const [min, max] = extent(element);
            return (min + max) / 2;
        }).center;
        const i = search(elements, x);
        return [
            elements[i]
        ].filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
    };
    const seriesData = (element, index)=>{
        const { __data__: data } = element;
        return Object.fromEntries(Object.entries(data).filter(([key])=>key.startsWith('series') && key !== 'series').map(([key, V])=>{
            const d = V[index];
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$lower$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__lowerFirst$3e$__["lowerFirst"])(key.replace('series', '')),
                d
            ];
        }));
    };
    const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, event);
    if (!mouse) return;
    const focus1 = [
        mouse[0] - startX,
        mouse[1] - startY
    ];
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Get selected item element.
    const selectedItems = elementsByFocus(focus1, itemElements);
    // Get selected data item from both series element and item element.
    const selectedSeriesElements = [];
    const selectedSeriesData = [];
    for (const element of seriesElements){
        const [sortedIndex, X] = elementSortedX.get(element);
        const index = indexByFocus(event, focus1, sortedIndex, X);
        if (index !== null) {
            selectedSeriesElements.push(element);
            const d = seriesData(element, index);
            const { x, y } = d;
            const p = coordinate.map([
                (x || 0) + offsetX,
                y || 0
            ]);
            selectedSeriesData.push([
                Object.assign(Object.assign({}, d), {
                    element
                }),
                p
            ]);
        }
    }
    // Filter selectedSeriesData with different x,
    // make sure there is only one x closest to focusX.
    const SX = Array.from(new Set(selectedSeriesData.map((d)=>d[0].x)));
    const closestX = SX[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__minIndex$3e$__["minIndex"])(SX, (x)=>Math.abs(x - abstractX(focus1)))];
    const filteredSeriesData = selectedSeriesData.filter((d)=>d[0].x === closestX);
    const selectedData = [
        ...filteredSeriesData.map((d)=>d[0]),
        ...selectedItems.map((d)=>d.__data__)
    ];
    // Get the displayed tooltip data.
    const selectedElements = [
        ...selectedSeriesElements,
        ...selectedItems
    ];
    return {
        selectedElements,
        selectedData,
        filteredSeriesData,
        abstractX
    };
}
function seriesTooltip(root, _a) {
    var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale, coordinate, crosshairs, crosshairsX, crosshairsY, render, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, offset, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {}, clickLock = false } = _a, rest = __rest(_a, [
        "elements",
        "sort",
        "filter",
        "scale",
        "coordinate",
        "crosshairs",
        "crosshairsX",
        "crosshairsY",
        "render",
        "groupName",
        "emitter",
        "wait",
        "leading",
        "trailing",
        "startX",
        "startY",
        "body",
        "single",
        "position",
        "enterable",
        "mount",
        "bounding",
        "theme",
        "offset",
        "disableNative",
        "marker",
        "preserve",
        "style",
        "css",
        "clickLock"
    ]);
    const elements = elementsof(root);
    const style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(_style, rest);
    const polar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate);
    const transposed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate);
    const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
    const update = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
        var _a;
        if (clickLock && root.getAttribute(LOCKED_SYMBOL)) return;
        const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, event);
        if (!mouse) return;
        const bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxOf"])(root);
        const x = bbox.min[0];
        const y = bbox.min[1];
        const { selectedElements, selectedData, filteredSeriesData, abstractX } = findSeriesElement({
            root,
            event,
            elements,
            coordinate,
            scale,
            startX,
            startY
        });
        const tooltipData = groupItems(selectedElements, scale, groupName, selectedData, theme);
        // Sort items and filter items.
        if (sortFunction) {
            tooltipData.items.sort((a, b)=>sortFunction(a) - sortFunction(b));
        }
        if (filterFunction) {
            tooltipData.items = tooltipData.items.filter(filterFunction);
        }
        // Hide tooltip with no selected tooltip.
        if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
            hide(event);
            return;
        }
        if (body) {
            showTooltip({
                root,
                data: tooltipData,
                x: mouse[0] + x,
                y: mouse[1] + y,
                render,
                event,
                single,
                position,
                enterable,
                mount,
                bounding,
                css,
                offset
            });
        }
        if (crosshairs || crosshairsX || crosshairsY) {
            const ruleStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'crosshairs');
            const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'crosshairsX'));
            const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'crosshairsY'));
            const points = filteredSeriesData.map((d)=>d[1]);
            if (crosshairsX) {
                updateRuleX(root, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
                    plotWidth,
                    plotHeight,
                    mainWidth,
                    mainHeight,
                    insetLeft,
                    insetTop,
                    startX,
                    startY,
                    transposed,
                    polar
                }));
            }
            if (crosshairsY) {
                updateRuleY(root, points, Object.assign(Object.assign({}, ruleStyleY), {
                    plotWidth,
                    plotHeight,
                    mainWidth,
                    mainHeight,
                    insetLeft,
                    insetTop,
                    startX,
                    startY,
                    transposed,
                    polar
                }));
            }
        }
        if (marker) {
            const markerStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'marker');
            updateMarker(root, {
                data: filteredSeriesData,
                style: markerStyles,
                theme
            });
        }
        // X in focus may related multiple points when dataset is large,
        // so we need to find the first x to show tooltip.
        const firstX = (_a = filteredSeriesData[0]) === null || _a === void 0 ? void 0 : _a[0].x;
        const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
        emitter.emit('tooltip:show', Object.assign(Object.assign({}, event), {
            nativeEvent: true,
            data: Object.assign(Object.assign({}, tooltipData), {
                data: {
                    x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(scale.x, transformedX, true)
                }
            })
        }));
    }, wait, {
        leading,
        trailing
    });
    const hide = (event)=>{
        if (clickLock && root.getAttribute(LOCKED_SYMBOL)) return;
        hideTooltip({
            root,
            single,
            emitter,
            event
        });
    };
    const destroy = ()=>{
        destroyTooltip({
            root,
            single
        });
    };
    const onTooltipShow = (_a)=>{
        var _b;
        var { nativeEvent, data, offsetX, offsetY } = _a, rest = __rest(_a, [
            "nativeEvent",
            "data",
            "offsetX",
            "offsetY"
        ]);
        if (nativeEvent) return;
        const x = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.x;
        const scaleX = scale.x;
        const x1 = scaleX.map(x);
        const [x2, y2] = coordinate.map([
            x1,
            0.5
        ]);
        const rootBounds = root.getRenderBounds();
        const minX = rootBounds.min[0];
        const minY = rootBounds.min[1];
        update(Object.assign(Object.assign({}, rest), {
            offsetX: offsetX !== undefined ? offsetX : minX + x2,
            offsetY: offsetY !== undefined ? offsetY : minY + y2,
            _x: x
        }));
    };
    const onTooltipHide = ()=>{
        hideTooltip({
            root,
            single,
            emitter,
            nativeEvent: false
        });
    };
    const onTooltipDisable = ()=>{
        removeEventListeners();
        destroy();
    };
    const pointerleave = (e)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, e)) return;
        hide(e);
    };
    const onTooltipEnable = ()=>{
        addEventListeners();
    };
    const pointerdown = (e)=>{
        if (clickLock) {
            root.setAttribute(LOCKED_SYMBOL, !root.getAttribute(LOCKED_SYMBOL));
        }
        update(e);
    };
    const addEventListeners = ()=>{
        if (!disableNative) {
            root.addEventListener('pointerdown', pointerdown);
            root.addEventListener('pointerenter', update);
            root.addEventListener('pointermove', update);
            // Only emit pointerleave event when the pointer is not in the root area.
            root.addEventListener('pointerleave', pointerleave);
            root.addEventListener('pointerup', hide);
        }
    };
    const removeEventListeners = ()=>{
        if (!disableNative) {
            root.removeEventListener('pointerdown', pointerdown);
            root.removeEventListener('pointerenter', update);
            root.removeEventListener('pointermove', update);
            root.removeEventListener('pointerleave', pointerleave);
            root.removeEventListener('pointerup', hide);
        }
    };
    addEventListeners();
    emitter.on('tooltip:show', onTooltipShow);
    emitter.on('tooltip:hide', onTooltipHide);
    emitter.on('tooltip:disable', onTooltipDisable);
    emitter.on('tooltip:enable', onTooltipEnable);
    return ()=>{
        removeEventListeners();
        emitter.off('tooltip:show', onTooltipShow);
        emitter.off('tooltip:hide', onTooltipHide);
        emitter.off('tooltip:disable', onTooltipDisable);
        emitter.off('tooltip:enable', onTooltipEnable);
        if (preserve) {
            hideTooltip({
                root,
                single,
                emitter,
                nativeEvent: false
            });
        } else {
            destroy();
        }
    };
}
function tooltip(root, { elements: elementsof, coordinate, scale, render, groupName, sort: sortFunction, filter: filterFunction, emitter, wait = 50, leading = true, trailing = false, groupKey = (d)=>d, single = true, position, enterable, datum, view, mount, bounding, theme, offset, shared = false, body = true, disableNative = false, preserve = false, css = {}, clickLock = false }) {
    const elements = elementsof(root);
    const keyGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, groupKey);
    const pointermove = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
        if (clickLock && root.getAttribute(LOCKED_SYMBOL)) return;
        const element = findSingleElement({
            root,
            event,
            elements,
            coordinate,
            scale,
            shared
        });
        if (!element) {
            hideTooltip({
                root,
                single,
                emitter,
                event
            });
            return;
        }
        const k = groupKey(element);
        const group = keyGroup.get(k);
        if (!group) {
            return;
        }
        const data = group.length === 1 && !shared ? singleItem(group[0]) : groupItems(group, scale, groupName, undefined, theme);
        // Sort items and sort.
        if (sortFunction) {
            data.items.sort((a, b)=>sortFunction(a) - sortFunction(b));
        }
        if (filterFunction) {
            data.items = data.items.filter(filterFunction);
        }
        if (isEmptyTooltipData(data)) {
            hideTooltip({
                root,
                single,
                emitter,
                event
            });
            return;
        }
        const { offsetX, offsetY } = event;
        if (body) {
            showTooltip({
                root,
                data,
                x: offsetX,
                y: offsetY,
                render,
                event,
                single,
                position,
                enterable,
                mount,
                bounding,
                css,
                offset
            });
        }
        emitter.emit('tooltip:show', Object.assign(Object.assign({}, event), {
            nativeEvent: true,
            data: Object.assign(Object.assign({}, data), {
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataOf"])(element, view)
            })
        }));
    }, wait, {
        leading,
        trailing
    });
    const pointerleave = (event)=>{
        hideTooltip({
            root,
            single,
            emitter,
            event
        });
    };
    const pointerdown = (e)=>{
        if (clickLock) {
            root.setAttribute(LOCKED_SYMBOL, !root.getAttribute(LOCKED_SYMBOL));
        }
        pointermove(e);
    };
    const addEventListeners = ()=>{
        if (!disableNative) {
            root.addEventListener('pointerdown', pointerdown);
            root.addEventListener('pointermove', pointermove);
            // Only emit pointerleave event when the pointer is not in the root area.
            // !!!DO NOT USE pointerout event, it will emit when the pointer is in the child area.
            root.addEventListener('pointerleave', pointerleave);
            root.addEventListener('pointerup', pointerleave);
        }
    };
    const removeEventListeners = ()=>{
        if (!disableNative) {
            root.removeEventListener('pointerdown', pointerdown);
            root.removeEventListener('pointermove', pointermove);
            root.removeEventListener('pointerleave', pointerleave);
            root.removeEventListener('pointerup', pointerleave);
        }
    };
    const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw })=>{
        if (nativeEvent) return;
        const { data } = raw;
        const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectElementByData"])(elements, data, datum);
        if (!element) return;
        const bbox = element.getBBox();
        const { x, y, width, height } = bbox;
        const rootBBox = root.getBBox();
        pointermove({
            target: element,
            offsetX: offsetX !== undefined ? offsetX + rootBBox.x : x + width / 2,
            offsetY: offsetY !== undefined ? offsetY + rootBBox.y : y + height / 2
        });
    };
    const onTooltipHide = ({ nativeEvent } = {})=>{
        if (nativeEvent) return;
        hideTooltip({
            root,
            single,
            emitter,
            nativeEvent: false
        });
    };
    const onTooltipDisable = ()=>{
        removeEventListeners();
        destroyTooltip({
            root,
            single
        });
    };
    const onTooltipEnable = ()=>{
        addEventListeners();
    };
    emitter.on('tooltip:show', onTooltipShow);
    emitter.on('tooltip:hide', onTooltipHide);
    emitter.on('tooltip:enable', onTooltipEnable);
    emitter.on('tooltip:disable', onTooltipDisable);
    addEventListeners();
    return ()=>{
        removeEventListeners();
        emitter.off('tooltip:show', onTooltipShow);
        emitter.off('tooltip:hide', onTooltipHide);
        emitter.off('tooltip:enable', onTooltipEnable);
        emitter.off('tooltip:disable', onTooltipDisable);
        if (preserve) {
            hideTooltip({
                root,
                single,
                emitter,
                nativeEvent: false
            });
        } else {
            destroyTooltip({
                root,
                single
            });
        }
    };
}
function Tooltip(options) {
    const { shared, crosshairs, crosshairsX, crosshairsY, series, name, item = ()=>({}), facet = false } = options, rest = __rest(options, [
        "shared",
        "crosshairs",
        "crosshairsX",
        "crosshairsY",
        "series",
        "name",
        "item",
        "facet"
    ]);
    return (target, viewInstances, emitter)=>{
        const { container, view } = target;
        const { scale, markState, coordinate, theme } = view;
        // Get default value from mark states.
        const defaultSeries = interactionKeyof(markState, 'seriesTooltip');
        const defaultShowCrosshairs = interactionKeyof(markState, 'crosshairs');
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const isSeries = maybeValue(series, defaultSeries);
        const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
        if (rest.clickLock && !facet) plotArea.setAttribute(LOCKED_SYMBOL, false);
        // For non-facet and series tooltip.
        if (isSeries && hasSeries(markState) && !facet) {
            return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
                theme,
                elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
                scale,
                coordinate,
                crosshairs: crosshairsSetting,
                // the crosshairsX settings level: crosshairsX > crosshairs > false
                // it means crosshairsX default is false
                crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
                // crosshairsY default depend on the crossharisSettings
                crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
                item,
                emitter
            }));
        }
        // For facet and series tooltip.
        if (isSeries && facet) {
            // Get sub view instances for this view.
            const facetInstances = viewInstances.filter((d)=>d !== target && d.options.parentKey === target.options.key);
            const elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetG2Elements"])(target, viewInstances);
            // Use the scale of the first view.
            const scale = facetInstances[0].view.scale;
            const bbox = plotArea.getBounds();
            const startX = bbox.min[0];
            const startY = bbox.min[1];
            Object.assign(scale, {
                facet: true
            });
            const root = plotArea.parentNode.parentNode;
            if (rest.clickLock) root.setAttribute(LOCKED_SYMBOL, false);
            // @todo Nested structure rather than flat structure for facet?
            // Add listener to the root area.
            // @ts-ignore
            return seriesTooltip(root, Object.assign(Object.assign({}, rest), {
                theme,
                elements: ()=>elements,
                scale,
                coordinate,
                crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
                // the crosshairsX settings level: crosshairsX > crosshairs > false
                // it means crosshairsX default is false
                crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
                crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
                item,
                startX,
                startY,
                emitter
            }));
        }
        return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            scale,
            coordinate,
            groupKey: shared ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"])(view) : undefined,
            item,
            emitter,
            view,
            theme,
            shared
        }));
    };
}
Tooltip.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=tooltip.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementHighlight": (()=>ElementHighlight),
    "elementHighlight": (()=>elementHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
function elementHighlight(root, { elements: elementsof, datum, groupKey: eleGroupKey = (d)=>d, regionGroupKey = (d)=>d, link = false, background = false, delay = 60, scale, coordinate, emitter, state = {}, region = false, regionEleFilter = (el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_FIND_BY_X_MARKS"].includes(el.markType) }) {
    var _a, _b;
    const allElements = (_a = elementsof(root)) !== null && _a !== void 0 ? _a : [];
    const elements = region ? allElements.filter(regionEleFilter) : allElements;
    const elementSet = new Set(elements);
    const groupKey = region ? regionGroupKey : eleGroupKey;
    const keyGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, groupKey);
    const findElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createFindElementByEvent"])({
        elementsof,
        root,
        coordinate,
        scale
    });
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const [appendLink, removeLink] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderLink"])(Object.assign({
        elements,
        valueof,
        link,
        coordinate
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.active, 'link')));
    const [appendBackground, removeBackground, isBackground] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderBackground"])(Object.assign({
        document: root.ownerDocument,
        scale,
        coordinate,
        background,
        valueof
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.active, 'background')));
    const elementStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(state, {
        active: Object.assign({}, ((_b = state.active) === null || _b === void 0 ? void 0 : _b.offset) && {
            //Apply translate to mock slice out.
            transform: (...params)=>{
                const value = state.active.offset(...params);
                const [, i] = params;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["offsetTransform"])(elements[i], value, coordinate);
            }
        })
    });
    const useState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUseState"])(elementStyle, elements);
    const { updateState, removeState, hasState } = useState(valueof);
    let out; // Timer for delaying unhighlighted.
    const pointerover = (event)=>{
        const { nativeEvent = true } = event;
        let element = event.target;
        if (region) {
            element = findElement(event);
        }
        if (!elementSet.has(element)) return;
        if (out) clearTimeout(out);
        const k = groupKey(element);
        const group = keyGroup.get(k);
        const groupSet = new Set(group);
        for (const e of elements){
            if (groupSet.has(e)) {
                if (!hasState(e, 'active')) updateState(e, 'active');
            } else {
                updateState(e, 'inactive');
                removeLink(e);
            }
            if (e !== element) removeBackground(e);
        }
        appendBackground(element);
        appendLink(group);
        // Emit events.
        if (!nativeEvent) return;
        emitter.emit('element:highlight', {
            nativeEvent,
            data: {
                data: datum(element),
                group: group.map(datum)
            }
        });
    };
    const delayUnhighlighted = ()=>{
        if (out) clearTimeout(out);
        out = setTimeout(()=>{
            unhighlighted();
            out = null;
        }, delay);
    };
    const unhighlighted = (nativeEvent = true)=>{
        for (const e of elements){
            removeState(e, 'active', 'inactive');
            removeBackground(e);
            removeLink(e);
        }
        if (nativeEvent) {
            emitter.emit('element:unhighlight', {
                nativeEvent
            });
        }
    };
    const pointerout = (event)=>{
        let element = event.target;
        if (region) {
            element = findElement(event);
        }
        if (!element) {
            if (delay > 0) delayUnhighlighted();
            else unhighlighted();
            return;
        }
        if (background && !isBackground(element)) return;
        if (!background && !elementSet.has(element)) return;
        if (delay > 0) delayUnhighlighted();
        else unhighlighted();
    };
    const pointerleave = ()=>{
        unhighlighted();
    };
    root.addEventListener('pointerover', pointerover);
    root.addEventListener('pointermove', pointerover);
    root.addEventListener('pointerout', pointerout);
    root.addEventListener('pointerleave', pointerleave);
    const onRest = (e)=>{
        const { nativeEvent } = e;
        if (nativeEvent) return;
        unhighlighted(false);
    };
    const onHighlight = (e)=>{
        const { nativeEvent } = e;
        if (nativeEvent) return;
        const { data } = e.data;
        const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectElementByData"])(elements, data, datum);
        if (!element) return;
        pointerover({
            target: element,
            nativeEvent: false
        });
    };
    emitter.on('element:highlight', onHighlight);
    emitter.on('element:unhighlight', onRest);
    return ()=>{
        root.removeEventListener('pointerover', pointerover);
        root.removeEventListener('pointermove', pointerover);
        root.removeEventListener('pointerout', pointerout);
        root.removeEventListener('pointerleave', pointerleave);
        emitter.off('element:highlight', onHighlight);
        emitter.off('element:unhighlight', onRest);
        for (const e of elements){
            removeBackground(e);
            removeLink(e);
        }
    };
}
function ElementHighlight(_a) {
    var { delay, createGroup, createRegionGroup, background = false, link = false } = _a, rest = __rest(_a, [
        "delay",
        "createGroup",
        "createRegionGroup",
        "background",
        "link"
    ]);
    return (context, _, emitter)=>{
        const { container, view, options } = context;
        const { scale, coordinate } = view;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        return elementHighlight(plotArea, Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            groupKey: createGroup ? createGroup(view) : undefined,
            regionGroupKey: createRegionGroup ? createRegionGroup(view) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"])(view),
            coordinate,
            scale,
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(options, [
                [
                    'active',
                    background ? {} : {
                        lineWidth: '1',
                        stroke: '#000'
                    }
                ],
                'inactive'
            ]),
            background,
            link,
            delay,
            emitter
        }, rest));
    };
}
ElementHighlight.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementHighlightByX.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementHighlightByX": (()=>ElementHighlightByX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementHighlightByX(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementHighlight"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"]
    }));
}
ElementHighlightByX.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementHighlightByX.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementHighlightByColor": (()=>ElementHighlightByColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementHighlightByColor(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementHighlight"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorKey"]
    }));
}
ElementHighlightByColor.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementHighlightByColor.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementSelect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementSelect": (()=>ElementSelect),
    "elementSelect": (()=>elementSelect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$traverse$2d$elements$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/traverse-elements.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
function elementSelect(root, { elements: elementsof, datum, groupKey = (d)=>d, regionGroupKey = (d)=>d, link = false, single = false, multipleSelectHotkey, coordinate, background = false, scale, emitter, state = {}, region = false, regionEleFilter = (el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_FIND_BY_X_MARKS"].includes(el.markType) }) {
    var _a;
    const elements = elementsof(root);
    const elementSet = new Set(elements);
    const findElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createFindElementByEvent"])({
        elementsof,
        root,
        coordinate,
        scale
    });
    const keyGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, groupKey);
    const regionGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, regionGroupKey);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const [appendLink, removeLink] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderLink"])(Object.assign({
        link,
        elements,
        valueof,
        coordinate
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.selected, 'link')));
    const [appendBackground, removeBackground] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderBackground"])(Object.assign({
        document: root.ownerDocument,
        background,
        coordinate,
        scale,
        valueof
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.selected, 'background')));
    const elementStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(state, {
        selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {
            // Apply translate to mock slice out.
            transform: (...params)=>{
                const value = state.selected.offset(...params);
                const [, i] = params;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["offsetTransform"])(elements[i], value, coordinate);
            }
        })
    });
    const useState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUseState"])(elementStyle, elements);
    const { updateState, removeState, hasState } = useState(valueof);
    let isMultiSelectMode = !single; // "single" determines whether to multi-select by default
    let activeHotkey = null; // Track the currently active hotkey
    const clear = (nativeEvent = true)=>{
        for (const e of elements){
            removeState(e, 'selected', 'unselected');
            removeLink(e);
            removeBackground(e);
        }
        if (nativeEvent) emitter.emit('element:unselect', {
            nativeEvent: true
        });
        return;
    };
    const singleSelect = ({ event, element, nativeEvent = true, filter = (el)=>true, groupBy = groupKey, groupMap = keyGroup })=>{
        const filteredElements = elements.filter(filter);
        // Clear states if clicked selected element.
        if (hasState(element, 'selected')) clear();
        else {
            const k = groupBy(element);
            const group = groupMap.get(k);
            const groupSet = new Set(group);
            for (const e of filteredElements){
                if (groupSet.has(e)) updateState(e, 'selected');
                else {
                    updateState(e, 'unselected');
                    removeLink(e);
                }
                if (e !== element) removeBackground(e);
            }
            appendLink(group);
            appendBackground(element);
            if (!nativeEvent) return;
            emitter.emit('element:select', Object.assign(Object.assign({}, event), {
                nativeEvent,
                data: {
                    data: [
                        datum(element),
                        ...group.map(datum)
                    ]
                }
            }));
        }
    };
    const multipleSelect = ({ event, element, nativeEvent = true, filter = (el)=>true, groupBy = groupKey, groupMap = keyGroup })=>{
        const k = groupBy(element);
        const group = groupMap.get(k);
        const groupSet = new Set(group);
        const filteredElements = elements.filter(filter);
        if (!hasState(element, 'selected')) {
            const hasSelectedGroup = group.some((e)=>hasState(e, 'selected'));
            for (const e of filteredElements){
                if (groupSet.has(e)) updateState(e, 'selected');
                else if (!hasState(e, 'selected')) updateState(e, 'unselected');
            }
            // Append link for each group only once.
            if (!hasSelectedGroup && link) appendLink(group);
            appendBackground(element);
        } else {
            // If there is no selected elements after resetting this group,
            // clear the states.
            const hasSelected = elements.some((e)=>!groupSet.has(e) && hasState(e, 'selected'));
            if (!hasSelected) return clear();
            // If there are still some selected elements after resetting this group,
            // only remove the link.
            for (const e of group){
                updateState(e, 'unselected');
                removeLink(e);
                removeBackground(e);
            }
        }
        if (!nativeEvent) return;
        emitter.emit('element:select', Object.assign(Object.assign({}, event), {
            nativeEvent,
            data: {
                data: elements.filter((e)=>hasState(e, 'selected')).map(datum)
            }
        }));
    };
    const isClickElementOrGroup = (element)=>{
        if (elementSet.has(element)) return true;
        for (const group of elementSet){
            const found = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$traverse$2d$elements$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverseElements"])(group, (el)=>el === element);
            if (found) return true;
        }
        return false;
    };
    const getRealElement = (element)=>{
        if (elementSet.has(element)) return element;
        for (const group of elementSet){
            let match = null;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$traverse$2d$elements$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["traverseElements"])(group, (el)=>{
                if (el === element) match = group;
            });
            if (match) return match;
        }
        return element;
    };
    const click = (event)=>{
        const { target: element, nativeEvent = true } = event;
        const select = !isMultiSelectMode ? singleSelect : multipleSelect;
        let el = element;
        const isClickElement = isClickElementOrGroup(element);
        if (!region || isClickElement) {
            // Click non-element shape, reset.
            // Such as the rest of content area(background).
            if (!isClickElement) return clear();
            return select({
                event,
                element: getRealElement(el),
                nativeEvent,
                groupBy: groupKey
            });
        } else {
            // Click background region area, select elements in the region.
            // Get element at cursor.x position.
            el = findElement(event);
            if (!elementSet.has(el)) return clear();
            return select({
                event,
                element: el,
                nativeEvent,
                filter: regionEleFilter,
                groupBy: regionGroupKey,
                groupMap: regionGroup
            });
        }
    };
    // Handle keyboard events for multi-select mode
    const hotkeys = Array.isArray(multipleSelectHotkey) ? multipleSelectHotkey : [
        multipleSelectHotkey
    ];
    const handleKeyDown = (event)=>{
        if (hotkeys.includes(event.code) && !activeHotkey) {
            activeHotkey = event.code;
            isMultiSelectMode = true;
        }
    };
    const handleKeyUp = (event)=>{
        if (event.code === activeHotkey) {
            activeHotkey = null;
            isMultiSelectMode = false;
        }
    };
    root.addEventListener('click', click);
    if (multipleSelectHotkey) {
        // If a hotkey is set, the initial state should be single mode
        isMultiSelectMode = false;
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
    }
    const onSelect = (e)=>{
        const { nativeEvent, data } = e;
        if (nativeEvent) return;
        const selectedData = !isMultiSelectMode ? data.data.slice(0, 1) : data.data;
        for (const d of selectedData){
            const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectElementByData"])(elements, d, datum);
            click({
                target: element,
                nativeEvent: false
            });
        }
    };
    const onUnSelect = ()=>{
        clear(false);
    };
    emitter.on('element:select', onSelect);
    emitter.on('element:unselect', onUnSelect);
    return ()=>{
        for (const e of elements)removeLink(e);
        root.removeEventListener('click', click);
        if (multipleSelectHotkey) {
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        }
        emitter.off('element:select', onSelect);
        emitter.off('element:unselect', onUnSelect);
    };
}
function ElementSelect(_a) {
    var { createGroup, createRegionGroup, background = false, link = false } = _a, rest = __rest(_a, [
        "createGroup",
        "createRegionGroup",
        "background",
        "link"
    ]);
    return (context, _, emitter)=>{
        const { container, view, options } = context;
        const { coordinate, scale } = view;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        return elementSelect(plotArea, Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            groupKey: createGroup ? createGroup(view) : undefined,
            regionGroupKey: createRegionGroup ? createRegionGroup(view) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"])(view),
            coordinate,
            scale,
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(options, [
                [
                    'selected',
                    background ? {} : {
                        lineWidth: '1',
                        stroke: '#000'
                    }
                ],
                'unselected'
            ]),
            background,
            link,
            emitter
        }, rest));
    };
}
ElementSelect.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementSelect.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementSelectByX.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementSelectByX": (()=>ElementSelectByX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementSelect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementSelectByX(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementSelect"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"]
    }));
}
ElementSelectByX.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementSelectByX.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementSelectByColor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementSelectByColor": (()=>ElementSelectByColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementSelect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementSelectByColor(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementSelect"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorKey"]
    }));
}
ElementSelectByColor.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementSelectByColor.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/fisheye.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Fisheye": (()=>Fisheye)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
;
;
function maybeCoordinate(options) {
    const { coordinate = {} } = options;
    const { transform = [] } = coordinate;
    const fisheye = transform.find((d)=>d.type === 'fisheye');
    if (fisheye) return fisheye;
    const newFisheye = {
        type: 'fisheye'
    };
    transform.push(newFisheye);
    coordinate.transform = transform;
    options.coordinate = coordinate;
    return newFisheye;
}
function Fisheye({ wait = 30, leading, trailing = false }) {
    return (context)=>{
        const { options, update, setState, container } = context;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const updateFocus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
            const focus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(plotArea, event);
            if (!focus) {
                setState('fisheye');
                update();
                return;
            }
            setState('fisheye', (options)=>{
                // Clone options and mutate it.
                // Disable animation.
                const clonedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, options, {
                    interaction: {
                        tooltip: {
                            preserve: true
                        }
                    }
                });
                for (const mark of clonedOptions.marks)mark.animate = false;
                const [x, y] = focus;
                const fisheye = maybeCoordinate(clonedOptions);
                fisheye.focusX = x;
                fisheye.focusY = y;
                fisheye.visual = true;
                return clonedOptions;
            });
            update();
        }, wait, {
            leading,
            trailing
        });
        // Bind events.
        plotArea.addEventListener('pointerenter', updateFocus);
        plotArea.addEventListener('pointermove', updateFocus);
        plotArea.addEventListener('pointerleave', updateFocus);
        return ()=>{
            plotArea.removeEventListener('pointerenter', updateFocus);
            plotArea.removeEventListener('pointermove', updateFocus);
            plotArea.removeEventListener('pointerleave', updateFocus);
        };
    };
} //# sourceMappingURL=fisheye.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/chartIndex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ChartIndex": (()=>ChartIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sort.js [app-client] (ecmascript) <export default as sort>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript) <export default as min>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript) <export default as bisector>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
function maybeTransform(options) {
    const { transform = [] } = options;
    const normalizeY = transform.find((d)=>d.type === 'normalizeY');
    if (normalizeY) return normalizeY;
    const newNormalizeY = {
        type: 'normalizeY'
    };
    transform.push(newNormalizeY);
    options.transform = transform;
    return newNormalizeY;
}
function markValue(markState, markName, channels) {
    const [value] = Array.from(markState.entries()).filter(([mark])=>mark.type === markName).map(([mark])=>{
        const { encode } = mark;
        const channel = (name)=>{
            const channel = encode[name];
            return [
                name,
                channel ? channel.value : undefined
            ];
        };
        return Object.fromEntries(channels.map(channel));
    });
    return value;
}
function ChartIndex(_a) {
    var { wait = 20, leading, trailing = false, labelFormatter = (date)=>`${date}` } = _a, style = __rest(_a, [
        "wait",
        "leading",
        "trailing",
        "labelFormatter"
    ]);
    return (context)=>{
        const { view, container, update, setState } = context;
        const { markState, scale, coordinate } = view;
        // Get line mark value, exit if it is not existed.
        const value = markValue(markState, 'line', [
            'x',
            'y',
            'series'
        ]);
        if (!value) return;
        // Prepare channel value.
        const { y: Y, x: X, series: S = [] } = value;
        const I = Y.map((_, i)=>i);
        const sortedX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])(I.map((i)=>X[i]));
        // Prepare shapes.
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const lines = container.getElementsByClassName(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]);
        const labels = container.getElementsByClassName(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_CLASS_NAME"]);
        // The format of label key: `${elementKey}-index`,
        // group labels by elementKey.
        const keyofLabel = (d)=>d.__data__.key.split('-')[0];
        const keyLabels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(labels, keyofLabel);
        const rule = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"]({
            style: Object.assign({
                x1: 0,
                y1: 0,
                x2: 0,
                y2: plotArea.getAttribute('height'),
                stroke: 'black',
                lineWidth: 1
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'rule'))
        });
        const text = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
            style: Object.assign({
                x: 0,
                y: plotArea.getAttribute('height'),
                text: '',
                fontSize: 10
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'label'))
        });
        rule.append(text);
        plotArea.appendChild(rule);
        // Get the closet date to the rule.
        const dateByFocus = (coordinate, scaleX, focus)=>{
            const [normalizedX] = coordinate.invert(focus);
            const date = scaleX.invert(normalizedX);
            return sortedX[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bisectCenter"])(sortedX, date)];
        };
        // Update rule and label content.
        const updateRule = (focus, date)=>{
            rule.setAttribute('x1', focus[0]);
            rule.setAttribute('x2', focus[0]);
            text.setAttribute('text', labelFormatter(date));
        };
        // Store the new inner state alter rerender the view.
        let newView;
        // Rerender the view to update basis for each line.
        const updateBasisByRerender = (focus)=>__awaiter(this, void 0, void 0, function*() {
                // Find the closetDate to the rule.
                const { x: scaleX } = scale;
                const date = dateByFocus(coordinate, scaleX, focus);
                updateRule(focus, date);
                setState('chartIndex', (options)=>{
                    // Clone options and get line mark.
                    const clonedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, options);
                    const lineMark = clonedOptions.marks.find((d)=>d.type === 'line');
                    // Update domain of y scale for the line mark.
                    const r = (I)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(I, (i)=>+Y[i]) / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__["min"])(I, (i)=>+Y[i]);
                    const k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rollup"])(I, r, (i)=>S[i]).values());
                    const domainY = [
                        1 / k,
                        k
                    ];
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(lineMark, {
                        scale: {
                            y: {
                                domain: domainY
                            }
                        }
                    });
                    // Update normalize options.
                    const normalizeY = maybeTransform(lineMark);
                    normalizeY.groupBy = 'color';
                    normalizeY.basis = (I, Y)=>{
                        const i = I[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((i)=>X[+i]).center(I, date)];
                        return Y[i];
                    };
                    // Disable animation.
                    for (const mark of clonedOptions.marks)mark.animate = false;
                    return clonedOptions;
                });
                const newState = yield update('chartIndex');
                newView = newState.view;
            });
        // Only apply translate to update basis for each line.
        // If performance is ok, there is no need to use this
        // strategy to update basis.
        const updateBasisByTranslate = (focus)=>{
            // Find the closetDate to the rule.
            const { scale, coordinate } = newView;
            const { x: scaleX, y: scaleY } = scale;
            const date = dateByFocus(coordinate, scaleX, focus);
            updateRule(focus, date);
            // Translate mark and label for better performance.
            for (const line of lines){
                // Compute transform in y direction.
                const { seriesIndex: SI, key } = line.__data__;
                const i = SI[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((i)=>X[+i]).center(SI, date)];
                const p0 = [
                    0,
                    scaleY.map(1)
                ]; // basis point
                const p1 = [
                    0,
                    scaleY.map(Y[i] / Y[SI[0]])
                ];
                const [, y0] = coordinate.map(p0);
                const [, y1] = coordinate.map(p1);
                const dy = y0 - y1;
                line.setAttribute('transform', `translate(0, ${dy})`);
                // Update line and related label.
                const labels = keyLabels.get(key) || [];
                for (const label of labels){
                    // @todo Replace with style.transform.
                    // It now has unexpected behavior.
                    label.setAttribute('dy', dy);
                }
            }
        };
        const updateBasis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
            const focus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(plotArea, event);
            if (!focus) return;
            updateBasisByTranslate(focus);
        }, wait, {
            leading,
            trailing
        });
        updateBasisByRerender([
            0,
            0
        ]);
        plotArea.addEventListener('pointerenter', updateBasis);
        plotArea.addEventListener('pointermove', updateBasis);
        plotArea.addEventListener('pointerleave', updateBasis);
        return ()=>{
            rule.remove();
            plotArea.removeEventListener('pointerenter', updateBasis);
            plotArea.removeEventListener('pointermove', updateBasis);
            plotArea.removeEventListener('pointerleave', updateBasis);
        };
    };
}
ChartIndex.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=chartIndex.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/legendFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CATEGORY_LEGEND_CLASS_NAME": (()=>CATEGORY_LEGEND_CLASS_NAME),
    "CONTINUOUS_LEGEND_CLASS_NAME": (()=>CONTINUOUS_LEGEND_CLASS_NAME),
    "LEGEND_FOCUS_ICON_CLASS_NAME": (()=>LEGEND_FOCUS_ICON_CLASS_NAME),
    "LEGEND_ITEMS_CLASS_NAME": (()=>LEGEND_ITEMS_CLASS_NAME),
    "LEGEND_LABEL_CLASS_NAME": (()=>LEGEND_LABEL_CLASS_NAME),
    "LEGEND_MAKER_CLASS_NAME": (()=>LEGEND_MAKER_CLASS_NAME),
    "LegendFilter": (()=>LegendFilter),
    "attributesOf": (()=>attributesOf),
    "dataOf": (()=>dataOf),
    "focusIconOf": (()=>focusIconOf),
    "itemsOf": (()=>itemsOf),
    "labelOf": (()=>labelOf),
    "legendClearSetState": (()=>legendClearSetState),
    "legendsContinuousOf": (()=>legendsContinuousOf),
    "legendsOf": (()=>legendsOf),
    "markerOf": (()=>markerOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$component$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/component/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
;
;
const CATEGORY_LEGEND_CLASS_NAME = 'legend-category';
const CONTINUOUS_LEGEND_CLASS_NAME = 'legend-continuous';
const LEGEND_ITEMS_CLASS_NAME = 'items-item';
const LEGEND_MAKER_CLASS_NAME = 'legend-category-item-marker';
const LEGEND_LABEL_CLASS_NAME = 'legend-category-item-label';
const LEGEND_FOCUS_ICON_CLASS_NAME = 'legend-category-item-focus-group';
function markerOf(item) {
    return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
    return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function focusIconOf(item) {
    return item.getElementsByClassName(LEGEND_FOCUS_ICON_CLASS_NAME)[0];
}
function itemsOf(root) {
    return root.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root) {
    return root.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsContinuousOf(root) {
    return root.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function legendClearSetState(root, setState) {
    const legends = [
        ...legendsOf(root),
        ...legendsContinuousOf(root)
    ];
    legends.forEach((legend)=>{
        setState(legend, (v)=>v);
    });
}
function dataOf(root) {
    // legend -> layout -> container
    let parent = root.parentNode;
    while(parent && !parent.__data__){
        parent = parent.parentNode;
    }
    return parent.__data__;
}
function attributesOf(root) {
    let child = root;
    while(child && !child.attr('class').startsWith('legend')){
        child = child.children[0];
    }
    return child.attributes;
}
function legendFilterOrdinal(root, { legends, marker: markerOf, label: labelOf, datum, filter, defaultSelect, emitter, channel, state = {} }) {
    // Index handler by item.
    const itemClick = new Map();
    const itemPointerenter = new Map();
    const itemPointerout = new Map();
    const focusIconClick = new Map();
    const { unselected = {
        markerStroke: '#aaa',
        markerFill: '#aaa',
        labelFill: '#aaa'
    } } = state;
    const markerStyle = {
        unselected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(unselected, 'marker')
    };
    const labelStyle = {
        unselected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(unselected, 'label')
    };
    const { setState: setM, removeState: removeM } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(markerStyle, undefined);
    const { setState: setL, removeState: removeL } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(labelStyle, undefined);
    const items = Array.from(legends(root));
    let selectedValues = items.map(datum);
    const updateLegendState = ()=>{
        for (const item of items){
            const value = datum(item);
            const marker = markerOf(item);
            const label = labelOf(item);
            if (!selectedValues.includes(value)) {
                setM(marker, 'unselected');
                setL(label, 'unselected');
            } else {
                removeM(marker, 'unselected');
                removeL(label, 'unselected');
            }
        }
    };
    for (const item of items){
        // Defined handlers.
        const pointerenter = ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'pointer');
        };
        const pointerout = ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["restoreCursor"])(root);
        };
        const click = (event)=>__awaiter(this, void 0, void 0, function*() {
                const value = datum(item);
                const index = selectedValues.indexOf(value);
                if (index === -1) selectedValues.push(value);
                else selectedValues.splice(index, 1);
                yield filter(selectedValues);
                updateLegendState();
                const { nativeEvent = true } = event;
                if (!nativeEvent) return;
                if (selectedValues.length === items.length) {
                    emitter.emit('legend:reset', {
                        nativeEvent
                    });
                } else {
                    // Emit events.
                    emitter.emit('legend:filter', Object.assign(Object.assign({}, event), {
                        nativeEvent,
                        data: {
                            channel,
                            values: selectedValues
                        }
                    }));
                }
            });
        // Bind and store handlers.
        item.addEventListener('click', click);
        item.addEventListener('pointerenter', pointerenter);
        item.addEventListener('pointerout', pointerout);
        itemClick.set(item, click);
        itemPointerenter.set(item, pointerenter);
        itemPointerout.set(item, pointerout);
        const focusIcon = focusIconOf(item);
        if (focusIcon) {
            const focusClick = (event)=>__awaiter(this, void 0, void 0, function*() {
                    event.stopPropagation();
                    const value = datum(item);
                    const index = selectedValues.indexOf(value);
                    const { nativeEvent = true } = event;
                    if (index !== -1 && selectedValues.length === 1) {
                        if (!nativeEvent) return;
                        // If the item is already focused, reset to show all items.
                        selectedValues = items.map(datum);
                        yield filter(selectedValues);
                        updateLegendState();
                        emitter.emit('legend:reset', {
                            nativeEvent
                        });
                    } else {
                        // Otherwise, focus on the clicked item.
                        selectedValues = [
                            value
                        ];
                        yield filter(selectedValues);
                        updateLegendState();
                        if (!nativeEvent) return;
                        emitter.emit('legend:focus', Object.assign(Object.assign({}, event), {
                            nativeEvent,
                            data: {
                                channel,
                                value
                            }
                        }));
                    }
                });
            // Bind focus icon handlers.
            focusIcon.addEventListener('click', focusClick);
            focusIconClick.set(item, focusClick);
        }
    }
    const onFocus = (event)=>__awaiter(this, void 0, void 0, function*() {
            const { nativeEvent } = event;
            if (nativeEvent) return;
            const { data } = event;
            const { channel: specifiedChannel, value } = data;
            if (specifiedChannel !== channel) return;
            selectedValues = [
                value
            ];
            yield filter(selectedValues);
            updateLegendState();
        });
    const onFilter = (event)=>__awaiter(this, void 0, void 0, function*() {
            const { nativeEvent } = event;
            if (nativeEvent) return;
            const { data } = event;
            const { channel: specifiedChannel, values } = data;
            if (specifiedChannel !== channel) return;
            selectedValues = values;
            yield filter(selectedValues);
            updateLegendState();
        });
    const onEnd = (event)=>__awaiter(this, void 0, void 0, function*() {
            const { nativeEvent } = event;
            if (nativeEvent) return;
            selectedValues = items.map(datum);
            yield filter(selectedValues);
            updateLegendState();
        });
    emitter.on('legend:filter', onFilter);
    emitter.on('legend:focus', onFocus);
    emitter.on('legend:reset', onEnd);
    if (defaultSelect) {
        emitter.emit('legend:filter', {
            data: {
                channel,
                values: defaultSelect
            }
        });
    }
    return ()=>{
        for (const item of items){
            item.removeEventListener('click', itemClick.get(item));
            item.removeEventListener('pointerenter', itemPointerenter.get(item));
            item.removeEventListener('pointerout', itemPointerout.get(item));
            const focusIcon = focusIconOf(item);
            if (focusIcon) {
                focusIcon.removeEventListener('click', focusIconClick.get(item));
            }
            emitter.on('legend:focus', onFocus);
            emitter.off('legend:filter', onFilter);
            emitter.off('legend:reset', onEnd);
        }
    };
}
function legendFilterContinuous(_, { legend, filter, emitter, channel }) {
    const onValueChange = ({ detail: { value } })=>{
        filter(value);
        emitter.emit({
            nativeEvent: true,
            data: {
                channel,
                values: value
            }
        });
    };
    legend.addEventListener('valuechange', onValueChange);
    return ()=>{
        legend.removeEventListener('valuechange', onValueChange);
    };
}
function filterView(context, { legend, channel, value, ordinal, channels, allChannels, facet = false }) {
    return __awaiter(this, void 0, void 0, function*() {
        const { view, update, setState } = context;
        setState(legend, (viewOptions)=>{
            const { marks } = viewOptions;
            // Add filter transform for every marks,
            // which will skip for mark without color channel.
            const newMarks = marks.map((mark)=>{
                if (mark.type === 'legends') return mark;
                // Skip Annotation marks.
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$component$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ANNOTATION_MARKS"].includes(mark.type)) return mark;
                // Inset after aggregate transform, such as group, and bin.
                const { transform = [], data = [] } = mark;
                const index = transform.findIndex(({ type })=>type.startsWith('group') || type.startsWith('bin'));
                const newTransform = [
                    ...transform
                ];
                if (data.length) {
                    newTransform.splice(index + 1, 0, {
                        type: 'filter',
                        [channel]: {
                            value,
                            ordinal
                        }
                    });
                }
                // Set domain of scale to preserve encoding.
                const newScale = Object.fromEntries(channels.map((channel)=>[
                        channel,
                        {
                            domain: view.scale[channel].getOptions().domain
                        }
                    ]));
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, mark, Object.assign(Object.assign({
                    transform: newTransform,
                    scale: newScale
                }, !ordinal && {
                    animate: false
                }), {
                    legend: facet ? false : Object.fromEntries(allChannels.map((d)=>[
                            d,
                            {
                                preserve: true
                            }
                        ]))
                }));
            });
            return Object.assign(Object.assign({}, viewOptions), {
                marks: newMarks
            });
        });
        yield update();
    });
}
function filterFacets(facets, options) {
    for (const facet of facets){
        filterView(facet, Object.assign(Object.assign({}, options), {
            facet: true
        }));
    }
}
function LegendFilter() {
    return (context, contexts, emitter)=>{
        const { container } = context;
        const facets = contexts.filter((d)=>d !== context);
        const isFacet = facets.length > 0;
        const channelsOf = (legend)=>{
            return dataOf(legend).scales.map((d)=>d.name);
        };
        const legends = [
            ...legendsOf(container),
            ...legendsContinuousOf(container)
        ];
        const allChannels = legends.flatMap(channelsOf);
        const filter = isFacet ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(filterFacets, 50, {
            trailing: true
        }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(filterView, 50, {
            trailing: true
        });
        const removes = legends.map((legend)=>{
            const { name: channel, domain } = dataOf(legend).scales[0];
            const channels = channelsOf(legend);
            const common = {
                legend,
                channel,
                channels,
                allChannels
            };
            if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
                return legendFilterOrdinal(container, {
                    legends: itemsOf,
                    marker: markerOf,
                    label: labelOf,
                    datum: (d)=>{
                        const { __data__: datum } = d;
                        const { index } = datum;
                        return domain[index];
                    },
                    filter: (value)=>{
                        const options = Object.assign(Object.assign({}, common), {
                            value,
                            ordinal: true
                        });
                        if (isFacet) filter(facets, options);
                        else filter(context, options);
                    },
                    state: legend.attributes.state,
                    defaultSelect: legend.attributes.defaultSelect,
                    channel,
                    emitter
                });
            } else {
                return legendFilterContinuous(container, {
                    legend,
                    filter: (value)=>{
                        const options = Object.assign(Object.assign({}, common), {
                            value,
                            ordinal: false
                        });
                        if (isFacet) filter(facets, options);
                        else filter(context, options);
                    },
                    emitter,
                    channel
                });
            }
        });
        return ()=>{
            removes.forEach((remove)=>remove());
        };
    };
} //# sourceMappingURL=legendFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/legendHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LegendHighlight": (()=>LegendHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$vendor$2f$es$2f$d3$2d$array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/vendor/es/d3-array.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/legendFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
;
;
;
;
function LegendHighlight() {
    return (context, _, emitter)=>{
        const { container, view, options } = context;
        const legends = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["legendsOf"])(container);
        const elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"])(container);
        const channelOf = (legend)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataOf"])(legend).scales[0].name;
        };
        const scaleOf = (channel)=>{
            const { scale: { [channel]: scale } } = view;
            return scale;
        };
        const markState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(options, [
            'active',
            'inactive'
        ]);
        const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view));
        const destroys = [];
        // Bind events for each legend.
        for (const legend of legends){
            const datumOf = (item)=>{
                const { data } = legend.attributes;
                const { __data__: datum } = item;
                const { index } = datum;
                return data[index].label;
            };
            const channel = channelOf(legend);
            const items = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["itemsOf"])(legend);
            const scale = scaleOf(channel);
            const elementGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, (d)=>scale.invert(d.__data__[channel]));
            const { state: legendState = {} } = legend.attributes;
            const { inactive = {} } = legendState;
            const { setState, removeState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(markState, valueof);
            // Handle styles of inner item.
            const markerStyle = {
                inactive: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(inactive, 'marker')
            };
            const labelStyle = {
                inactive: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(inactive, 'label')
            };
            const { setState: setM, removeState: removeM } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(markerStyle);
            const { setState: setL, removeState: removeL } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(labelStyle);
            const updateLegendState = (highlight)=>{
                for (const item of items){
                    const marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markerOf"])(item);
                    const label = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelOf"])(item);
                    if (item === highlight || highlight === null) {
                        removeM(marker, 'inactive');
                        removeL(label, 'inactive');
                    } else {
                        setM(marker, 'inactive');
                        setL(label, 'inactive');
                    }
                }
            };
            const highlightItem = (event, item)=>{
                // Update UI.
                const value = datumOf(item);
                const elementSet = new Set(elementGroup.get(value));
                for (const e of elements){
                    if (elementSet.has(e)) setState(e, 'active');
                    else setState(e, 'inactive');
                }
                updateLegendState(item);
                // Emit events.
                const { nativeEvent = true } = event;
                if (!nativeEvent) return;
                emitter.emit('legend:highlight', Object.assign(Object.assign({}, event), {
                    nativeEvent,
                    data: {
                        channel,
                        value
                    }
                }));
            };
            const itemPointerover = new Map();
            // Add listener for the legend items.
            for (const item of items){
                const pointerover = (event)=>{
                    highlightItem(event, item);
                };
                item.addEventListener('pointerover', pointerover);
                itemPointerover.set(item, pointerover);
            }
            // Add listener for the legend group.
            const pointerleave = (event)=>{
                for (const e of elements)removeState(e, 'inactive', 'active');
                updateLegendState(null);
                // Emit events.
                const { nativeEvent = true } = event;
                if (!nativeEvent) return;
                emitter.emit('legend:unhighlight', {
                    nativeEvent
                });
            };
            const onHighlight = (event)=>{
                const { nativeEvent, data } = event;
                if (nativeEvent) return;
                const { channel: specifiedChannel, value } = data;
                if (specifiedChannel !== channel) return;
                const item = items.find((d)=>datumOf(d) === value);
                if (!item) return;
                highlightItem({
                    nativeEvent: false
                }, item);
            };
            const onUnHighlight = (event)=>{
                const { nativeEvent } = event;
                if (nativeEvent) return;
                pointerleave({
                    nativeEvent: false
                });
            };
            legend.addEventListener('pointerleave', pointerleave);
            emitter.on('legend:highlight', onHighlight);
            emitter.on('legend:unhighlight', onUnHighlight);
            const destroy = ()=>{
                legend.removeEventListener(pointerleave);
                emitter.off('legend:highlight', onHighlight);
                emitter.off('legend:unhighlight', onUnHighlight);
                for (const [item, pointerover] of itemPointerover){
                    item.removeEventListener(pointerover);
                }
            };
            destroys.push(destroy);
        }
        return ()=>destroys.forEach((d)=>d());
    };
} //# sourceMappingURL=legendHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushHighlight": (()=>BrushHighlight),
    "brush": (()=>brush),
    "brushHighlight": (()=>brushHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$createElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/createElement.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
function intersect(bbox1, bbox2) {
    const [minX1, minY1, maxX1, maxY1] = bbox1;
    const [minX2, minY2, maxX2, maxY2] = bbox2;
    return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x, y, x1, y1, extent) {
    const [minX, minY, maxX, maxY] = extent;
    return [
        Math.max(minX, Math.min(x, x1)),
        Math.max(minY, Math.min(y, y1)),
        Math.min(maxX, Math.max(x, x1)),
        Math.min(maxY, Math.max(y, y1))
    ];
}
function bboxOf(root) {
    const { width, height } = root.getBBox();
    return [
        0,
        0,
        width,
        height
    ];
}
function applyStyle(selection, style) {
    for (const [key, value] of Object.entries(style)){
        selection.style(key, value);
    }
}
const ResizableMask = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$createElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])((g)=>{
    const _a = g.attributes, { x, y, width, height, class: className, renders = {}, handleSize: size = 10, document } = _a, style = __rest(_a, [
        "x",
        "y",
        "width",
        "height",
        "class",
        "renders",
        "handleSize",
        "document"
    ]);
    if (!document || width === undefined || height === undefined || x === undefined || y === undefined) return;
    const half = size / 2;
    const renderRect = (g, options, document)=>{
        if (!g.handle) {
            g.handle = document.createElement('rect');
            g.append(g.handle);
        }
        const { handle } = g;
        handle.attr(options);
        return handle;
    };
    const _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omitPrefixObject"])(style, 'handleNW', 'handleNE'), 'handleN'), { render: handleNRender = renderRect } = _b, handleNStyle = __rest(_b, [
        "render"
    ]);
    const _c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleE'), { render: handleERender = renderRect } = _c, handleEStyle = __rest(_c, [
        "render"
    ]);
    const _d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omitPrefixObject"])(style, 'handleSE', 'handleSW'), 'handleS'), { render: handleSRender = renderRect } = _d, handleSStyle = __rest(_d, [
        "render"
    ]);
    const _e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleW'), { render: handleWRender = renderRect } = _e, handleWStyle = __rest(_e, [
        "render"
    ]);
    const _f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleNW'), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest(_f, [
        "render"
    ]);
    const _g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleNE'), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest(_g, [
        "render"
    ]);
    const _h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleSE'), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest(_h, [
        "render"
    ]);
    const _j = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleSW'), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest(_j, [
        "render"
    ]);
    const renderHandle = (g, renderNode)=>{
        const { id } = g;
        const handle = renderNode(g, g.attributes, document);
        handle.id = id;
        handle.style.draggable = true;
    };
    const appendHandle = (handleRender)=>{
        return ()=>{
            const Node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$createElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])((g)=>renderHandle(g, handleRender));
            return new Node({});
        };
    };
    const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(g).attr('className', className).style('transform', `translate(${x}, ${y})`).style('draggable', true);
    container.maybeAppend('selection', 'rect').style('draggable', true).style('fill', 'transparent').call(applyStyle, Object.assign(Object.assign({
        width,
        height
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omitPrefixObject"])(style, 'handle')), {
        transform: undefined
    }));
    container.maybeAppend('handle-n', appendHandle(handleNRender)).style('x', half).style('y', -half).style('width', width - size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNStyle);
    container.maybeAppend('handle-e', appendHandle(handleERender)).style('x', width - half).style('y', half).style('width', size).style('height', height - size).style('fill', 'transparent').call(applyStyle, handleEStyle);
    container.maybeAppend('handle-s', appendHandle(handleSRender)).style('x', half).style('y', height - half).style('width', width - size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSStyle);
    container.maybeAppend('handle-w', appendHandle(handleWRender)).style('x', -half).style('y', half).style('width', size).style('height', height - size).style('fill', 'transparent').call(applyStyle, handleWStyle);
    container.maybeAppend('handle-nw', appendHandle(handleNWRender)).style('x', -half).style('y', -half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNWStyle);
    container.maybeAppend('handle-ne', appendHandle(handleNERender)).style('x', width - half).style('y', -half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNEStyle);
    container.maybeAppend('handle-se', appendHandle(handleSERender)).style('x', width - half).style('y', height - half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSEStyle);
    container.maybeAppend('handle-sw', appendHandle(handleSWRender)).style('x', -half).style('y', height - half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSWStyle);
});
function brush(root, _a) {
    var { brushed = ()=>{}, brushended = ()=>{}, brushcreated = ()=>{}, brushstarted = ()=>{}, brushupdated = ()=>{}, extent = bboxOf(root), brushRegion = (x, y, x1, y1, extent)=>[
            x,
            y,
            x1,
            y1
        ], reverse = false, fill = '#777', fillOpacity = '0.3', stroke = '#fff', selectedHandles = [
        'handle-n',
        'handle-e',
        'handle-s',
        'handle-w',
        'handle-nw',
        'handle-ne',
        'handle-se',
        'handle-sw'
    ] } = _a, style = __rest(_a, [
        "brushed",
        "brushended",
        "brushcreated",
        "brushstarted",
        "brushupdated",
        "extent",
        "brushRegion",
        "reverse",
        "fill",
        "fillOpacity",
        "stroke",
        "selectedHandles"
    ]);
    let start = null; // Start point of mask.
    let end = null; // End point of mask.
    let moveStart = null; // Start point of moving mask.
    let mask = null; // Mask instance.
    let background = null;
    let creating = false;
    const [originX, originY, width, height] = extent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'crosshair');
    root.style.draggable = true; // Make it response to drag event.
    // Remove old mask and init new mask.
    const initMask = (x, y, event)=>{
        brushstarted(event);
        if (mask) mask.remove();
        if (background) background.remove();
        start = [
            x,
            y
        ];
        if (reverse) return initReverseMask();
        initNormalMask();
    };
    const initReverseMask = ()=>{
        background = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]({
            style: Object.assign(Object.assign({}, style), {
                fill,
                fillOpacity,
                stroke,
                pointerEvents: 'none'
            })
        });
        mask = new ResizableMask({
            // @ts-ignore
            style: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                draggable: true,
                document: root.ownerDocument
            },
            className: 'mask'
        });
        root.appendChild(background);
        root.appendChild(mask);
    };
    const initNormalMask = ()=>{
        mask = new ResizableMask({
            // @ts-ignore
            style: Object.assign(Object.assign({
                document: root.ownerDocument,
                x: 0,
                y: 0
            }, style), {
                fill,
                fillOpacity,
                stroke,
                draggable: true
            }),
            className: 'mask'
        });
        root.appendChild(mask);
    };
    // Remove mask and reset states.
    const removeMask = (emit = true)=>{
        if (mask) mask.remove();
        if (background) background.remove();
        start = null;
        end = null;
        moveStart = null;
        creating = false;
        mask = null;
        background = null;
        brushended(emit);
    };
    // Update mask and invoke brushended callback.
    const updateMask = (start, end, emit = true)=>{
        const [x, y, x1, y1] = normalizeBounds(start[0], start[1], end[0], end[1], extent);
        const [fx, fy, fx1, fy1] = brushRegion(x, y, x1, y1, extent);
        if (reverse) updateReverseMask(fx, fy, fx1, fy1);
        else updateNormalMask(fx, fy, fx1, fy1);
        brushed(fx, fy, fx1, fy1, emit);
        return [
            fx,
            fy,
            fx1,
            fy1
        ];
    };
    const updateNormalMask = (x, y, x1, y1)=>{
        mask.style.x = x;
        mask.style.y = y;
        mask.style.width = x1 - x;
        mask.style.height = y1 - y;
    };
    const updateReverseMask = (x, y, x1, y1)=>{
        background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x},${y}L${x},${y1}L${x1},${y1}L${x1},${y}Z
    `;
        mask.style.x = x;
        mask.style.y = y;
        mask.style.width = x1 - x;
        mask.style.height = y1 - y;
    };
    // Move and update mask.
    const moveMask = (current)=>{
        const clip = (dt, start, end, min, max)=>{
            if (dt + start < min) return min - start;
            if (dt + end > max) return max - end;
            return dt;
        };
        const dx = current[0] - moveStart[0];
        const dy = current[1] - moveStart[1];
        const dx1 = clip(dx, start[0], end[0], originX, width);
        const dy1 = clip(dy, start[1], end[1], originY, height);
        const currentStart = [
            start[0] + dx1,
            start[1] + dy1
        ];
        const currentEnd = [
            end[0] + dx1,
            end[1] + dy1
        ];
        updateMask(currentStart, currentEnd);
    };
    const handles = {
        'handle-n': {
            vector: [
                0,
                1,
                0,
                0
            ],
            cursor: 'ns-resize'
        },
        'handle-e': {
            vector: [
                0,
                0,
                1,
                0
            ],
            cursor: 'ew-resize'
        },
        'handle-s': {
            vector: [
                0,
                0,
                0,
                1
            ],
            cursor: 'ns-resize'
        },
        'handle-w': {
            vector: [
                1,
                0,
                0,
                0
            ],
            cursor: 'ew-resize'
        },
        'handle-nw': {
            vector: [
                1,
                1,
                0,
                0
            ],
            cursor: 'nwse-resize'
        },
        'handle-ne': {
            vector: [
                0,
                1,
                1,
                0
            ],
            cursor: 'nesw-resize'
        },
        'handle-se': {
            vector: [
                0,
                0,
                1,
                1
            ],
            cursor: 'nwse-resize'
        },
        'handle-sw': {
            vector: [
                1,
                0,
                0,
                1
            ],
            cursor: 'nesw-resize'
        }
    };
    const isMask = (target)=>{
        return isSelection(target) || isHandle(target);
    };
    const isHandle = (target)=>{
        const { id } = target;
        if (selectedHandles.indexOf(id) === -1) return false;
        return new Set(Object.keys(handles)).has(id);
    };
    const isSelection = (target)=>{
        return target === mask.getElementById('selection');
    };
    // If target is plot area, create mask.
    // If target is mask, about to update position.
    const dragstart = (event)=>{
        const { target } = event;
        const [offsetX, offsetY] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushMousePosition"])(root, event);
        if (!mask || !isMask(target)) {
            initMask(offsetX, offsetY, event);
            creating = true;
            return;
        }
        if (isMask(target)) {
            moveStart = [
                offsetX,
                offsetY
            ];
        }
    };
    const drag = (event)=>{
        const { target } = event;
        const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushMousePosition"])(root, event);
        if (!start) return;
        // If target is plot area, resize mask.
        if (!moveStart) return updateMask(start, mouse);
        // If target is selection area, move mask.
        if (isSelection(target)) return moveMask(mouse);
        // If target is handle area, resize mask.
        const [dx, dy] = [
            mouse[0] - moveStart[0],
            mouse[1] - moveStart[1]
        ];
        const { id } = target;
        if (handles[id]) {
            const [sx, sy, ex, ey] = handles[id].vector;
            return updateMask([
                start[0] + dx * sx,
                start[1] + dy * sy
            ], [
                end[0] + dx * ex,
                end[1] + dy * ey
            ]);
        }
    };
    // If target is plot area, finish creating.
    // If target is mask, finish moving mask.
    const dragend = (event)=>{
        if (moveStart) {
            moveStart = null;
            // Update start and end;
            const { x, y, width, height } = mask.style;
            start = [
                x,
                y
            ];
            end = [
                x + width,
                y + height
            ];
            brushupdated(x, y, x + width, y + height, event);
            return;
        }
        end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushMousePosition"])(root, event);
        const [fx, fy, fx1, fy1] = updateMask(start, end);
        creating = false;
        brushcreated(fx, fy, fx1, fy1, event);
    };
    // Hide mask.
    const click = (event)=>{
        const { target } = event;
        if (mask && !isMask(target)) removeMask();
    };
    // Update cursor depends on hovered element.
    const pointermove = (event)=>{
        const { target } = event;
        if (!mask || !isMask(target) || creating) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'crosshair');
        else if (isSelection(target)) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'move');
        else if (isHandle(target)) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, handles[target.id].cursor);
    };
    const pointerleave = ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'default');
    };
    root.addEventListener('dragstart', dragstart);
    root.addEventListener('drag', drag);
    root.addEventListener('dragend', dragend);
    root.addEventListener('click', click);
    root.addEventListener('pointermove', pointermove);
    root.addEventListener('pointerleave', pointerleave);
    return {
        mask,
        move (x, y, x1, y1, emit = true) {
            if (!mask) initMask(x, y, {});
            start = [
                x,
                y
            ];
            end = [
                x1,
                y1
            ];
            updateMask([
                x,
                y
            ], [
                x1,
                y1
            ], emit);
        },
        remove (emit = true) {
            if (mask) removeMask(emit);
        },
        destroy () {
            // Do not emit brush:end event.
            if (mask) removeMask(false);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'default');
            root.removeEventListener('dragstart', dragstart);
            root.removeEventListener('drag', drag);
            root.removeEventListener('dragend', dragend);
            root.removeEventListener('click', click);
            root.removeEventListener('pointermove', pointermove);
            root.removeEventListener('pointerleave', pointerleave);
        }
    };
}
function selectSiblingViews(target, viewInstances, brushKey) {
    return viewInstances.filter((d)=>{
        if (d === target) return false;
        const { interaction = {} } = d.options;
        return Object.values(interaction).find((d)=>d.brushKey === brushKey);
    });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(d.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d)=>d.options);
}
function brushHighlight(root, _a) {
    var { elements: elementof, selectedHandles, siblings: siblingsof = (root)=>[], datum, brushRegion, extent: optionalExtent, reverse, scale, coordinate, series = false, key = (d)=>d, bboxOf = (root)=>{
        const { x, y, width, height } = root.style;
        return {
            x,
            y,
            width,
            height
        };
    }, state = {}, emitter } = _a, rest = __rest(_a, [
        "elements",
        "selectedHandles",
        "siblings",
        "datum",
        "brushRegion",
        "extent",
        "reverse",
        "scale",
        "coordinate",
        "series",
        "key",
        "bboxOf",
        "state",
        "emitter"
    ]);
    const elements = elementof(root);
    const siblings = siblingsof(root);
    const siblingElements = siblings.flatMap(elementof);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const brushStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'mask');
    const { setState, removeState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(state, valueof);
    const clonedElement = new Map();
    const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf(root);
    const extent = optionalExtent ? optionalExtent : [
        0,
        0,
        rootWidth,
        rootHeight
    ];
    const brushended = ()=>{
        for (const element of [
            ...elements,
            ...siblingElements
        ]){
            removeState(element, 'active', 'inactive');
        }
    };
    const brushed = (x, y, x1, y1)=>{
        var _a;
        // Hide brush for the sibling view.
        for (const sibling of siblings)(_a = sibling.brush) === null || _a === void 0 ? void 0 : _a.remove();
        // Store the key of the active element.
        const keys = new Set();
        // Highlight and store selected elements.
        for (const element of elements){
            const { min, max } = element.getLocalBounds();
            const [ex, ey] = min;
            const [ex1, ey1] = max;
            if (!intersect([
                ex,
                ey,
                ex1,
                ey1
            ], [
                x,
                y,
                x1,
                y1
            ])) {
                setState(element, 'inactive');
            } else {
                setState(element, 'active');
                keys.add(key(element));
            }
        }
        // Highlight elements with same key in sibling view.
        for (const element of siblingElements){
            if (keys.has(key(element))) setState(element, 'active');
            else setState(element, 'inactive');
        }
    };
    const seriesBrushend = ()=>{
        for (const element of elements)removeState(element, 'inactive');
        for (const cloned of clonedElement.values())cloned.remove();
        clonedElement.clear();
    };
    const seriesBrushed = (x, y, x1, y1)=>{
        const clone = (element)=>{
            const cloned = element.cloneNode();
            cloned.__data__ = element.__data__;
            element.parentNode.appendChild(cloned);
            clonedElement.set(element, cloned);
            return cloned;
        };
        // Create a clipPath shared between all children.
        const clipPath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            style: {
                x: x + ordinalX,
                y: y + ordinalY,
                width: x1 - x,
                height: y1 - y
            }
        });
        root.appendChild(clipPath);
        for (const element of elements){
            const cloned = clonedElement.get(element) || clone(element);
            cloned.style.clipPath = clipPath;
            setState(element, 'inactive');
            setState(cloned, 'active');
        }
    };
    const brushHandler = brush(root, Object.assign(Object.assign({}, brushStyle), {
        extent,
        brushRegion,
        reverse,
        selectedHandles,
        brushended: (emit)=>{
            const handler = series ? seriesBrushend : brushended;
            if (emit) {
                emitter.emit('brush:remove', {
                    nativeEvent: true
                });
            }
            handler();
        },
        brushed: (x, y, x1, y1, emit)=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            if (emit) {
                emitter.emit('brush:highlight', {
                    nativeEvent: true,
                    data: {
                        selection
                    }
                });
            }
            const handler = series ? seriesBrushed : brushed;
            handler(x, y, x1, y1);
        },
        brushcreated: (x, y, x1, y1, event)=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            emitter.emit('brush:end', Object.assign(Object.assign({}, event), {
                nativeEvent: true,
                data: {
                    selection
                }
            }));
        },
        brushupdated: (x, y, x1, y1, event)=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            emitter.emit('brush:end', Object.assign(Object.assign({}, event), {
                nativeEvent: true,
                data: {
                    selection
                }
            }));
        },
        brushstarted: (e)=>{
            emitter.emit('brush:start', e);
        }
    }));
    // Move brush and highlight data.
    const onHighlight = ({ nativeEvent, data })=>{
        if (nativeEvent) return;
        const { selection } = data;
        const [x, y, x1, y1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pixelsOf"])(selection, scale, coordinate);
        brushHandler.move(x, y, x1, y1, false);
    };
    emitter.on('brush:highlight', onHighlight);
    // Remove brush and reset data.
    const onRemove = ({ nativeEvent } = {})=>{
        if (nativeEvent) return;
        brushHandler.remove(false);
    };
    emitter.on('brush:remove', onRemove);
    // Remove event handlers.
    const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
    brushHandler.destroy = ()=>{
        emitter.off('brush:highlight', onHighlight);
        emitter.off('brush:remove', onRemove);
        preBrushDestroy();
    };
    return brushHandler;
}
function BrushHighlight(_a) {
    var { facet, brushKey } = _a, rest = __rest(_a, [
        "facet",
        "brushKey"
    ]);
    return (target, viewInstances, emitter)=>{
        const { container, view, options } = target;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const defaultOptions = {
            maskFill: '#777',
            maskFillOpacity: '0.3',
            maskStroke: '#fff',
            reverse: false
        };
        const defaultStates = [
            'active',
            [
                'inactive',
                {
                    opacity: 0.5
                }
            ]
        ];
        const { scale, coordinate } = view;
        if (facet) {
            const bbox = plotArea.getBounds();
            const x = bbox.min[0];
            const y = bbox.min[1];
            const x1 = bbox.max[0];
            const y1 = bbox.max[1];
            return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
                elements: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetG2Elements"])(target, viewInstances),
                datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetViews"])(target, viewInstances).map((d)=>d.view)),
                brushRegion: (x, y, x1, y1)=>[
                        x,
                        y,
                        x1,
                        y1
                    ],
                extent: [
                    x,
                    y,
                    x1,
                    y1
                ],
                state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetViews"])(target, viewInstances).map((d)=>d.options), defaultStates),
                emitter,
                scale,
                coordinate,
                selectedHandles: undefined
            }, defaultOptions), rest));
        }
        const brush = brushHighlight(plotArea, Object.assign(Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            key: (element)=>element.__data__.key,
            siblings: ()=>selectSiblingContainers(target, viewInstances, brushKey),
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])([
                view,
                ...selectSiblingViews(target, viewInstances, brushKey).map((d)=>d.view)
            ]),
            brushRegion: (x, y, x1, y1)=>[
                    x,
                    y,
                    x1,
                    y1
                ],
            extent: undefined,
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])([
                options,
                ...selectSiblingOptions(target, viewInstances, brushKey)
            ], defaultStates),
            emitter,
            scale,
            coordinate,
            selectedHandles: undefined
        }, defaultOptions), rest));
        // Bind brush to the view it belongs to.
        //@ts-ignore
        plotArea.brush = brush;
        return ()=>brush.destroy();
    };
}
// Ensure BrushHighlight gets reapplied when view updates (e.g., after slider filter)
BrushHighlight.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=brushHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushXHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushXHighlight": (()=>BrushXHighlight),
    "brushXRegion": (()=>brushXRegion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
;
function brushXRegion(x, y, x1, y1, extent) {
    const [, minY, , maxY] = extent;
    return [
        x,
        minY,
        x1,
        maxY
    ];
}
function BrushXHighlight(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushHighlight"])(Object.assign(Object.assign({}, options), {
        brushRegion: brushXRegion,
        selectedHandles: [
            'handle-e',
            'handle-w'
        ]
    }));
} //# sourceMappingURL=brushXHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushYHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushYHighlight": (()=>BrushYHighlight),
    "brushYRegion": (()=>brushYRegion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
;
function brushYRegion(x, y, x1, y1, extent) {
    const [minX, , maxX] = extent;
    return [
        minX,
        y,
        maxX,
        y1
    ];
}
function BrushYHighlight(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushHighlight"])(Object.assign(Object.assign({}, options), {
        brushRegion: brushYRegion,
        selectedHandles: [
            'handle-n',
            'handle-s'
        ]
    }));
} //# sourceMappingURL=brushYHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AXIS_CLASS_NAME": (()=>AXIS_CLASS_NAME),
    "AXIS_HOT_AREA_CLASS_NAME": (()=>AXIS_HOT_AREA_CLASS_NAME),
    "AXIS_LINE_CLASS_NAME": (()=>AXIS_LINE_CLASS_NAME),
    "AXIS_MAIN_CLASS_NAME": (()=>AXIS_MAIN_CLASS_NAME),
    "BrushAxisHighlight": (()=>BrushAxisHighlight),
    "brushAxisHighlight": (()=>brushAxisHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushYHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushXHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
const AXIS_CLASS_NAME = 'axis';
const AXIS_LINE_CLASS_NAME = 'axis-line';
const AXIS_MAIN_CLASS_NAME = 'axis-main-group';
const AXIS_HOT_AREA_CLASS_NAME = 'axis-hot-area';
function axesOf(container) {
    return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
    return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
    return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
// Use the bounds of main group of axis as the bounds of axis,
// get rid of grid and title.
function boundsOfAxis(axis) {
    return mainGroupOf(axis).getLocalBounds();
}
// Brush for vertical axis.
function verticalBrush(axis, _a) {
    var { cross, offsetX, offsetY } = _a, style = __rest(_a, [
        "cross",
        "offsetX",
        "offsetY"
    ]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [lineX] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY] = bounds.max;
    const size = (maxX - minX) * 2;
    return {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushYRegion"],
        hotZone: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            className: AXIS_HOT_AREA_CLASS_NAME,
            style: Object.assign({
                // If it is not cross, draw brush in both side of axisLine,
                // otherwise the draw brush within bounds area.
                width: cross ? size / 2 : size,
                transform: `translate(${(cross ? minX : lineX - size / 2).toFixed(2)}, ${minY})`,
                height: maxY - minY
            }, style)
        }),
        extent: cross ? (x, y, x1, y1)=>[
                -Infinity,
                y,
                Infinity,
                y1
            ] : (x, y, x1, y1)=>[
                Math.floor(minX - offsetX),
                y,
                Math.ceil(maxX - offsetX),
                y1
            ]
    };
}
// Brush for horizontal axis.
function horizontalBrush(axis, _a) {
    var { offsetY, offsetX, cross = false } = _a, style = __rest(_a, [
        "offsetY",
        "offsetX",
        "cross"
    ]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [, lineY] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY] = bounds.max;
    const size = maxY - minY;
    return {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushXRegion"],
        hotZone: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            className: AXIS_HOT_AREA_CLASS_NAME,
            style: Object.assign({
                width: maxX - minX,
                // If it is not cross, draw brush in both side of axisLine,
                // otherwise the draw brush within bounds area.
                height: cross ? size : size * 2,
                transform: `translate(${minX}, ${cross ? minY : lineY - size})`
            }, style)
        }),
        extent: cross ? (x, y, x1, y1)=>[
                x,
                -Infinity,
                x1,
                Infinity
            ] : (x, y, x1, y1)=>[
                x,
                Math.floor(minY - offsetY),
                x1,
                Math.ceil(maxY - offsetY)
            ]
    };
}
function brushAxisHighlight(root, _a) {
    var { axes: axesOf, elements: elementsOf, points: pointsOf, horizontal: isHorizontal, datum, offsetY, offsetX, reverse = false, state = {}, emitter, coordinate } = _a, rest = __rest(_a, [
        "axes",
        "elements",
        "points",
        "horizontal",
        "datum",
        "offsetY",
        "offsetX",
        "reverse",
        "state",
        "emitter",
        "coordinate"
    ]) // style
    ;
    const elements = elementsOf(root);
    const axes = axesOf(root);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const { setState, removeState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(state, valueof);
    const axisExtent = new Map();
    const brushStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'mask');
    // Only some of shape's points in all mask, it is selected.
    const brushed = (points)=>Array.from(axisExtent.values()).every(([x, y, x1, y1])=>points.some(([x0, y0])=>{
                return x0 >= x && x0 <= x1 && y0 >= y && y0 <= y1;
            }));
    const scales = axes.map((d)=>d.attributes.scale);
    const extentOf = (D)=>D.length > 2 ? [
            D[0],
            D[D.length - 1]
        ] : D;
    const indexDomain = new Map();
    const initIndexDomain = ()=>{
        indexDomain.clear();
        for(let i = 0; i < axes.length; i++){
            const scale = scales[i];
            const { domain } = scale.getOptions();
            indexDomain.set(i, extentOf(domain));
        }
    };
    initIndexDomain();
    // Update element when brush changed.
    const updateElement = (i, emit)=>{
        const selectedElements = [];
        for (const element of elements){
            const points = pointsOf(element);
            if (brushed(points)) {
                setState(element, 'active');
                selectedElements.push(element);
            } else setState(element, 'inactive');
        }
        indexDomain.set(i, selectionOf(selectedElements, i));
        if (!emit) return;
        // Emit events.
        const selection = ()=>{
            if (!cross) return Array.from(indexDomain.values());
            const S = [];
            for (const [index, domain] of indexDomain){
                const scale = scales[index];
                const { name } = scale.getOptions();
                if (name === 'x') S[0] = domain;
                else S[1] = domain;
            }
            return S;
        };
        emitter.emit('brushAxis:highlight', {
            nativeEvent: true,
            data: {
                selection: selection()
            }
        });
    };
    const clearElement = (emit)=>{
        for (const element of elements)removeState(element, 'active', 'inactive');
        initIndexDomain();
        if (!emit) return;
        emitter.emit('brushAxis:remove', {
            nativeEvent: true
        });
    };
    const selectionOf = (selected, i)=>{
        const scale = scales[i];
        const { name } = scale.getOptions();
        const domain = selected.map((d)=>{
            const data = d.__data__;
            return scale.invert(data[name]);
        });
        return extentOf((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scale, domain));
    };
    // Distinguish between parallel coordinates and normal charts.
    const cross = axes.some(isHorizontal) && axes.some((d)=>!isHorizontal(d));
    const handlers = [];
    for(let i = 0; i < axes.length; i++){
        const axis = axes[i];
        const createBrush = isHorizontal(axis) ? horizontalBrush : verticalBrush;
        const { hotZone, brushRegion, extent } = createBrush(axis, {
            offsetY,
            offsetX,
            cross,
            zIndex: 999,
            fill: 'transparent'
        });
        axis.parentNode.appendChild(hotZone);
        const brushHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brush"])(hotZone, Object.assign(Object.assign({}, brushStyle), {
            reverse,
            brushRegion,
            brushended (emit) {
                axisExtent.delete(axis);
                if (Array.from(axisExtent.entries()).length === 0) clearElement(emit);
                else updateElement(i, emit);
            },
            brushed (x, y, x1, y1, emit) {
                axisExtent.set(axis, extent(x, y, x1, y1));
                updateElement(i, emit);
            }
        }));
        handlers.push(brushHandler);
    }
    const onRemove = (event = {})=>{
        const { nativeEvent } = event;
        if (nativeEvent) return;
        handlers.forEach((d)=>d.remove(false));
    };
    const rangeOf = (domain, scale, axis)=>{
        const [d0, d1] = domain;
        const maybeStep = (scale)=>scale.getStep ? scale.getStep() : 0;
        const x = abstractOf(d0, scale, axis);
        const x1 = abstractOf(d1, scale, axis) + maybeStep(scale);
        if (isHorizontal(axis)) return [
            x,
            -Infinity,
            x1,
            Infinity
        ];
        return [
            -Infinity,
            x,
            Infinity,
            x1
        ];
    };
    const abstractOf = (x, scale, axis)=>{
        const { height, width } = coordinate.getOptions();
        const scale1 = scale.clone();
        if (isHorizontal(axis)) scale1.update({
            range: [
                0,
                width
            ]
        });
        else scale1.update({
            range: [
                height,
                0
            ]
        });
        return scale1.map(x);
    };
    const onHighlight = (event)=>{
        const { nativeEvent } = event;
        if (nativeEvent) return;
        const { selection } = event.data;
        for(let i = 0; i < handlers.length; i++){
            const domain = selection[i];
            const handler = handlers[i];
            const axis = axes[i];
            if (domain) {
                const scale = scales[i];
                handler.move(...rangeOf(domain, scale, axis), false);
            } else {
                handler.remove(false);
            }
        }
    };
    emitter.on('brushAxis:remove', onRemove);
    emitter.on('brushAxis:highlight', onHighlight);
    return ()=>{
        handlers.forEach((d)=>d.destroy());
        emitter.off('brushAxis:remove', onRemove);
        emitter.off('brushAxis:highlight', onHighlight);
    };
}
function BrushAxisHighlight(options) {
    return (target, _, emitter)=>{
        const { container, view, options: viewOptions } = target;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const { x: x0, y: y0 } = plotArea.getBBox();
        const { coordinate } = view;
        return brushAxisHighlight(container, Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            axes: axesOf,
            offsetY: y0,
            offsetX: x0,
            points: (element)=>element.__data__.points,
            horizontal: (axis)=>{
                const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
                // attention, non-horizontal does not mean vertical
                // it may has a specific degree angle
                return sx !== ex && sy === ey;
            },
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(viewOptions, [
                'active',
                [
                    'inactive',
                    {
                        opacity: 0.5
                    }
                ]
            ]),
            coordinate,
            emitter
        }, options));
    };
} //# sourceMappingURL=brushAxisHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushFilter": (()=>BrushFilter),
    "brushFilter": (()=>brushFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
// Mock dblclick events.
function dblclick(interval = 300) {
    let preTimeStamp = null;
    return (e)=>{
        const { timeStamp } = e;
        if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {
            preTimeStamp = timeStamp;
            return true;
        }
        preTimeStamp = timeStamp;
        return false;
    };
}
function brushFilter(root, _a) {
    var { filter, reset, brushRegion, extent: optionalExtent, reverse, emitter, scale, coordinate, selection, series = false } = _a, rest = __rest(_a, [
        "filter",
        "reset",
        "brushRegion",
        "extent",
        "reverse",
        "emitter",
        "scale",
        "coordinate",
        "selection",
        "series"
    ]);
    const brushStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'mask');
    const { width: rootWidth, height: rootHeight } = root.getBBox();
    const extent = optionalExtent ? optionalExtent : [
        0,
        0,
        rootWidth,
        rootHeight
    ];
    const isDblclick = dblclick();
    const brush = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brush"])(root, Object.assign(Object.assign({}, brushStyle), {
        extent,
        brushRegion,
        reverse,
        brushcreated
    }));
    root.addEventListener('click', click);
    // Filter when brush created.
    function brushcreated(x, y, x1, y1, event) {
        if (x === x1 && y === y1) return;
        event.nativeEvent = true;
        filter(selection(x, y, x1, y1), event);
        brush.remove();
    }
    // Reset when dblclick.
    function click(e) {
        if (isDblclick(e)) {
            e.nativeEvent = true;
            reset(e);
        }
    }
    const onFilter = ({ nativeEvent, data })=>{
        if (nativeEvent) return;
        const { selection } = data;
        filter(selection, {
            nativeEvent: false
        });
    };
    emitter.on('brush:filter', onFilter);
    return ()=>{
        brush.destroy();
        emitter.off('brush:filter', onFilter);
        root.removeEventListener('click', click);
    };
}
function BrushFilter(_a) {
    var { hideX = true, hideY = true } = _a, rest = __rest(_a, [
        "hideX",
        "hideY"
    ]);
    return (target, viewInstances, emitter)=>{
        const { container, view, options: viewOptions, update, setState } = target;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const defaultOptions = {
            maskFill: '#777',
            maskFillOpacity: '0.3',
            maskStroke: '#fff',
            unhighlightedOpacity: 0.5,
            reverse: false
        };
        let filtered = false;
        let filtering = false;
        let newView = view;
        const { scale, coordinate } = view;
        return brushFilter(plotArea, Object.assign(Object.assign({
            brushRegion: (x, y, x1, y1)=>[
                    x,
                    y,
                    x1,
                    y1
                ],
            selection: (x, y, x1, y1)=>{
                const { scale, coordinate } = newView;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            },
            filter: (selection, event)=>__awaiter(this, void 0, void 0, function*() {
                    // Avoid redundant filter.
                    if (filtering) return;
                    filtering = true;
                    // Update the domain of x and y scale to filter data.
                    const [domainX, domainY] = selection;
                    setState('brushFilter', (options)=>{
                        const { marks } = options;
                        const newMarks = marks.map((mark)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
                                // Hide label to keep smooth transition.
                                axis: Object.assign(Object.assign({}, hideX && {
                                    x: {
                                        transform: [
                                            {
                                                type: 'hide'
                                            }
                                        ]
                                    }
                                }), hideY && {
                                    y: {
                                        transform: [
                                            {
                                                type: 'hide'
                                            }
                                        ]
                                    }
                                })
                            }, mark, {
                                // Set nice to false to avoid modify domain.
                                scale: {
                                    x: {
                                        domain: domainX,
                                        nice: false
                                    },
                                    y: {
                                        domain: domainY,
                                        nice: false
                                    }
                                }
                            }));
                        return Object.assign(Object.assign({}, viewOptions), {
                            marks: newMarks,
                            clip: true
                        });
                    });
                    // Emit event.
                    emitter.emit('brush:filter', Object.assign(Object.assign({}, event), {
                        data: {
                            selection: [
                                domainX,
                                domainY
                            ]
                        }
                    }));
                    const newState = yield update();
                    newView = newState.view;
                    filtering = false;
                    filtered = true;
                }),
            reset: (event)=>{
                if (filtering || !filtered) return;
                // Emit event.
                const { scale } = view;
                const { x: scaleX, y: scaleY } = scale;
                const domainX = scaleX.getOptions().domain;
                const domainY = scaleY.getOptions().domain;
                emitter.emit('brush:filter', Object.assign(Object.assign({}, event), {
                    data: {
                        selection: [
                            domainX,
                            domainY
                        ]
                    }
                }));
                filtered = false;
                newView = view;
                setState('brushFilter');
                update();
            },
            extent: undefined,
            emitter,
            scale,
            coordinate
        }, defaultOptions), rest));
    };
} //# sourceMappingURL=brushFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushXFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushXFilter": (()=>BrushXFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushXHighlight.js [app-client] (ecmascript)");
;
;
function BrushXFilter(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushFilter"])(Object.assign(Object.assign({
        hideX: true
    }, options), {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushXRegion"]
    }));
} //# sourceMappingURL=brushXFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushYFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushYFilter": (()=>BrushYFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushYHighlight.js [app-client] (ecmascript)");
;
;
function BrushYFilter(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushFilter"])(Object.assign(Object.assign({
        hideY: true
    }, options), {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushYRegion"]
    }));
} //# sourceMappingURL=brushYFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/adaptiveFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "extractMultiAxisScaleInfo": (()=>extractMultiAxisScaleInfo),
    "extractSingleAxisScaleInfo": (()=>extractSingleAxisScaleInfo),
    "filterMarkDataByDomain": (()=>filterMarkDataByDomain),
    "processMultiAxisMarkFiltering": (()=>processMultiAxisMarkFiltering),
    "processMultiAxisViewFiltering": (()=>processMultiAxisViewFiltering),
    "processSingleAxisFiltering": (()=>processSingleAxisFiltering),
    "updateChannelDomains": (()=>updateChannelDomains)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function extractSingleAxisScaleInfo(shouldFilterXAxis, scaleX, scaleY) {
    const currentScale = shouldFilterXAxis ? scaleY : scaleX;
    const targetScale = shouldFilterXAxis ? scaleX : scaleY;
    const isSourceDiscrete = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(currentScale);
    const isTargetDiscrete = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(targetScale);
    const targetOriginalDomain = targetScale.getOptions().domain;
    const shouldPreserveZeroBaseline = !isTargetDiscrete && targetOriginalDomain && targetOriginalDomain.length >= 2 && targetOriginalDomain[0] === 0;
    return {
        currentScale,
        targetScale,
        isSourceDiscrete,
        isTargetDiscrete,
        shouldPreserveZeroBaseline
    };
}
function extractMultiAxisScaleInfo(shouldFilterXAxis, scale, scaleX, scaleY, channelDomain) {
    const currentScale = shouldFilterXAxis ? scaleY : scaleX;
    /**
     * Retrieves scale domains for a specific axis type (x or y).
     * Supports both primary axes (x, y) and numbered variants (x1, x2, y1, y2).
     */ const getAxisScaleDomains = (axisType)=>{
        const axisScales = {};
        Object.keys(channelDomain).forEach((key)=>{
            if (key === axisType || key.match(new RegExp(`^${axisType}\\d+$`))) {
                axisScales[key] = channelDomain[key];
            }
        });
        return axisScales;
    };
    const targetScaleDomain = shouldFilterXAxis ? getAxisScaleDomains('x') : getAxisScaleDomains('y');
    const targetScaleKeys = Object.keys(targetScaleDomain);
    const targetScales = targetScaleKeys.map((item)=>scale[item]);
    const isSourceDiscrete = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(currentScale);
    const isTargetDiscrete = targetScales.map((targetScale)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(targetScale));
    const shouldPreserveZeroBaseline = targetScales.map((targetScale, index)=>{
        const targetOriginalDomain = targetScale.getOptions().domain;
        const isDiscrete = isTargetDiscrete[index];
        return !isDiscrete && targetOriginalDomain && targetOriginalDomain.length >= 2 && targetOriginalDomain[0] === 0;
    });
    return {
        currentScale,
        targetScales,
        isSourceDiscrete,
        isTargetDiscrete,
        shouldPreserveZeroBaseline,
        targetScaleKeys
    };
}
/**
 * Removes duplicate values from an array and returns sorted result.
 *
 * @param values - Array of numeric values
 * @returns Sorted array with unique values
 */ function getUniqueSortedValues(values) {
    const uniqueValues = Array.from(new Set(values));
    return uniqueValues.sort((a, b)=>a - b);
}
/**
 * Calculates the filtered domain based on target scale type and constraints.
 *
 * @param options - Configuration for domain calculation
 * @returns Calculated domain array
 */ function calculateFilteredDomain({ isTargetDiscrete, filteredValues, shouldPreserveZeroBaseline }) {
    if (isTargetDiscrete) {
        return getUniqueSortedValues(filteredValues);
    } else {
        const min = Math.min(...filteredValues);
        const max = Math.max(...filteredValues);
        return shouldPreserveZeroBaseline ? [
            0,
            max
        ] : [
            min,
            max
        ];
    }
}
/**
 * Converts various value types to numeric for comparison.
 * Handles Date objects, strings, and numbers.
 */ function convertToNumeric(value) {
    if (value instanceof Date) {
        return value.getTime();
    }
    if (typeof value === 'string') {
        return parseFloat(value);
    }
    return Number(value);
}
function filterMarkDataByDomain(markDataPairs, domain, isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, adaptiveMode = 'filter', shouldFilterXAxis = false) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFalsyValue"])(adaptiveMode)) {
        return [];
    }
    const sourceChannel = shouldFilterXAxis ? 'y' : 'x';
    const targetChannel = shouldFilterXAxis ? 'x' : 'y';
    const allFilteredTargetValues = [];
    for (const markData of markDataPairs){
        const { channelData } = markData;
        const sourceValues = channelData[sourceChannel] || [];
        const targetValues = channelData[targetChannel] || [];
        // Handle different data structures based on channel type:
        // X channel: one-dimensional array [x1, x2, x3, ...]
        // Y channel: two-dimensional array [[y1, y2, y3, ...]]
        // Normalize source values to one-dimensional array
        const normalizedSourceValues = Array.isArray(sourceValues[0]) ? sourceValues[0] // If it's 2D array (Y channel), take first sub-array
         : sourceValues; // If it's 1D array (X channel), use as is
        // Handle target values based on their structure
        const isTargetArray2D = Array.isArray(targetValues[0]);
        if (normalizedSourceValues.length === 0) continue;
        const dataLength = normalizedSourceValues.length;
        for(let i = 0; i < dataLength; i++){
            const sourceValue = normalizedSourceValues[i];
            let shouldInclude = false;
            if (isSourceDiscrete) {
                shouldInclude = domain.includes(sourceValue);
            } else {
                // Handle both numeric and Date domains
                if (domain.length >= 2) {
                    const sourceTime = convertToNumeric(sourceValue);
                    const domainStartTime = convertToNumeric(domain[0]);
                    const domainEndTime = convertToNumeric(domain[domain.length - 1]);
                    if (!isNaN(sourceTime) && !isNaN(domainStartTime) && !isNaN(domainEndTime)) {
                        shouldInclude = sourceTime >= domainStartTime && sourceTime <= domainEndTime;
                    }
                }
            }
            if (adaptiveMode === 'filter' && shouldInclude) {
                // Collect target channel values for this data point
                if (isTargetArray2D) {
                    // Target is 2D array (Y channel)
                    const numChannels = targetValues.length;
                    for(let channelIdx = 0; channelIdx < numChannels; channelIdx++){
                        const channelData = targetValues[channelIdx];
                        if (Array.isArray(channelData) && i < channelData.length) {
                            const targetValue = channelData[i];
                            const numericValue = convertToNumeric(targetValue);
                            if (!isNaN(numericValue)) {
                                allFilteredTargetValues.push(numericValue);
                            }
                        }
                    }
                } else {
                    // Target is 1D array (X channel)
                    if (i < targetValues.length) {
                        const targetValue = targetValues[i];
                        const numericValue = convertToNumeric(targetValue);
                        if (!isNaN(numericValue)) {
                            allFilteredTargetValues.push(numericValue);
                        }
                    }
                }
            }
        }
    }
    if (allFilteredTargetValues.length > 0) {
        return calculateFilteredDomain({
            isTargetDiscrete,
            filteredValues: allFilteredTargetValues,
            shouldPreserveZeroBaseline
        });
    }
    return [];
}
function processSingleAxisFiltering({ markDataPairs, domain, scaleInfo, adaptiveMode, shouldFilterXAxis = false }) {
    const { isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline } = scaleInfo;
    return filterMarkDataByDomain(markDataPairs, domain, isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, adaptiveMode, shouldFilterXAxis);
}
function processMultiAxisViewFiltering({ markDataPairs, domain, scaleInfo, markToScaleMap, adaptiveMode, shouldFilterXAxis = false }) {
    const filteredDomain = new Map();
    const { isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, targetScaleKeys } = scaleInfo;
    markDataPairs.forEach((markData)=>{
        const scaleKey = markToScaleMap.get(markData.markKey);
        if (!scaleKey) return;
        const scaleIndex = targetScaleKeys.indexOf(scaleKey);
        if (scaleIndex === -1) return;
        const currentIsTargetDiscrete = isTargetDiscrete[scaleIndex];
        const currentShouldPreserveZeroBaseline = shouldPreserveZeroBaseline[scaleIndex];
        const markFilteredDomain = filterMarkDataByDomain([
            markData
        ], domain, isSourceDiscrete, currentIsTargetDiscrete, currentShouldPreserveZeroBaseline, adaptiveMode, shouldFilterXAxis);
        filteredDomain.set(scaleKey, markFilteredDomain);
    });
    return filteredDomain;
}
function processMultiAxisMarkFiltering(markDataPairs, domain, scaleInfo, targetMarkKey, targetScaleKey, adaptiveMode, shouldFilterXAxis = false, markToScaleMap) {
    const filteredDomain = new Map();
    // Early return if no data to process
    if (markDataPairs.length === 0 || domain.length === 0) {
        return filteredDomain;
    }
    const { isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline } = scaleInfo;
    // Find all marks that share the same target scale key
    const relevantMarkData = markToScaleMap ? markDataPairs.filter((markData)=>{
        const markScaleKey = markToScaleMap.get(markData.markKey);
        return markScaleKey === targetScaleKey;
    }) : markDataPairs.filter((markData)=>markData.markKey === targetMarkKey);
    // Early return if no relevant marks found
    if (relevantMarkData.length === 0) {
        return filteredDomain;
    }
    const markFilteredDomain = filterMarkDataByDomain(relevantMarkData, domain, isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, adaptiveMode, shouldFilterXAxis);
    filteredDomain.set(targetScaleKey, markFilteredDomain);
    return filteredDomain;
}
function updateChannelDomains(channelDomain, filteredDomain, shouldFilterXAxis, isMultiAxis) {
    if (isMultiAxis && filteredDomain instanceof Map) {
        filteredDomain.forEach((domain, scaleKey)=>{
            if (domain && Array.isArray(domain) && domain.length > 0) {
                channelDomain[scaleKey] = domain;
            }
        });
    } else if (!isMultiAxis && Array.isArray(filteredDomain)) {
        if (filteredDomain.length > 0) {
            channelDomain[shouldFilterXAxis ? 'x' : 'y'] = filteredDomain;
        }
    }
} //# sourceMappingURL=adaptiveFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/sliderFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SLIDER_CLASS_NAME": (()=>SLIDER_CLASS_NAME),
    "SliderFilter": (()=>SliderFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/upper-first.js [app-client] (ecmascript) <export default as upperFirst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/adaptiveFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
;
;
;
;
const SLIDER_CLASS_NAME = 'slider';
/**
 * Calculates extra inset needed for point marks based on size scale range or values
 *
 * @param view - View descriptor containing markState
 * @returns Calculated inset value from size scale range or values
 */ function calculatePointInset(view) {
    var _a, _b, _c, _d;
    if (!(view === null || view === void 0 ? void 0 : view.markState)) return 0;
    let maxSize = 0;
    for (const [mark, state] of view.markState.entries()){
        if (mark.type !== 'point' || !(state === null || state === void 0 ? void 0 : state.channels)) continue;
        const sizeChannel = (_a = state.channels) === null || _a === void 0 ? void 0 : _a.find((ch)=>ch.name === 'size');
        if (!sizeChannel) continue;
        // Priority 1: Use scale range if available
        if (((_c = (_b = sizeChannel.scale) === null || _b === void 0 ? void 0 : _b.range) === null || _c === void 0 ? void 0 : _c.length) > 0) {
            const rangeMax = Math.max(...sizeChannel.scale.range.filter((val)=>typeof val === 'number'));
            maxSize = Math.max(maxSize, rangeMax);
            continue;
        }
        // Priority 2: Fallback to values maximum
        if (((_d = sizeChannel.values) === null || _d === void 0 ? void 0 : _d.length) > 0) {
            const sizes = sizeChannel.values.filter((item)=>item.value !== undefined).flatMap((item)=>Array.isArray(item.value) ? item.value : [
                    item.value
                ]).filter((value)=>typeof value === 'number' && !isNaN(value));
            if (sizes.length > 0) {
                maxSize = Math.max(maxSize, ...sizes);
            }
        }
    }
    return maxSize;
}
/**
 * Emits filter events with proper X/Y domain mapping.
 *
 * @param emitter - Event emitter instance
 * @param eventName - Name of the event to emit
 * @param event - Event data object
 * @param domain0 - Primary domain values
 * @param channelDomain - Channel domain configuration
 * @param isX - Whether this is an X-axis event
 * @param nativeEvent - Whether this is a native DOM event
 */ function emitFilterEvent(emitter, eventName, event, domain0, channelDomain, isX, nativeEvent) {
    if (nativeEvent) {
        const X = isX ? domain0 : channelDomain.x;
        const Y = isX ? channelDomain.y : domain0;
        emitter.emit(eventName, Object.assign(Object.assign({}, event), {
            nativeEvent,
            data: {
                selection: [
                    extentOf(X),
                    extentOf(Y)
                ]
            }
        }));
    }
}
/**
 * Updates slider state with appropriate filter function.
 * Handles both single-axis and multi-axis scenarios.
 *
 * @param setState - State setter function
 * @param slider - Slider component instance
 * @param params - Configuration parameters for state update
 */ function updateSliderState(setState, slider, view, params) {
    const { domain0, filteredDomain, channel0, channel1, prefix, hasState, isMultiAxis, markToScaleMap, enableAdaptiveFiltering } = params;
    if (isMultiAxis && filteredDomain instanceof Map) {
        setState(slider, (options)=>Object.assign({}, filterDataByDomainMultiAxis(options, view, {
                [channel0]: {
                    domain: domain0,
                    nice: false
                }
            }, prefix, hasState, channel0, channel1, markToScaleMap || new Map(), filteredDomain)));
    } else {
        setState(slider, (options)=>Object.assign({}, filterDataByDomain(options, view, Object.assign({
                [channel0]: {
                    domain: domain0,
                    nice: false
                }
            }, enableAdaptiveFiltering && Array.isArray(filteredDomain) ? {
                [channel1]: {
                    domain: filteredDomain,
                    nice: true
                }
            } : {}), prefix, hasState, channel0, channel1)));
    }
}
/**
 * Filters data by domain for single-axis scenarios.
 * Applies scale options and preserves slider state.
 *
 * @param options - Filter data options
 * @param scaleOptions - Scale configuration
 * @param prefix - Slider prefix identifier
 * @param hasState - Whether slider has state
 * @param channel0 - Primary channel (x or y)
 * @param channel1 - Secondary channel (y or x)
 * @returns Filtered options with updated marks
 */ function filterDataByDomain(options, view, scaleOptions, prefix, hasState = false, channel0 = 'x', channel1 = 'y') {
    const { marks } = options;
    const extraInset = calculatePointInset(view);
    const newMarks = marks.map((mark)=>{
        var _a, _b;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
            // Hide label to keep smooth transition.
            axis: {
                x: {
                    transform: [
                        {
                            type: 'hide'
                        }
                    ]
                },
                y: {
                    transform: [
                        {
                            type: 'hide'
                        }
                    ]
                }
            }
        }, mark, {
            scale: scaleOptions,
            [prefix]: Object.assign(Object.assign({}, ((_a = mark[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
                [channel0]: Object.assign({
                    preserve: true
                }, hasState && {
                    ratio: null
                })
            }), ((_b = mark[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
                [channel1]: {
                    preserve: true
                }
            }),
            animate: false
        });
    });
    return Object.assign(Object.assign({}, options), {
        marks: newMarks,
        // Add adaptive inset based on actual point sizes from markState
        insetLeft: extraInset,
        insetRight: extraInset,
        insetTop: extraInset,
        insetBottom: extraInset,
        clip: true,
        animate: false
    });
}
/**
 * Filters data by domain for multi-axis scenarios.
 * Handles independent scales and mark-specific filtering.
 *
 * @param options - Filter data options
 * @param scaleOptions - Scale configuration
 * @param prefix - Slider prefix identifier
 * @param hasState - Whether slider has state
 * @param channel0 - Primary channel (x or y)
 * @param channel1 - Secondary channel (y or x)
 * @param markToScaleMap - Mapping of marks to scale keys
 * @param filteredDomainList - Map of filtered domains by scale key
 * @returns Filtered options with updated marks
 */ function filterDataByDomainMultiAxis(options, view, scaleOptions, prefix, hasState = false, channel0 = 'x', channel1 = 'y', markToScaleMap = new Map(), filteredDomainList = new Map()) {
    const { marks } = options;
    const extraInset = calculatePointInset(view);
    const newMarks = marks.map((mark)=>{
        var _a, _b;
        const markKey = typeof (mark === null || mark === void 0 ? void 0 : mark.key) === 'string' ? mark.key : String((mark === null || mark === void 0 ? void 0 : mark.key) || '');
        const markToScale = markToScaleMap.get(markKey);
        const filterDomain = filteredDomainList.get(markToScale);
        const scaleNew = filterDomain && {
            y: Object.assign({
                domain: filterDomain,
                nice: true
            }, markToScale !== 'y' ? {
                independent: true
            } : undefined)
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
            // Hide label to keep smooth transition.
            axis: {
                x: {
                    transform: [
                        {
                            type: 'hide'
                        }
                    ]
                },
                y: {
                    transform: [
                        {
                            type: 'hide'
                        }
                    ]
                }
            }
        }, mark, {
            scale: Object.assign(Object.assign({}, scaleOptions), scaleNew),
            [prefix]: Object.assign(Object.assign({}, ((_a = mark[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
                [channel0]: Object.assign({
                    preserve: true
                }, hasState && {
                    ratio: null
                })
            }), ((_b = mark[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
                [channel1]: {
                    preserve: true
                }
            }),
            animate: false
        });
    });
    return Object.assign(Object.assign({}, options), {
        marks: newMarks,
        // Add adaptive inset based on actual point sizes from markState
        insetLeft: extraInset,
        insetRight: extraInset,
        insetTop: extraInset,
        insetBottom: extraInset,
        clip: true,
        animate: false
    });
}
/**
 * Converts slider values to abstract domain values.
 *
 * @param values - Slider value range [start, end]
 * @param scale - Scale instance for conversion
 * @param reverse - Whether to reverse the mapping
 * @returns Abstract domain values
 */ function abstractValue(values, scale, reverse) {
    const [x, x1] = values;
    const v = reverse ? (d)=>1 - d : (d)=>d;
    const d0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(scale, v(x), true);
    const d1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(scale, v(x1), false);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scale, [
        d0,
        d1
    ]);
}
/**
 * Gets the extent (first and last) values from a domain array.
 *
 * @param domain - Domain array
 * @returns Array containing first and last domain values
 */ function extentOf(domain) {
    return [
        domain[0],
        domain[domain.length - 1]
    ];
}
function SliderFilter({ initDomain = {}, className = SLIDER_CLASS_NAME, prefix = 'slider', setValue = (component, values)=>component.setValues(values), hasState = false, wait = 50, leading = true, trailing = false, adaptiveMode = 'filter', getInitValues = (slider)=>{
    var _a;
    const values = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;
    if (values[0] !== 0 || values[1] !== 1) return values;
} }) {
    return (context, _, emitter)=>{
        const { container, view, update, setState } = context;
        const sliders = container.getElementsByClassName(className);
        if (!sliders.length) return ()=>{};
        let filtering = false;
        const { scale, coordinate } = view;
        const { x: scaleX, y: scaleY } = scale;
        const transposed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate);
        const channelOf = (orientation)=>{
            const channel0 = orientation === 'vertical' ? 'y' : 'x';
            const channel1 = orientation === 'vertical' ? 'x' : 'y';
            if (transposed) return [
                channel1,
                channel0
            ];
            return [
                channel0,
                channel1
            ];
        };
        const sliderHandler = new Map();
        const emitHandlers = new Set();
        const independentScaleInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateAllIndependentScaleInfo"])(view);
        const channelDomain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateMultiAxisChannelDomains"])(view, initDomain, scaleX, scaleY, independentScaleInfo);
        const sliderArray = Array.from(sliders);
        const hasSliderOfType = (type)=>sliderArray.some((slider)=>{
                const { orientation } = slider.attributes;
                const [channel0] = channelOf(orientation);
                return channel0 === type;
            });
        const hasOnlyXSlider = hasSliderOfType('x') && !hasSliderOfType('y');
        const hasOnlyYSlider = hasSliderOfType('y') && !hasSliderOfType('x');
        const enableAdaptiveFiltering = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFalsyValue"])(adaptiveMode) && (hasOnlyXSlider || hasOnlyYSlider);
        for (const slider of sliders){
            const { orientation } = slider.attributes;
            const [channel0, channel1] = channelOf(orientation);
            const eventName = `${prefix}${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(channel0)}:filter`;
            const isX = channel0 === 'x';
            const { ratio: ratioX } = scaleX.getOptions();
            const { ratio: ratioY } = scaleY.getOptions();
            const domainsOf = (event)=>{
                if (event.data) {
                    const { selection } = event.data;
                    const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
                    return isX ? [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleX, X, ratioX),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleY, Y, ratioY)
                    ] : [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleY, Y, ratioY),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleX, X, ratioX)
                    ];
                }
                const { value: values } = event.detail;
                const scale0 = scale[channel0];
                const domain0 = abstractValue(values, scale0, transposed && orientation === 'horizontal');
                const domain1 = channelDomain[channel1];
                return [
                    domain0,
                    domain1
                ];
            };
            // Create value change handler with independent filtering state
            // Each slider maintains its own filtering state to prevent mutual interference in dual-axis scenarios
            let isFiltering = false;
            const setFiltering = (value)=>{
                isFiltering = value;
                // Only reset global state when all sliders are not filtering
                if (!value) {
                    filtering = false;
                }
            };
            const onValueChange = createValueChangeHandler({
                getFiltering: ()=>isFiltering,
                setFiltering,
                domainsOf,
                view,
                independentScaleInfo,
                enableAdaptiveFiltering,
                hasOnlyXSlider,
                hasOnlyYSlider,
                adaptiveMode,
                scaleX,
                scaleY,
                scale,
                channelDomain,
                channel0,
                channel1,
                isX,
                emitter,
                eventName,
                setState,
                slider,
                prefix,
                hasState,
                update,
                wait,
                leading,
                trailing
            });
            const emitHandler = (event)=>{
                const { nativeEvent } = event;
                if (nativeEvent) return;
                const { data } = event;
                const { selection } = data;
                const [X, Y] = selection;
                slider.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomEvent"]('valuechange', {
                    data,
                    nativeEvent: false
                }));
                const V = isX ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sliderAbstractOf"])(X, scaleX) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sliderAbstractOf"])(Y, scaleY);
                setValue(slider, V);
            };
            emitter.on(eventName, emitHandler);
            slider.addEventListener('valuechange', onValueChange);
            sliderHandler.set(slider, onValueChange);
            emitHandlers.add([
                eventName,
                emitHandler
            ]);
            const values = getInitValues(slider);
            if (values) {
                slider.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomEvent"]('valuechange', {
                    detail: {
                        value: values
                    },
                    nativeEvent: false,
                    initValue: true
                }));
            }
        }
        return ()=>{
            for (const [slider, handler] of sliderHandler){
                slider.removeEventListener('valuechange', handler);
            }
            for (const [name, handler] of emitHandlers){
                emitter.off(name, handler);
            }
        };
    };
}
/**
 * Processes multi-axis filtering for view-level sliders.
 * Handles both view-level and mark-level slider configurations.
 *
 * @param params - Multi-axis filtering parameters
 * @returns Filtered domain mapping
 */ function processMultiAxisFiltering({ view, domain0, shouldFilterXAxis, enableAdaptiveFiltering, markDataPairs, adaptiveMode, scaleX, scaleY, scale, channelDomain, independentScaleInfo, channel0 }) {
    const filteredDomain = new Map();
    const markToScaleMap = new Map();
    if (!enableAdaptiveFiltering || markDataPairs.length === 0 || !(domain0 === null || domain0 === void 0 ? void 0 : domain0.length)) {
        return {
            filteredDomain,
            markToScaleMap
        };
    }
    const viewSlider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(view, 'options.slider');
    const isViewSlider = Object.keys(viewSlider).length > 0 && Object.prototype.hasOwnProperty.call(viewSlider, channel0);
    if (isViewSlider) {
        // Handle view-level slider
        const multiAxisScaleInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractMultiAxisScaleInfo"])(shouldFilterXAxis, scale, scaleX, scaleY, channelDomain);
        const scaleMapToUse = shouldFilterXAxis ? independentScaleInfo.markToXScaleMap : independentScaleInfo.markToYScaleMap;
        scaleMapToUse.forEach((scaleKey, markKey)=>{
            markToScaleMap.set(markKey, scaleKey);
        });
        const processedFilteredDomain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["processMultiAxisViewFiltering"])({
            markDataPairs,
            domain: domain0,
            scaleInfo: multiAxisScaleInfo,
            markToScaleMap,
            adaptiveMode,
            isViewSlider: true,
            shouldFilterXAxis
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateChannelDomains"])(channelDomain, processedFilteredDomain, shouldFilterXAxis, true);
        return {
            filteredDomain: processedFilteredDomain,
            markToScaleMap
        };
    } else {
        // Handle mark-level slider
        const targetMarkKey = findTargetMarkKey(view, channel0);
        if (targetMarkKey) {
            const singleAxisScaleInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractSingleAxisScaleInfo"])(shouldFilterXAxis, scaleX, scaleY);
            const scaleMapping = shouldFilterXAxis ? independentScaleInfo.markToXScaleMap : independentScaleInfo.markToYScaleMap;
            const targetScaleKey = scaleMapping.get(targetMarkKey) || '';
            if (targetScaleKey) {
                markToScaleMap.set(targetMarkKey, targetScaleKey);
                const processedFilteredDomain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["processMultiAxisMarkFiltering"])(markDataPairs, domain0, singleAxisScaleInfo, targetMarkKey, targetScaleKey, adaptiveMode, shouldFilterXAxis, scaleMapping);
                return {
                    filteredDomain: processedFilteredDomain,
                    markToScaleMap
                };
            }
        }
    }
    return {
        filteredDomain,
        markToScaleMap
    };
}
/**
 * Finds the target mark key for mark-level sliders.
 *
 * @param view - View instance
 * @param channel0 - Channel identifier
 * @returns Target mark key or null if not found
 */ function findTargetMarkKey(view, channel0) {
    for (const [mark] of view.markState.entries()){
        const markSlider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(mark, 'slider');
        const hasMarkSlider = Object.keys(markSlider || {}).length > 0 && Object.prototype.hasOwnProperty.call(markSlider, channel0);
        if (hasMarkSlider) {
            return String(mark.key || '');
        }
    }
    return null;
}
/**
 * Processes single-axis filtering for scenarios without independent scales.
 *
 * @param params - Single-axis filtering parameters
 * @returns Filtered domain array
 */ function processSingleAxisFilteringWithDomainUpdate({ domain0, domain1, shouldFilterXAxis, enableAdaptiveFiltering, markDataPairs, adaptiveMode, scaleX, scaleY, channelDomain, hasOnlyXSlider, hasOnlyYSlider, isX }) {
    let filteredDomain = domain1;
    if (enableAdaptiveFiltering && markDataPairs.length > 0 && (hasOnlyXSlider && isX || hasOnlyYSlider && !isX) && (domain0 === null || domain0 === void 0 ? void 0 : domain0.length) > 0) {
        const singleAxisScaleInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractSingleAxisScaleInfo"])(shouldFilterXAxis, scaleX, scaleY);
        filteredDomain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["processSingleAxisFiltering"])({
            markDataPairs,
            domain: domain0,
            scaleInfo: singleAxisScaleInfo,
            adaptiveMode,
            shouldFilterXAxis
        });
        // Update channelDomain if filtering was applied
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$adaptiveFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateChannelDomains"])(channelDomain, filteredDomain, shouldFilterXAxis, false);
    }
    return filteredDomain;
}
/**
 * Creates the main value change handler for slider filtering.
 *
 * @param params - Handler creation parameters
 * @returns Throttled value change handler
 */ function createValueChangeHandler({ getFiltering, setFiltering, domainsOf, view, independentScaleInfo, enableAdaptiveFiltering, hasOnlyXSlider, hasOnlyYSlider, adaptiveMode, scaleX, scaleY, scale, channelDomain, channel0, channel1, isX, emitter, eventName, setState, slider, prefix, hasState, update, wait, leading, trailing }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>__awaiter(this, void 0, void 0, function*() {
            const { initValue = false } = event;
            if (getFiltering() && !initValue) {
                return;
            }
            setFiltering(true);
            const { nativeEvent = true } = event;
            const { markDataPairs } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractChannelValues"])(view);
            const hasIndependentScale = independentScaleInfo[`hasIndependent${channel1.toUpperCase()}`];
            if (hasIndependentScale) {
                // Handle multi-axis scenario
                const [domain0] = domainsOf(event);
                const shouldFilterXAxis = hasOnlyYSlider && !isX;
                const { filteredDomain, markToScaleMap } = processMultiAxisFiltering({
                    view,
                    domain0,
                    shouldFilterXAxis,
                    enableAdaptiveFiltering: enableAdaptiveFiltering && (hasOnlyXSlider && isX || hasOnlyYSlider && !isX),
                    markDataPairs,
                    adaptiveMode,
                    scaleX,
                    scaleY,
                    scale,
                    channelDomain,
                    independentScaleInfo,
                    channel0
                });
                // Update channelDomain to reflect the current filter state
                channelDomain[channel0] = domain0;
                emitFilterEvent(emitter, eventName, event, domain0, channelDomain, isX, nativeEvent);
                updateSliderState(setState, slider, view, {
                    domain0,
                    filteredDomain,
                    channel0,
                    channel1,
                    prefix,
                    hasState,
                    isMultiAxis: true,
                    markToScaleMap,
                    enableAdaptiveFiltering
                });
            } else {
                // Handle single-axis scenario
                const [domain0, domain1] = domainsOf(event);
                const shouldFilterXAxis = hasOnlyYSlider && !isX;
                const filteredDomain = processSingleAxisFilteringWithDomainUpdate({
                    domain0,
                    domain1,
                    shouldFilterXAxis,
                    enableAdaptiveFiltering,
                    markDataPairs,
                    adaptiveMode,
                    scaleX,
                    scaleY,
                    channelDomain,
                    hasOnlyXSlider,
                    hasOnlyYSlider,
                    isX
                });
                // Update channelDomain to reflect the current filter state
                channelDomain[channel0] = domain0;
                emitFilterEvent(emitter, eventName, event, domain0, channelDomain, isX, nativeEvent);
                updateSliderState(setState, slider, view, {
                    domain0,
                    filteredDomain,
                    channel0,
                    channel1,
                    prefix,
                    hasState,
                    isMultiAxis: false,
                    markToScaleMap: undefined,
                    enableAdaptiveFiltering
                });
            }
            yield update();
            setFiltering(false);
        }), wait, {
        leading,
        trailing
    });
} //# sourceMappingURL=sliderFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/sliderWheel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SliderWheel": (()=>SliderWheel)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$sliderFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/sliderFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
;
;
/**
 * SliderWheel interaction for mouse wheel/touchpad gestures on charts.
 */ /**
 * Get the real DOM canvas element from G2 container.
 * This helper function provides better type safety than using 'as any' directly.
 */ function getCanvasDOM(container) {
    var _a;
    try {
        const canvas = (_a = container.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
        if (!canvas || typeof canvas.getContextService !== 'function') {
            return null;
        }
        const dom = canvas.getContextService().getDomElement();
        return dom instanceof HTMLElement ? dom : null;
    } catch (_b) {
        return null;
    }
}
function SliderWheel({ className = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$sliderFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SLIDER_CLASS_NAME"], setValue = (component, values)=>component.setValues(values), minRange = 0.01, wheelSensitivity = 0.05, x = true, y = true } = {}) {
    return (context)=>{
        const { container, view } = context;
        const { coordinate } = view;
        const transposed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate);
        // Get the real DOM canvas element to attach wheel listener
        const canvasDOM = getCanvasDOM(container);
        const safeMinRange = Math.max(0.000001, Math.min(1, minRange));
        const sliders = container.getElementsByClassName(className);
        if (!sliders.length) return ()=>{};
        const isModifierKeyActive = (config, event)=>{
            if (config === true) return true;
            if (config === false) return false;
            if (config === 'shift') return event.shiftKey && !event.ctrlKey && !event.altKey;
            if (config === 'ctrl') return event.ctrlKey && !event.shiftKey && !event.altKey;
            if (config === 'alt') return event.altKey && !event.shiftKey && !event.ctrlKey;
            return false;
        };
        const triggerSliderValueChange = (slider, values)=>{
            setValue(slider, values);
            slider.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomEvent"]('valuechange', {
                detail: {
                    value: values
                },
                nativeEvent: true
            }));
        };
        /**
         * Calculate zoom center based on mouse position relative to slider track.
         * @param mousePos - Mouse position (X or Y) relative to canvas
         * @param sliderPos - Slider position (X or Y)
         * @param trackLength - Length of slider track
         * @param v0 - Current selection start value [0-1]
         * @param v1 - Current selection end value [0-1]
         * @returns Normalized center position [0-1] clamped to current selection
         */ const calculateZoomCenter = (mousePos, sliderPos, trackLength, v0, v1)=>{
            const relativePos = mousePos - sliderPos;
            const normalizedPosition = relativePos / trackLength;
            // Clamp to [0, 1] range first, then to current selection range
            const clamped = Math.max(0, Math.min(1, normalizedPosition));
            return Math.max(v0, Math.min(v1, clamped));
        };
        const handleWheel = (event)=>{
            // Early return if canvas DOM is not available
            if (!canvasDOM) return;
            // Check if the event target is within our canvas container
            const target = event.target;
            if (!canvasDOM.contains(target)) {
                return;
            }
            // Get mouse position relative to canvas
            const canvasRect = canvasDOM.getBoundingClientRect();
            const mouseX = event.clientX - canvasRect.left;
            const mouseY = event.clientY - canvasRect.top;
            // Find all sliders that should respond to this event
            const activeSliders = [];
            for (const slider of sliders){
                const { values, orientation } = slider.attributes;
                if (!values) continue;
                const isHorizontal = orientation === 'horizontal';
                const actualAxis = transposed ? isHorizontal ? 'y' : 'x' : isHorizontal ? 'x' : 'y';
                const axisConfig = actualAxis === 'x' ? x : y;
                if (isModifierKeyActive(axisConfig, event)) {
                    activeSliders.push(slider);
                }
            }
            // If no slider should handle this event, let it propagate
            if (activeSliders.length === 0) {
                return;
            }
            // Prevent page scroll since we have active sliders
            event.preventDefault();
            event.stopPropagation();
            // Process all active sliders
            for (const slider of activeSliders){
                const { values, orientation, x: sliderX, y: sliderY, trackLength } = slider.attributes;
                const [v0, v1] = values;
                const range = v1 - v0;
                const isHorizontal = orientation === 'horizontal';
                // Calculate zoom center based on mouse position relative to slider
                const center = isHorizontal ? calculateZoomCenter(mouseX, sliderX, trackLength, v0, v1) : calculateZoomCenter(mouseY, sliderY, trackLength, v0, v1);
                const adaptiveSensitivity = wheelSensitivity * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateSensitivityMultiplier"])(range);
                const delta = event.deltaY * adaptiveSensitivity;
                const zoomFactor = 1 + delta;
                const newRange = Math.max(safeMinRange, Math.min(1, range * zoomFactor));
                // Calculate new range boundaries based on mouse position
                // The zoom should maintain the ratio of distances from center to edges
                const leftRatio = (center - v0) / range;
                const rightRatio = (v1 - center) / range;
                let newV0 = center - newRange * leftRatio;
                let newV1 = center + newRange * rightRatio;
                // Handle boundary conditions while trying to maintain mouse position as center
                if (newV0 < 0) {
                    newV0 = 0;
                    newV1 = Math.min(1, newRange);
                } else if (newV1 > 1) {
                    newV1 = 1;
                    newV0 = Math.max(0, 1 - newRange);
                }
                triggerSliderValueChange(slider, [
                    newV0,
                    newV1
                ]);
            }
        };
        // Listen on the real DOM canvas element with passive: false AND capture: true
        // Capture phase ensures we intercept BEFORE @antv/g-canvas's passive listener
        // This is the only way to preventDefault() before the passive listener receives it
        if (canvasDOM) {
            canvasDOM.addEventListener('wheel', handleWheel, {
                passive: false,
                capture: true
            });
        }
        return ()=>{
            if (canvasDOM) {
                canvasDOM.removeEventListener('wheel', handleWheel, {
                    capture: true
                });
            }
        };
    };
}
SliderWheel.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=sliderWheel.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/scrollbarFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SCROLLBAR_CLASS_NAME": (()=>SCROLLBAR_CLASS_NAME),
    "ScrollbarFilter": (()=>ScrollbarFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$sliderFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/sliderFilter.js [app-client] (ecmascript)");
;
const SCROLLBAR_CLASS_NAME = 'g2-scrollbar';
function ScrollbarFilter(options = {}) {
    return (context, _, emitter)=>{
        const { view, container } = context;
        const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
        if (!scrollbars.length) return ()=>{};
        const { scale } = view;
        const { x: scaleX, y: scaleY } = scale;
        // The filtered domain, computed by the ratio attribute.
        const initDomain = {
            x: [
                ...scaleX.getOptions().domain
            ],
            y: [
                ...scaleY.getOptions().domain
            ]
        };
        // The ordinal domain for each channel.
        scaleX.update({
            domain: scaleX.getOptions().expectedDomain
        });
        scaleY.update({
            domain: scaleY.getOptions().expectedDomain
        });
        const interaction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$sliderFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SliderFilter"])(Object.assign({
            initDomain,
            className: SCROLLBAR_CLASS_NAME,
            prefix: 'scrollbar',
            hasState: true,
            setValue: (component, values)=>component.setValue(values[0]),
            getInitValues: (scrollbar)=>{
                const values = scrollbar.slider.attributes.values;
                if (values[0] !== 0 || values[1] !== 1) return values;
            }
        }, options));
        return interaction(context, _, emitter);
    };
} //# sourceMappingURL=scrollbarFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/poptip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Poptip": (()=>Poptip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
function dom(tag, children, style) {
    return `<${tag} style="${Object.entries(style).map(([key, value])=>`${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kebabCase"])(key)}:${value}`).join(';')}">${children}</${tag}>`;
}
const defaultTipStyle = {
    backgroundColor: 'rgba(0,0,0,0.75)',
    color: '#fff',
    width: 'max-content',
    padding: '1px 4px',
    fontSize: '12px',
    borderRadius: '2.5px',
    boxShadow: '0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)'
};
function isTipText(element) {
    if (element.nodeName !== 'text') return false;
    if (element.isOverflowing()) return true;
    return false;
}
function Poptip(_a) {
    var { offsetX = 8, offsetY = 8 } = _a, style = __rest(_a, [
        "offsetX",
        "offsetY"
    ]);
    return (context)=>{
        const { container } = context;
        const [x0, y0] = container.getBounds().min;
        const tipStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'tip');
        const tips = new Set();
        const pointerover = (e)=>{
            const { target } = e;
            if (!isTipText(target)) {
                e.stopPropagation();
                return;
            }
            const { offsetX: mouseX, offsetY: mouseY } = e;
            const x = mouseX + offsetX - x0;
            const y = mouseY + offsetY - y0;
            if (target.tip) {
                target.tip.style.x = x;
                target.tip.style.y = y;
                return;
            }
            const { text } = target.style;
            const tipELement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HTML"]({
                className: 'poptip',
                style: {
                    innerHTML: dom('div', text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
                    x,
                    y
                }
            });
            container.appendChild(tipELement);
            target.tip = tipELement;
            tips.add(tipELement);
        };
        const pointerout = (e)=>{
            const { target } = e;
            if (!isTipText(target)) {
                e.stopPropagation();
                return;
            }
            if (!target.tip) return;
            target.tip.remove();
            target.tip = null;
            tips.delete(target.tip);
        };
        container.addEventListener('pointerover', pointerover);
        container.addEventListener('pointerout', pointerout);
        return ()=>{
            container.removeEventListener('pointerover', pointerover);
            container.removeEventListener('pointerout', pointerout);
            tips.forEach((tip)=>tip.remove());
        };
    };
}
Poptip.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=poptip.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/treemapDrillDown.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "TreemapDrillDown": (()=>TreemapDrillDown)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__size$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/size.js [app-client] (ecmascript) <export default as size>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/legendFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$treeDataTransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/treeDataTransform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/last.js [app-client] (ecmascript) <export default as last>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/find.js [app-client] (ecmascript) <export default as find>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$keys$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__keys$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/keys.js [app-client] (ecmascript) <export default as keys>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pick$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/pick.js [app-client] (ecmascript) <export default as pick>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
function selectPlotArea(root) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(root).select(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"]}`).node();
}
// Default breadCrumb config.
const DEFAULT_BREADCRUMB_STYLE = {
    breadCrumbFill: 'rgba(0, 0, 0, 0.85)',
    breadCrumbFontSize: 12,
    breadCrumbY: 12,
    activeFill: 'rgba(0, 0, 0, 0.5)'
};
function TreemapDrillDown(drillDownOptions = {}) {
    const { originData = [], layout } = drillDownOptions, style = __rest(drillDownOptions, [
        "originData",
        "layout"
    ]);
    const breadCrumb = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, DEFAULT_BREADCRUMB_STYLE, style);
    const breadCrumbStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(breadCrumb, 'breadCrumb');
    const breadCrumbActiveStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(breadCrumb, 'active');
    return (context)=>{
        const { update, setState, container, options } = context;
        const plotArea = selectPlotArea(container);
        const mark = options.marks[0];
        const { state } = mark;
        // Create breadCrumbTextsGroup,save textSeparatordrillTexts.
        const textGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        plotArea.appendChild(textGroup);
        // Modify the data and scale according to the path and the level of the current click, so as to achieve the effect of drilling down and drilling up and initialization.
        const drillDownClick = (path, depth)=>__awaiter(this, void 0, void 0, function*() {
                // Clear text.
                textGroup.removeChildren();
                // More path creation text.
                if (depth) {
                    let name = '';
                    let y = breadCrumbStyle.y;
                    let x = 0;
                    const textPath = [];
                    const maxWidth = plotArea.getBBox().width;
                    // Create path: 'type1 / type2 / type3' -> '/ type1 / type2 / type3'.
                    const drillTexts = path.map((text, index)=>{
                        name = `${name}${text}/`;
                        textPath.push(text);
                        const drillText = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
                            name: name.replace(/\/$/, ''),
                            style: Object.assign(Object.assign({
                                text,
                                x,
                                // @ts-ignore
                                path: [
                                    ...textPath
                                ],
                                depth: index
                            }, breadCrumbStyle), {
                                y
                            })
                        });
                        textGroup.appendChild(drillText);
                        x += drillText.getBBox().width;
                        const textSeparator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
                            style: Object.assign(Object.assign({
                                x,
                                text: ' / '
                            }, breadCrumbStyle), {
                                y
                            })
                        });
                        textGroup.appendChild(textSeparator);
                        x += textSeparator.getBBox().width;
                        /**
                     * Page width exceeds maximum, line feed.
                     * | ----maxWidth---- |
                     * | / tyep1 / tyep2 / type3 |
                     * ->
                     * | ----maxWidth---- |
                     * | / tyep1 / tyep2  |
                     * | / type3 |
                     */ if (x > maxWidth) {
                            y = textGroup.getBBox().height + breadCrumbStyle.y;
                            x = 0;
                            drillText.attr({
                                x,
                                y
                            });
                            x += drillText.getBBox().width;
                            textSeparator.attr({
                                x,
                                y
                            });
                            x += textSeparator.getBBox().width;
                        }
                        if (index === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__size$3e$__["size"])(path) - 1) {
                            textSeparator.remove();
                        }
                        return drillText;
                    });
                    // Add Active, Add TreemapDrillDown
                    drillTexts.forEach((item, index)=>{
                        // Last drillText
                        if (index === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__size$3e$__["size"])(drillTexts) - 1) return;
                        const originalAttrs = Object.assign({}, item.attributes);
                        item.attr('cursor', 'pointer');
                        item.addEventListener('mouseenter', ()=>{
                            item.attr(breadCrumbActiveStyle);
                        });
                        item.addEventListener('mouseleave', ()=>{
                            item.attr(originalAttrs);
                        });
                        item.addEventListener('click', ()=>{
                            drillDownClick((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                'style',
                                'path'
                            ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                'style',
                                'depth'
                            ]));
                        });
                    });
                }
                // LegendFilter interaction and treemapDrillDown clash.
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["legendClearSetState"])(container, setState);
                // Update marks.
                setState('treemapDrillDown', (viewOptions)=>{
                    const { marks } = viewOptions;
                    // Add filter transform for every marks,
                    // which will skip for mark without color channel.
                    const strPath = path.join('/');
                    const newMarks = marks.map((mark)=>{
                        if (mark.type !== 'rect') return mark;
                        let newData = originData;
                        if (depth) {
                            const filterData = originData.filter((item)=>{
                                const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                    'id'
                                ]);
                                return id && (id.match(`${strPath}/`) || strPath.match(id));
                            }).map((item)=>({
                                    value: item.height === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                        'value'
                                    ]) : undefined,
                                    name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                        'id'
                                    ])
                                }));
                            const { paddingLeft, paddingBottom, paddingRight } = layout;
                            // New drill layout for calculation x y and filtration data.
                            const newLayout = Object.assign(Object.assign({}, layout), {
                                paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1),
                                paddingLeft: paddingLeft / (depth + 1),
                                paddingBottom: paddingBottom / (depth + 1),
                                paddingRight: paddingRight / (depth + 1),
                                path: (d)=>d.name,
                                layer: (d)=>d.depth === depth + 1
                            });
                            // Transform the new matrix tree data.
                            newData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$treeDataTransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["treeDataTransform"])(filterData, newLayout, {
                                value: 'value'
                            })[0];
                        } else {
                            newData = originData.filter((item)=>{
                                return item.depth === 1;
                            });
                        }
                        const colorDomain = [];
                        newData.forEach(({ path })=>{
                            colorDomain.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__["last"])(path));
                        });
                        // TreemapDrillDown by filtering the data and scale.
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, mark, {
                            data: newData,
                            scale: {
                                color: {
                                    domain: colorDomain
                                }
                            }
                        });
                    });
                    return Object.assign(Object.assign({}, viewOptions), {
                        marks: newMarks
                    });
                });
                // The second argument is to allow the legendFilter event to be re-added; the update method itself causes legend to lose the interaction event.
                yield update(undefined, [
                    'legendFilter'
                ]);
            });
        //
        const keyofLabel = (d)=>d.attributes.key.split('-')[0];
        const keyofRect = (d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(d, [
                '__data__',
                'key'
            ]);
        // Elements and BreadCrumb click.
        const createDrillClick = (e)=>{
            const item = e.target;
            const { markType, nodeName, attributes } = item || {};
            if (markType !== 'rect' && nodeName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Shape"].TEXT) return;
            const key = nodeName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Shape"].TEXT && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(attributes, 'isTreemapLabel') === true ? keyofLabel(item) : keyofRect(item);
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(originData, (d)=>d.id === key);
            // Node height = 0 no children
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(node, 'height')) {
                drillDownClick((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(node, 'path'), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(node, 'depth'));
            }
        };
        // Add click drill interaction.
        plotArea.addEventListener('click', createDrillClick);
        // Change attributes keys.
        const changeStyleKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$keys$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__keys$3e$__["keys"])(Object.assign(Object.assign({}, state.active), state.inactive));
        const createActive = ()=>{
            const elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getElements"])(plotArea);
            elements.forEach((element)=>{
                const cursor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
                    'style',
                    'cursor'
                ]);
                const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(originData, (d)=>d.id === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
                        '__data__',
                        'key'
                    ]));
                if (cursor !== 'pointer' && (node === null || node === void 0 ? void 0 : node.height)) {
                    element.style.cursor = 'pointer';
                    const originalAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pick$3e$__["pick"])(element.attributes, changeStyleKey);
                    element.addEventListener('mouseenter', ()=>{
                        element.attr(state.active);
                    });
                    element.addEventListener('mouseleave', ()=>{
                        element.attr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(originalAttrs, state.inactive));
                    });
                }
            });
        };
        createActive();
        // Animate elements update, Add active.
        plotArea.addEventListener('mousemove', createActive);
        return ()=>{
            textGroup.remove();
            plotArea.removeEventListener('click', createDrillClick);
            plotArea.removeEventListener('mousemove', createActive);
        };
    };
} //# sourceMappingURL=treemapDrillDown.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementPointMove.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementPointMove": (()=>ElementPointMove)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/find.js [app-client] (ecmascript) <export default as find>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$undefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isUndefined$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/is-undefined.js [app-client] (ecmascript) <export default as isUndefined>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
const DEFAULT_STYLE = {
    pointR: 6,
    pointStrokeWidth: 1,
    pointStroke: '#888',
    pointActiveStroke: '#f5f5f5',
    pathStroke: '#888',
    pathLineDash: [
        3,
        4
    ],
    labelFontSize: 12,
    labelFill: '#888',
    labelStroke: '#fff',
    labelLineWidth: 1,
    labelY: -6,
    labelX: 2
};
// point shape name.
const MOVE_POINT_NAME = 'movePoint';
// Element mouseenter change style.
const elementMouseenter = (e)=>{
    const element = e.target;
    const { markType } = element;
    // Mark line.
    if (markType === 'line') {
        element.attr('_lineWidth', element.attr('lineWidth') || 1);
        element.attr('lineWidth', element.attr('_lineWidth') + 3);
    }
    // Mark interval.
    if (markType === 'interval') {
        element.attr('_opacity', element.attr('opacity') || 1);
        element.attr('opacity', 0.7 * element.attr('_opacity'));
    }
};
// Element mouseleave change style.
const elementMouseleave = (e)=>{
    const element = e.target;
    const { markType } = element;
    // Mark line.
    if (markType === 'line') {
        element.attr('lineWidth', element.attr('_lineWidth'));
    }
    // Mark interval.
    if (markType === 'interval') {
        element.attr('opacity', element.attr('_opacity'));
    }
};
// Get the latest overall data based on the individual data changes.
const getNewData = (newChangeData, data, encode)=>{
    return data.map((d)=>{
        const isUpdate = [
            'x',
            'color'
        ].reduce((v, key)=>{
            const field = encode[key];
            if (!field) return v;
            if (d[field] !== newChangeData[field]) return false;
            return v;
        }, true);
        return isUpdate ? Object.assign(Object.assign({}, d), newChangeData) : d;
    });
};
// Find mark interval origin element data.
const getIntervalDataRatioTransformFn = (element)=>{
    const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'y'
    ]);
    const y1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'y1'
    ]);
    const v = y1 - y;
    const { __data__: { data, encode, transform }, childNodes } = element.parentNode;
    const isNormalizeY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(transform, ({ type })=>type === 'normalizeY');
    const yField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(encode, [
        'y',
        'field'
    ]);
    const value = data[childNodes.indexOf(element)][yField];
    return (newValue, isTheta = false)=>{
        if (isNormalizeY || isTheta) {
            return newValue / (1 - newValue) / (v / (1 - v)) * value;
        }
        return newValue;
    };
};
// Find origin path data.
const getPathDataRatioTransformFn = (element, index)=>{
    const v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'seriesItems',
        index,
        '0',
        'value'
    ]);
    const i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'seriesIndex',
        index
    ]);
    const { __data__: { data, encode, transform } } = element.parentNode;
    const isNormalizeY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(transform, ({ type })=>type === 'normalizeY');
    const yField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(encode, [
        'y',
        'field'
    ]);
    const value = data[i][yField];
    return (newValue)=>{
        if (isNormalizeY) {
            if (v === 1) {
                return newValue;
            }
            return newValue / (1 - newValue) / (v / (1 - v)) * value;
        }
        return newValue;
    };
};
// Point shape select change style.
const selectedPointsStyle = (pointsShape, selection, defaultStyle)=>{
    pointsShape.forEach((shape, index)=>{
        shape.attr('stroke', selection[1] === index ? defaultStyle['activeStroke'] : defaultStyle['stroke']);
    });
};
// Create help show message shape.
const createHelpShape = (group, circle, pathStyle, labelStyle)=>{
    const pathShape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]({
        style: pathStyle
    });
    const labelShape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
        style: labelStyle
    });
    circle.appendChild(labelShape);
    group.appendChild(pathShape);
    return [
        pathShape,
        labelShape
    ];
};
// Get color scale type.
const getColorType = (scaleColor, color)=>{
    const indexOf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(scaleColor, [
        'options',
        'range',
        'indexOf'
    ]);
    if (!indexOf) return;
    const i = scaleColor.options.range.indexOf(color);
    return scaleColor.sortedDomain[i];
};
// Get the same direction new point.
const getSamePointPosition = (center, point, target)=>{
    const oldR = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsR"])(center, point);
    const newR = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsR"])(center, target);
    const ratio = newR / oldR;
    const newX = center[0] + (point[0] - center[0]) * ratio;
    const newY = center[1] + (point[1] - center[1]) * ratio;
    return [
        newX,
        newY
    ];
};
function ElementPointMove(elementPointMoveOptions = {}) {
    const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest(elementPointMoveOptions, [
        "selection",
        "precision"
    ]);
    const defaultStyle = Object.assign(Object.assign({}, DEFAULT_STYLE), style || {});
    // Shape default style.
    const pathDefaultStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(defaultStyle, 'path');
    const labelDefaultStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(defaultStyle, 'label');
    const pointDefaultStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(defaultStyle, 'point');
    return (context, _, emitter)=>{
        const { update, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        let elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getElements"])(plotArea);
        let newState;
        let newSelection = selection;
        const { transform = [], type: coordinateType } = coordinateOptions;
        const isTranspose = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(transform, ({ type })=>type === 'transpose');
        const isPolar = coordinateType === 'polar';
        const isTheta = coordinateType === 'theta';
        const isArea = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(elements, ({ markType })=>markType === 'area');
        if (isArea) {
            elements = elements.filter(({ markType })=>markType === 'area');
        }
        // Create points
        const pointsGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]({
            style: {
                // Tooltip point need down.
                zIndex: 2
            }
        });
        plotArea.appendChild(pointsGroup);
        const selectedChange = ()=>{
            emitter.emit('element-point:select', {
                nativeEvent: true,
                data: {
                    selection: newSelection
                }
            });
        };
        const dataChange = (changeData, data)=>{
            emitter.emit('element-point:moved', {
                nativeEvent: true,
                data: {
                    changeData,
                    data
                }
            });
        };
        // Element click change style.
        const elementClick = (e)=>{
            const element = e.target;
            newSelection = [
                element.parentNode.childNodes.indexOf(element)
            ];
            selectedChange();
            createPoints(element);
        };
        const elementSelect = (d)=>{
            const { data: { selection }, nativeEvent } = d;
            if (nativeEvent) return;
            newSelection = selection;
            const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(elements, [
                newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]
            ]);
            if (element) {
                createPoints(element);
            }
        };
        // Create select element points.
        const createPoints = (element)=>{
            const { attributes, markType, __data__: data } = element;
            const { stroke: fill } = attributes;
            const { points, seriesTitle, color, title, seriesX, y1 } = data;
            // Transpose Currently only do mark interval;
            if (isTranspose && markType !== 'interval') return;
            const { scale, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
            const { color: scaleColor, y: scaleY, x: scaleX } = scale;
            const center = coordinate.getCenter();
            pointsGroup.removeChildren();
            let downPoint;
            const updateView = (x, y, color, markTypes)=>__awaiter(this, void 0, void 0, function*() {
                    setState('elementPointMove', (viewOptions)=>{
                        var _a;
                        // Update marks.
                        const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map((mark)=>{
                            if (!markTypes.includes(mark.type)) return mark;
                            const { data, encode } = mark;
                            const encodeKeys = Object.keys(encode);
                            // Get change new one element data.
                            const newChangeData = encodeKeys.reduce((value, key)=>{
                                const dataKey = encode[key];
                                if (key === 'x') {
                                    value[dataKey] = x;
                                }
                                if (key === 'y') {
                                    value[dataKey] = y;
                                }
                                if (key === 'color') {
                                    value[dataKey] = color;
                                }
                                return value;
                            }, {});
                            // Get change new all data.
                            const newData = getNewData(newChangeData, data, encode);
                            dataChange(newChangeData, newData);
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, mark, {
                                data: newData,
                                // No need animate
                                animate: false
                            });
                        });
                        return Object.assign(Object.assign({}, viewOptions), {
                            marks: newMarks
                        });
                    });
                    return yield update('elementPointMove');
                });
            if ([
                'line',
                'area'
            ].includes(markType)) {
                points.forEach((p, index)=>{
                    const title = scaleX.invert(seriesX[index]);
                    // Area points have bottom point.
                    if (!title) return;
                    const circle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
                        name: MOVE_POINT_NAME,
                        style: Object.assign({
                            cx: p[0],
                            cy: p[1],
                            fill
                        }, pointDefaultStyle)
                    });
                    const ratioTransform = getPathDataRatioTransformFn(element, index);
                    circle.addEventListener('mousedown', (e)=>{
                        const oldPoint = coordinate.output([
                            seriesX[index],
                            0
                        ]);
                        const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
                        container.attr('cursor', 'move');
                        if (newSelection[1] !== index) {
                            newSelection[1] = index;
                            selectedChange();
                        }
                        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
                        const [pathShape, labelShape] = createHelpShape(pointsGroup, circle, pathDefaultStyle, labelDefaultStyle);
                        // Point move change text
                        const pointMousemove = (e)=>{
                            const newCy = p[1] + e.clientY - downPoint[1];
                            // Area/Radar chart.
                            if (isArea) {
                                // Radar chart.
                                if (isPolar) {
                                    const newCx = p[0] + e.clientX - downPoint[0];
                                    const [newX, newY] = getSamePointPosition(center, oldPoint, [
                                        newCx,
                                        newCy
                                    ]);
                                    const [, initY] = coordinate.output([
                                        1,
                                        scaleY.output(0)
                                    ]);
                                    const [, y] = coordinate.invert([
                                        newX,
                                        initY - (points[index + pathLength][1] - newY)
                                    ]);
                                    const nextIndex = (index + 1) % pathLength;
                                    const lastIndex = (index - 1 + pathLength) % pathLength;
                                    const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                        points[lastIndex],
                                        [
                                            newX,
                                            newY
                                        ],
                                        seriesTitle[nextIndex] && points[nextIndex]
                                    ]);
                                    labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));
                                    pathShape.attr('d', newPath);
                                    circle.attr('cx', newX);
                                    circle.attr('cy', newY);
                                } else {
                                    // Area chart.
                                    const [, initY] = coordinate.output([
                                        1,
                                        scaleY.output(0)
                                    ]);
                                    const [, y] = coordinate.invert([
                                        p[0],
                                        initY - (points[index + pathLength][1] - newCy)
                                    ]);
                                    const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                        points[index - 1],
                                        [
                                            p[0],
                                            newCy
                                        ],
                                        seriesTitle[index + 1] && points[index + 1]
                                    ]);
                                    labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));
                                    pathShape.attr('d', newPath);
                                    circle.attr('cy', newCy);
                                }
                            } else {
                                // Line chart.
                                const [, y] = coordinate.invert([
                                    p[0],
                                    newCy
                                ]);
                                const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                    points[index - 1],
                                    [
                                        p[0],
                                        newCy
                                    ],
                                    points[index + 1]
                                ]);
                                labelShape.attr('text', scaleY.invert(y).toFixed(precision));
                                pathShape.attr('d', newPath);
                                circle.attr('cy', newCy);
                            }
                        };
                        downPoint = [
                            e.clientX,
                            e.clientY
                        ];
                        window.addEventListener('mousemove', pointMousemove);
                        const mouseupFn = ()=>__awaiter(this, void 0, void 0, function*() {
                                container.attr('cursor', 'default');
                                window.removeEventListener('mousemove', pointMousemove);
                                container.removeEventListener('mouseup', mouseupFn);
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$undefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isUndefined$3e$__["isUndefined"])(labelShape.attr('text'))) return;
                                const y = Number(labelShape.attr('text'));
                                const colorType = getColorType(scaleColor, color);
                                newState = yield updateView(title, y, colorType, [
                                    'line',
                                    'area'
                                ]);
                                labelShape.remove();
                                pathShape.remove();
                                createPoints(element);
                            });
                        container.addEventListener('mouseup', mouseupFn);
                    });
                    pointsGroup.appendChild(circle);
                });
                selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
            } else if (markType === 'interval') {
                // Column chart point.
                let circlePoint = [
                    (points[0][0] + points[1][0]) / 2,
                    points[0][1]
                ];
                // Bar chart point.
                if (isTranspose) {
                    circlePoint = [
                        points[0][0],
                        (points[0][1] + points[1][1]) / 2
                    ];
                } else if (isTheta) {
                    // Pie chart point.
                    circlePoint = points[0];
                }
                const ratioTransform = getIntervalDataRatioTransformFn(element);
                const circle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
                    name: MOVE_POINT_NAME,
                    style: Object.assign(Object.assign({
                        cx: circlePoint[0],
                        cy: circlePoint[1],
                        fill
                    }, pointDefaultStyle), {
                        stroke: pointDefaultStyle['activeStroke']
                    })
                });
                circle.addEventListener('mousedown', (e)=>{
                    container.attr('cursor', 'move');
                    const colorType = getColorType(scaleColor, color);
                    const [pathShape, labelShape] = createHelpShape(pointsGroup, circle, pathDefaultStyle, labelDefaultStyle);
                    // Point move change text
                    const pointMousemove = (e)=>{
                        if (isTranspose) {
                            // Bar chart.
                            const newCx = circlePoint[0] + e.clientX - downPoint[0];
                            const [initX] = coordinate.output([
                                scaleY.output(0),
                                scaleY.output(0)
                            ]);
                            const [, x] = coordinate.invert([
                                initX + (newCx - points[2][0]),
                                circlePoint[1]
                            ]);
                            const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                [
                                    newCx,
                                    points[0][1]
                                ],
                                [
                                    newCx,
                                    points[1][1]
                                ],
                                points[2],
                                points[3]
                            ], true);
                            labelShape.attr('text', ratioTransform(scaleY.invert(x)).toFixed(precision));
                            pathShape.attr('d', newPath);
                            circle.attr('cx', newCx);
                        } else if (isTheta) {
                            // Pie chart.
                            const newCy = circlePoint[1] + e.clientY - downPoint[1];
                            const newCx = circlePoint[0] + e.clientX - downPoint[0];
                            const [newXOut, newYOut] = getSamePointPosition(center, [
                                newCx,
                                newCy
                            ], circlePoint);
                            const [newXIn, newYIn] = getSamePointPosition(center, [
                                newCx,
                                newCy
                            ], points[1]);
                            const lastPercent = coordinate.invert([
                                newXOut,
                                newYOut
                            ])[1];
                            const percent = y1 - lastPercent;
                            if (percent < 0) return;
                            const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getThetaPath"])(center, [
                                [
                                    newXOut,
                                    newYOut
                                ],
                                [
                                    newXIn,
                                    newYIn
                                ],
                                points[2],
                                points[3]
                            ], percent > 0.5 ? 1 : 0);
                            labelShape.attr('text', ratioTransform(percent, true).toFixed(precision));
                            pathShape.attr('d', newPath);
                            circle.attr('cx', newXOut);
                            circle.attr('cy', newYOut);
                        } else {
                            // Column chart.
                            const newCy = circlePoint[1] + e.clientY - downPoint[1];
                            const [, initY] = coordinate.output([
                                1,
                                scaleY.output(0)
                            ]);
                            const [, y] = coordinate.invert([
                                circlePoint[0],
                                initY - (points[2][1] - newCy)
                            ]);
                            const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                [
                                    points[0][0],
                                    newCy
                                ],
                                [
                                    points[1][0],
                                    newCy
                                ],
                                points[2],
                                points[3]
                            ], true);
                            labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));
                            pathShape.attr('d', newPath);
                            circle.attr('cy', newCy);
                        }
                    };
                    downPoint = [
                        e.clientX,
                        e.clientY
                    ];
                    window.addEventListener('mousemove', pointMousemove);
                    // Change mosueup change data and update clear shape.
                    const mouseupFn = ()=>__awaiter(this, void 0, void 0, function*() {
                            container.attr('cursor', 'default');
                            container.removeEventListener('mouseup', mouseupFn);
                            window.removeEventListener('mousemove', pointMousemove);
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$undefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isUndefined$3e$__["isUndefined"])(labelShape.attr('text'))) return;
                            const y = Number(labelShape.attr('text'));
                            newState = yield updateView(title, y, colorType, [
                                markType
                            ]);
                            labelShape.remove();
                            pathShape.remove();
                            createPoints(element);
                        });
                    container.addEventListener('mouseup', mouseupFn);
                });
                pointsGroup.appendChild(circle);
            }
        };
        // Add EventListener.
        elements.forEach((element, index)=>{
            if (newSelection[0] === index) {
                createPoints(element);
            }
            element.addEventListener('click', elementClick);
            element.addEventListener('mouseenter', elementMouseenter);
            element.addEventListener('mouseleave', elementMouseleave);
        });
        const rootClick = (e)=>{
            const element = e === null || e === void 0 ? void 0 : e.target;
            if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
                newSelection = [];
                selectedChange();
                pointsGroup.removeChildren();
            }
        };
        emitter.on('element-point:select', elementSelect);
        emitter.on('element-point:unselect', rootClick);
        container.addEventListener('mousedown', rootClick);
        // Remove EventListener.
        return ()=>{
            pointsGroup.remove();
            emitter.off('element-point:select', elementSelect);
            emitter.off('element-point:unselect', rootClick);
            container.removeEventListener('mousedown', rootClick);
            elements.forEach((element)=>{
                element.removeEventListener('click', elementClick);
                element.removeEventListener('mouseenter', elementMouseenter);
                element.removeEventListener('mouseleave', elementMouseleave);
            });
        };
    };
} //# sourceMappingURL=elementPointMove.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40antv_g2_esm_interaction_c2f3cb._.js.map